<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>source/data-transfer.js - skylinkjs</title>
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <style>
      body {
        font-family: 'Source Sans Pro', sans-serif, helvetica;
      }
      pre, code {
        font-family: 'Source Code Pro', consolas, helvetica, sans-serif;
      }
      /* Bootstrap override */
      h1, h2, h3 {
        font-weight: 300;
      }
      h1 span,
      h2 span,
      h3 span {
        font-size: 28px;
        color: #888;
      }
      h1 small,
      h2 small,
      h3 small {
        display: block;
        font-size: 14px;
        margin-top: 10px;
      }
      .badge {
        margin-top: -5px;
        margin-left: 5px;
        font-weight: normal;
      }
      h3 code {
        background: transparent;
        padding: 0;
      }
      .navbar-brand {
        color: #888!important;
        font-weight: bold;
      }
      .navbar-brand small {
        font-size: 12px;
        text-transform: uppercase;
        font-weight: 300;
        margin-left: 15px;
        color: #fff!important;
      }
      .navbar-brand img {
        width: 90px;
        margin-top: -5px;
      }
      .jumbotron hr {
        border-top-color: #888;
      }
      .list-group {
        border-radius: 0!important;
        -webkit-box-shadow: none;
        box-shadow: none;
      }
      .list-group .list-group-item {
        border: 0;
        border-radius: 0!important;
        margin-bottom: 10px;
        padding: 1px 7px;
      }
      .list-group .list-group-item span.settings {
        display: block;
        margin-top: 5px;
      }
      .section-doc-group .col-md-3 {
        padding-left: 0;
      }
      .section-doc-group .col-md-9 {
        padding-right: 0;
        padding-left: 55px;
      }
      .list-group .list-group-item.active {
        color: #428bca;
        text-shadow: none;
        background: transparent;
        border-left: solid 4px #428bca;
      }
      .list-group h4 {
        margin: 0;
      }
      .no-padding {
        padding: 0;
      }
      .code-item-name {
        margin-top: 0;
      }
      .prettyprint {
        border: double 2px #ccc!important; /* override */
        margin-top: 15px;
        border-radius: 0;
        border-left: 0!important;
        border-right: 0!important;
      }
      /* documentation styling */
      .private-method-item,
      .private-event-item,
      .private-property-item,
      .private-attr-item {
        display: none;
      }
      .list-group-o-wrapper {
        background: #fff;
      }
      .list-group-o-wrapper span.title {
        font-size: 22px;
        font-weight: 300;
        margin: 15px;
        display: none;
      }
      .list-group-wrapper {
        overflow-y: auto;
      }
      .property-item,
      .event-item,
      .attr-item {
        display: none;
      }
      /* to always show the constructor */
      .constructor-item .method-item {
        display: block!important;
      }
      .code-item {
        min-height: 0;
      }
      .code-item h4 {
        font-size: 15px;
        text-transform: uppercase;
      }
      .code-item-trigger a {
        font-weight: normal;
        margin-right: 15px;
      }
      .code-item-properties {
        margin: 15px 0;
        padding: 5px 0;
        border: solid 1px #eee;
        border-left: 0;
        border-right: 0;
      }
      .code-item-properties .label {
        font-weight: normal;
        text-transform: uppercase;
      }
      .code-item-properties small {
        display: block;
        margin: 5px 0;
      }
      .code-item-properties .badge {
        background: #aaa;
      }
      .code-item-information {
        margin: 15px 0;
        padding: 2px 7px;
        border-left: solid 4px #f0f0f8;
      }
      .code-item-information span {
        display: block;
        margin: 5px 0;
      }
      .code-item-section {
        margin: 35px 0 45px;
      }
      .code-item-type i {
        font-style: normal;
        text-transform: uppercase;
        margin-right: 15px;
      }
      .params-list .param {
        margin-bottom: 7px;
      }
      .params-list .param .type {
        margin-left: 10px;
        color: #888;
        font-size: 12px;
      }
      .params-list .param .label {
        font-size: 10px;
        /*font-weight: normal;*/
        text-transform: uppercase;
        margin-left: 5px;
        opacity: 0.85;
        background: #eee;
        color: #888;
      }
      .params-list .param .label.multiple {
        background: #f0ad4e;
        color: #fff;
      }
      .returns-description span,
      .returns-description p {
        display: inline-block;
      }
      .returns-description .type {
        margin-right: 15px;
      }
      .checkbox-selected-highlight {
        padding: 2px 7px;
        border: solid 1px #eee;
        border-left: 0;
        border-right: 0;
        background: #fafafa;
      }
      @media (max-width: 991px) {
        .section-doc-group .col-md-3 {
          display: none;
        }
        .section-doc-group .col-md-9 {
          padding-left: 0;
        }
      }
    </style>
    <script>
      var displayPrivateMode = false;
      $(document).ready(function () {
        // seperate every arguments seperator
        $('.args').each(function () {
          var length = $(this).find('.seperator').length;
          // remove the last item
          $(this).find('.seperator')[length - 1].remove();
        });
        // seperate every code-item-trigger
        $('.code-item-trigger').each(function () {
          var content = $(this).html().split(',');
          var outputContent = '';
          for (var i = 0; i < content.length; i++) {
            outputContent += '<a href="#event_' + content[i] + '" class="label label-primary">' + content[i] + '</a>';
          }
          $(this).html(outputContent);
        });
        // set the current window tab
        setSelectedTab($('.doc-selected.active').find('a').attr('href').split('#')[1]);
        // remove unwanted code information
        $('.code-item-information').each(function () {
          if ($(this).find('span').length === 0) {
            $(this).hide();
          }
        });
        // set the private option
        $('#doc-private-select').change(function () {
          displayPrivateMode = $(this).is(':checked');
          setSelectedTab(window.location.hash.split('#')[1]);
        });
      });
      // check the select doc item
      function setSelectedTab (currentSelectedTab) {
        $('.code-item').hide();
        $('.code-menu-item').hide();
        $('.code-item.private').hide();
        $('.code-menu-item.private').hide();

        console.info(currentSelectedTab, currentSelectedTab.indexOf('method') === 0);

        if (currentSelectedTab === 'events' || currentSelectedTab.indexOf('event_') === 0) {
          if (displayPrivateMode) {
            $('.private-event-item').fadeIn().css('display', 'block');
          } else {
            $('.event-item').fadeIn().css('display', 'block');
          }
        } else if (currentSelectedTab === 'methods' || currentSelectedTab.indexOf('method_') === 0) {
          if (displayPrivateMode) {
            $('.private-method-item').fadeIn().css('display', 'block');
          } else {
            $('.method-item').fadeIn().css('display', 'block');
          }
        } else if (currentSelectedTab === 'properties' || currentSelectedTab.indexOf('property_') === 0) {
          if (displayPrivateMode) {
            $('.private-property-item').fadeIn().css('display', 'block');
          } else {
            $('.property-item').fadeIn().css('display', 'block');
          }
        } else if (currentSelectedTab === 'attrs' || currentSelectedTab.indexOf('attr_') === 0) {
          if (displayPrivateMode) {
            $('.private-attr-item').fadeIn().css('display', 'block');
          } else {
            $('.attr-item').fadeIn().css('display', 'block');
          }
        } else {
          $('.code-item').hide();
          $('.code-menu-item').hide();
          $('.code-item.private').hide();
          $('.code-menu-item.private').hide();
        }
      };

      // on click change active selected
      $(window).on('hashchange', function(e){
        // switch tabs
        $('.doc-selected.active').removeClass('active');
        var mainMenus = ['#events', '#properties', '#methods', '#attrs'];
        var menuItems = {
          '#method': '#methods',
          '#event': '#events',
          '#attr': '#attrs',
          '#property': '#properties'
        };
        var typeOfMenuItem = mainMenus.indexOf(window.location.hash);
        // check if parent menu item selected or child menu item
        if (typeOfMenuItem === -1) {
          typeOfMenuItem = mainMenus.indexOf(menuItems[window.location.hash.split('_')[0]]);
        }
        var item = $('.doc-selected a[href="' + mainMenus[typeOfMenuItem] + '"]');
        $(item).parent('.doc-selected').addClass('active');
        console.info(item);
        $('.list-group-o-wrapper .title').html($(item).html());
        $('#current-doc-selected-title').html($(item).html());
        $('.doc-private-label').html($(item).html());
        setSelectedTab($(item).attr('href').split('#')[1]);
      });

      $(window).bind('scroll', function() {
        var scrollTop = $(this).scrollTop();
        if(($('#current-doc-selected-title').offset().top) > scrollTop) {
          // remove the scrollbar top
          $('.list-group-o-wrapper').css('position', '');
          $('.list-group-o-wrapper').css('top', '');
          $('.list-group-o-wrapper').find('.list-group-wrapper').css('min-height', '');
          $('.list-group-o-wrapper').find('.list-group-wrapper').css('height', '');
          $('.list-group-o-wrapper .title').hide().css('display', 'none');
        } else {
          // set scrollbar to top
          $('.list-group-o-wrapper').css('position', 'fixed');
          $('.list-group-o-wrapper').css('top', '65px');
          $('.list-group-o-wrapper').find('.list-group-wrapper').css('min-height', ($(window).height() - 125) + 'px');
          $('.list-group-o-wrapper').find('.list-group-wrapper').css('height', ($(window).height() - 125) + 'px');
          $('.list-group-o-wrapper .title').show().css('display', 'block');
          // set the selected item
          $('.doc-content .code-item').each(function () {
            if ($(this).is(':visible')) {
              var topDistance = $(this).offset().top;
              if((topDistance + $(this).height() - 55) > (scrollTop)) {
                $('.code-menu-item').removeClass('active');
                $('a[href="#' + $(this).attr('id') + '"]').addClass('active');
                return false;
              }
            }
          });
        }
      });
    </script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" />JS<small>Version: 0.5.3</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
    </ul>
  </li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
  <li><a href="https://temasys.github.io">Getting Started</a></li>
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
              <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>

 options
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content">
                      <h1 class="file-heading">File: source/data-transfer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * The list of datachannel message types.
 * - These are the list of available datachannel message types expected to
 *   be received.
 * - These message types are fixed.
 * - The available message types are:
 * @attribute _DC_PROTOCOL_TYPE
 * @type JSON
 * @readOnly
 * @param {String} WRQ
 * - Send: User request to transfer a data.
 * - Received: A peer has requested to transfer a data.
 * @param {String} ACK
 * - Send: User response to data transfer request.
 * - Received: Response from peer towards data transfer.
 *   - -1: Peer has rejected data transfer request.
 *   - 0: Peer has accepted data transfer request.
 *   - &gt;0: Data transfer is going on.
 * @param {String} CANCEL
 * - Send: User canceled data transfer.
 * - Received: A peer has canceled data transfer.
 * @param {String} ERROR
 * - Send: Timeout waiting for peer response has exceeded limit.
 * - Received: Response from peer that timeout has reached its limit.
 *   Data transfer has failed.
 * @param {String} MESSAGE
 * - Send: User sends a P2P message.
 * - Received: A peer has sent a P2P message.
 * @readOnly
 * @private
 * @since 0.5.2
 */
Skylink.prototype._DC_PROTOCOL_TYPE = {
  WRQ: &#x27;WRQ&#x27;,
  ACK: &#x27;ACK&#x27;,
  ERROR: &#x27;ERROR&#x27;,
  CANCEL: &#x27;CANCEL&#x27;,
  MESSAGE: &#x27;MESSAGE&#x27;
};

/**
 * The list of datachannel transfer types.
 * - This is used to identify if the stream is an upload stream or
 *   a download stream.
 * - The available types are:
 * @attribute DATA_TRANSFER_TYPE
 * @type JSON
 * @param {String} UPLOAD The datachannel transfer is an upload stream.
 * @param {String} DOWNLOAD The datachannel transfer is a download stream.
 * @readOnly
 * @since 0.1.0
 */
Skylink.prototype.DATA_TRANSFER_TYPE = {
  UPLOAD: &#x27;upload&#x27;,
  DOWNLOAD: &#x27;download&#x27;
};
/**
 * The list of datachannel transfer state.
 * - These are the states to inform the state of the data transfer.
 * - The list of states would occur are:
 * @attribute DATA_TRANSFER_STATE
 * @type JSON
 * @param {String} UPLOAD_REQUEST Peer has a data transfer request.
 * @param {String} UPLOAD_STARTED Data transfer of upload has just started.
 * @param {String} DOWNLOAD_STARTED Data transfer of download has
 *   just started.
 * @param {String} UPLOADING Data upload transfer is occurring.
 * @param {String} DOWNLOADING Data download transfer is occurring.
 * @param {String} UPLOAD_COMPLETED Data upload transfer has been completed.
 * @param {String} DOWNLOAD_COMPLETED Data download transfer has been
 *   completed.
 * @param {String} REJECTED Peer rejected user&#x27;s data transfer request.
 * @param {String} ERROR Data transfer had an error occurred
 *   when uploading or downloading file.
 * @readOnly
 * @since 0.4.0
 */
Skylink.prototype.DATA_TRANSFER_STATE = {
  UPLOAD_REQUEST: &#x27;request&#x27;,
  UPLOAD_STARTED: &#x27;uploadStarted&#x27;,
  DOWNLOAD_STARTED: &#x27;downloadStarted&#x27;,
  REJECTED: &#x27;rejected&#x27;,
  CANCEL: &#x27;cancel&#x27;,
  ERROR: &#x27;error&#x27;,
  UPLOADING: &#x27;uploading&#x27;,
  DOWNLOADING: &#x27;downloading&#x27;,
  UPLOAD_COMPLETED: &#x27;uploadCompleted&#x27;,
  DOWNLOAD_COMPLETED: &#x27;downloadCompleted&#x27;
};

/**
 * Internal array of data upload transfers.
 * @attribute _uploadDataTransfers
 * @type Array
 * @private
 * @required
 * @since 0.4.1
 */
Skylink.prototype._uploadDataTransfers = [];

/**
 * Internal array of data upload sessions.
 * @attribute _uploadDataSessions
 * @type Array
 * @private
 * @required
 * @since 0.4.1
 */
Skylink.prototype._uploadDataSessions = [];

/**
 * Internal array of data download transfers.
 * @attribute _downloadDataTransfers
 * @type Array
 * @private
 * @required
 * @since 0.4.1
 */
Skylink.prototype._downloadDataTransfers = [];

/**
 * Internal array of data download sessions.
 * @attribute _downloadDataSessions
 * @type Array
 * @private
 * @required
 * @since 0.4.1
 */
Skylink.prototype._downloadDataSessions = [];

/**
 * Internal array of data transfers timeout.
 * @attribute _dataTransfersTimeout
 * @type Array
 * @private
 * @required
 * @since 0.4.1
 */
Skylink.prototype._dataTransfersTimeout = [];

/**
 * Sets the datachannel timeout.
 * - If timeout is met, it will send the &#x27;ERROR&#x27; message
 * @method _setDataChannelTimeout
 * @param {String} peerId PeerId of the datachannel to set timeout.
 * @param {Integer} timeout The timeout to set in seconds.
 * @param {Boolean} isSender Is peer the sender or the receiver?
 * @private
 * @since 0.5.0
 */
Skylink.prototype._setDataChannelTimeout = function(peerId, timeout, isSender) {
  var self = this;
  if (!self._dataTransfersTimeout[peerId]) {
    self._dataTransfersTimeout[peerId] = [];
  }
  var type = (isSender) ? self.DATA_TRANSFER_TYPE.UPLOAD :
    self.DATA_TRANSFER_TYPE.DOWNLOAD;
  self._dataTransfersTimeout[peerId][type] = setTimeout(function() {
    var name;
    if (self._dataTransfersTimeout[peerId][type]) {
      if (isSender) {
        name = self._uploadDataSessions[peerId].name;
        delete self._uploadDataTransfers[peerId];
        delete self._uploadDataSessions[peerId];
      } else {
        name = self._downloadDataSessions[peerId].name;
        delete self._downloadDataTransfers[peerId];
        delete self._downloadDataSessions[peerId];
      }
      self._sendDataChannelMessage(peerId, {
        type: self._DC_PROTOCOL_TYPE.ERROR,
        sender: self._user.sid,
        name: name,
        content: &#x27;Connection Timeout. Longer than &#x27; + timeout +
          &#x27; seconds. Connection is abolished.&#x27;,
        isUploadError: isSender
      });
      // TODO: Find a way to add channel name so it&#x27;s more specific
      log.error([peerId, &#x27;RTCDataChannel&#x27;, null, &#x27;Failed transfering data:&#x27;],
        &#x27;Transfer &#x27; + ((isSender) ? &#x27;for&#x27;: &#x27;from&#x27;) + &#x27; &#x27; + peerId +
        &#x27; failed. Connection timeout&#x27;);
      self._clearDataChannelTimeout(peerId, isSender);
    }
  }, 1000 * timeout);
};

/**
 * Clears the datachannel timeout.
 * @method _clearDataChannelTimeout
 * @param {String} peerId PeerId of the datachannel to clear timeout.
 * @param {Boolean} isSender Is peer the sender or the receiver?
 * @param {Skylink} self Skylink object.
 * @private
 * @since 0.5.0
 */
Skylink.prototype._clearDataChannelTimeout = function(peerId, isSender) {
  if (this._dataTransfersTimeout[peerId]) {
    var type = (isSender) ? this.DATA_TRANSFER_TYPE.UPLOAD :
      this.DATA_TRANSFER_TYPE.DOWNLOAD;
    clearTimeout(this._dataTransfersTimeout[peerId][type]);
    delete this._dataTransfersTimeout[peerId][type];
  }
};

/**
 * Sends blob data to individual peer.
 * - This sends the {{#crossLink &quot;Skylink/WRQ:event&quot;}}WRQ{{/crossLink}}
 *   and to initiate the TFTP protocol.
 * @method _sendBlobDataToPeer
 * @param {Blob} data The blob data to be sent over.
 * @param {JSON} dataInfo The data information.
 * @param {String} dataInfo.transferId TransferId of the data.
 * @param {String} dataInfo.name Data name.
 * @param {Integer} dataInfo.timeout Data timeout to wait for packets.
 *   [Default is 60].
 * @param {Integer} dataInfo.size Data size
 * @param {String} targetPeerId PeerId targeted to receive data.
 *   Leave blank to send to all peers.
 * @private
 * @since 0.1.0
 */
Skylink.prototype._sendBlobDataToPeer = function(data, dataInfo, targetPeerId) {
  var binarySize = parseInt((dataInfo.size * (4 / 3)).toFixed(), 10);
  var chunkSize = parseInt((this._CHUNK_FILE_SIZE * (4 / 3)).toFixed(), 10);
  if (window.webrtcDetectedBrowser === &#x27;firefox&#x27; &amp;&amp;
    window.webrtcDetectedVersion &lt; 30) {
    chunkSize = this._MOZ_CHUNK_FILE_SIZE;
  }
  log.log([targetPeerId, null, null, &#x27;Chunk size of data:&#x27;], chunkSize);
  this._uploadDataTransfers[targetPeerId] = this._chunkBlobData(data, dataInfo.size);
  this._uploadDataSessions[targetPeerId] = {
    name: dataInfo.name,
    size: binarySize,
    transferId: dataInfo.transferId,
    timeout: dataInfo.timeout
  };
  this._sendDataChannelMessage(targetPeerId, {
    type: this._DC_PROTOCOL_TYPE.WRQ,
    sender: this._user.sid,
    agent: window.webrtcDetectedBrowser,
    name: dataInfo.name,
    size: binarySize,
    chunkSize: chunkSize,
    timeout: dataInfo.timeout
  });
  this._setDataChannelTimeout(targetPeerId, dataInfo.timeout, true);
};

/**
 * Handles all datachannel protocol events.
 * @method _dataChannelProtocolHandler
 * @param {String|Object} data The data received from datachannel.
 * @private
 * @since 0.5.2
 */
Skylink.prototype._dataChannelProtocolHandler = function(dataString, peerId, channelName) {
  // PROTOCOL ESTABLISHMENT
  if (typeof dataString === &#x27;string&#x27;) {
    var data = {};
    try {
      data = JSON.parse(dataString);
    } catch (error) {
      log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Received from peer -&gt;&#x27;], &#x27;DATA&#x27;);
      this._DATAProtocolHandler(peerId, dataString,
        this.DATA_TRANSFER_DATA_TYPE.BINARY_STRING, channelName);
      return;
    }
    log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Received from peer -&gt;&#x27;], data.type);
    switch (data.type) {
    case this._DC_PROTOCOL_TYPE.WRQ:
      this._WRQProtocolHandler(peerId, data, channelName);
      break;
    case this._DC_PROTOCOL_TYPE.ACK:
      this._ACKProtocolHandler(peerId, data, channelName);
      break;
    case this._DC_PROTOCOL_TYPE.ERROR:
      this._ERRORProtocolHandler(peerId, data, channelName);
      break;
    case this._DC_PROTOCOL_TYPE.CANCEL:
      this._CANCELProtocolHandler(peerId, data, channelName);
      break;
    case this._DC_PROTOCOL_TYPE.MESSAGE: // Not considered a protocol actually?
      this._MESSAGEProtocolHandler(peerId, data, channelName);
      break;
    default:
      log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Unsupported message -&gt;&#x27;], data.type);
    }
  }
};

/**
 * The user receives a blob request.
 * From here, it&#x27;s up to the user to accept or reject it
 * @method _WRQProtocolHandler
 * @param {String} peerId PeerId of the peer that is sending the request.
 * @param {JSON} data The data object received from datachannel.
 * @param {String} data.agent The peer&#x27;s browser agent.
 * @param {Integer} data.version The peer&#x27;s browser version.
 * @param {String} data.name The data name.
 * @param {Integer} data.size The data size.
 * @param {Integer} data.chunkSize The data chunk size expected to receive.
 * @param {Integer} data.timeout The timeout to wait for packet response.
 * @param {Boolean} data.isPrivate Is the data sent private.
 * @param {String} data.sender The sender&#x27;s peerId.
 * @param {String} data.type The type of datachannel message.
 * @trigger dataTransferState
 * @private
 * @since 0.5.2
 */
Skylink.prototype._WRQProtocolHandler = function(peerId, data, channelName) {
  var transferId = this._user.sid + this.DATA_TRANSFER_TYPE.DOWNLOAD +
    (((new Date()).toISOString().replace(/-/g, &#x27;&#x27;).replace(/:/g, &#x27;&#x27;))).replace(&#x27;.&#x27;, &#x27;&#x27;);
  log.log([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;WRQ&#x27;],
    &#x27;Received file request from peer:&#x27;], data);
  var name = data.name;
  var binarySize = data.size;
  var expectedSize = data.chunkSize;
  var timeout = data.timeout;
  this._downloadDataSessions[peerId] = {
    transferId: transferId,
    name: name,
    size: binarySize,
    ackN: 0,
    receivedSize: 0,
    chunkSize: expectedSize,
    timeout: timeout
  };
  this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.UPLOAD_REQUEST,
    transferId, peerId, {
    name: name,
    size: binarySize,
    senderPeerId: peerId
  });
};

/**
 * The user receives an acknowledge of the blob request.
 * @method _ACKProtocolHandler
 * @param {String} peerId PeerId of the peer that is sending the acknowledgement.
 * @param {JSON} data The data object received from datachannel.
 * @param {String} data.ackN The acknowledge request number.
 * - 0: Request accepted. First packet sent.
 * - 0 and above: Transfer is going on.
 * - -1: Request rejected.
 * @param {String} data.sender The sender&#x27;s peerId.
 * @param {String} data.type The type of datachannel message.
 * @trigger dataTransferState
 * @private
 * @since 0.5.2
 */
Skylink.prototype._ACKProtocolHandler = function(peerId, data, channelName) {
  var self = this;
  var ackN = data.ackN;
  var chunksLength = self._uploadDataTransfers[peerId].length;
  var uploadedDetails = self._uploadDataSessions[peerId];
  var transferId = uploadedDetails.transferId;
  var timeout = uploadedDetails.timeout;

  self._clearDataChannelTimeout(peerId, true);
  log.log([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;ACK&#x27;], &#x27;ACK stage -&gt;&#x27;],
    ackN + &#x27; / &#x27; + chunksLength);

  if (ackN &gt; -1) {
    // Still uploading
    if (ackN &lt; chunksLength) {
      var fileReader = new FileReader();
      fileReader.onload = function() {
        // Load Blob as dataurl base64 string
        var base64BinaryString = fileReader.result.split(&#x27;,&#x27;)[1];
        self._sendDataChannelMessage(peerId, base64BinaryString);
        self._setDataChannelTimeout(peerId, timeout, true);
        self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.UPLOADING,
          transferId, peerId, {
          percentage: (((ackN + 1) / chunksLength) * 100).toFixed()
        });
      };
      fileReader.readAsDataURL(self._uploadDataTransfers[peerId][ackN]);
    } else if (ackN === chunksLength) {
      self._trigger(&#x27;dataTransferState&#x27;,
        self.DATA_TRANSFER_STATE.UPLOAD_COMPLETED, transferId, peerId, {
        name: uploadedDetails.name
      });
      delete self._uploadDataTransfers[peerId];
      delete self._uploadDataSessions[peerId];
    }
  } else {
    self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.REJECTED,
      transferId, peerId);
    delete self._uploadDataTransfers[peerId];
    delete self._uploadDataSessions[peerId];
  }
};

/**
 * The user receives a datachannel broadcast message.
 * @method _MESSAGEProtocolHandler
 * @param {String} peerId PeerId of the peer that is sending a broadcast message.
 * @param {JSON} data The data object received from datachannel.
 * @param {String} data.target The target peerId to receive the data.
 * @param {String|JSON} data.data The data to be received.
 * @param {String} data.sender The sender&#x27;s peerId.
 * @param {String} data.type The type of datachannel message.
 * @trigger incomingMessage
 * @private
 * @since 0.5.2
 */
Skylink.prototype._MESSAGEProtocolHandler = function(peerId, data, channelName) {
  var targetMid = data.sender;
  log.log([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;MESSAGE&#x27;],
    &#x27;Received P2P message from peer:&#x27;], data);
  this._trigger(&#x27;incomingMessage&#x27;, {
    content: data.data,
    isPrivate: data.isPrivate,
    isDataChannel: true,
    targetPeerId: this._user.sid,
    senderPeerId: targetMid
  }, targetMid, this._peerInformations[targetMid], false);
};

/**
 * The user receives a timeout error.
 * @method _ERRORProtocolHandler
 * @param {String} peerId PeerId of the peer that is sending the error.
 * @param {Array} data The data object received from datachannel.
 * @param {String} data.name The data name.
 * @param {String} data.content The error message.
 * @param {Boolean} data.isUploadError Is the error occurring at upload state.
 * @param {String} data.sender The sender&#x27;s peerId.
 * @param {String} data.type The type of datachannel message.
 * @trigger dataTransferState
 * @private
 * @since 0.5.2
 */
Skylink.prototype._ERRORProtocolHandler = function(peerId, data, channelName) {
  var isUploader = data.isUploadError;
  var transferId = (isUploader) ? this._uploadDataSessions[peerId].transferId :
    this._downloadDataSessions[peerId].transferId;
  log.error([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;ERROR&#x27;],
    &#x27;Received an error from peer:&#x27;], data);
  this._clearDataChannelTimeout(peerId, isUploader);
  this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.ERROR,
    transferId, peerId, null, {
    name: data.name,
    message: data.content,
    transferType: ((isUploader) ? this.DATA_TRANSFER_TYPE.UPLOAD :
      this.DATA_TRANSFER_TYPE.DOWNLOAD)
  });
};

/**
 * The user receives a timeout error.
 * @method _CANCELProtocolHandler
 * @param {String} peerId PeerId of the peer that is sending the error.
 * @param {Array} data The data object received from datachannel.
 * @param {String} data.name The data name.
 * @param {String} data.content The error message.
 * @param {String} data.sender The sender&#x27;s peerId.
 * @param {String} data.type The type of datachannel message.
 * @trigger dataTransferState
 * @private
 * @since 0.5.2
 */
Skylink.prototype._CANCELProtocolHandler = function(peerId, data, channelName) {
  var isUploader = data.isUploadError;
  var transferId = (isUploader) ? this._uploadDataSessions[peerId].transferId :
    this._downloadDataSessions[peerId].transferId;
  log.log([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;CANCEL&#x27;],
    &#x27;Received file transfer cancel request:&#x27;], data);
  this._clearDataChannelTimeout(peerId, isUploader);
  this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.CANCEL,
    transferId, peerId, null, {
    name: data.name,
    content: data.content,
    senderPeerId: data.sender,
    transferType: ((isUploader) ? this.DATA_TRANSFER_TYPE.UPLOAD :
      this.DATA_TRANSFER_TYPE.DOWNLOAD)
  });
};

/**
 * This is when the data is sent from the sender to the receiving user.
 * @method _DATAProtocolHandler
 * @param {String} peerId PeerId of the peer that is sending the data.
 * @param {ArrayBuffer|Blob|String} dataString The data received.
 * @param {String} dataType The data type received from datachannel.
 *   [Rel: Skylink.DATA_TRANSFER_DATA_TYPE]
 * @trigger dataTransferState
 * @private
 * @since 0.5.2
 */
Skylink.prototype._DATAProtocolHandler = function(peerId, dataString, dataType, channelName) {
  var chunk, error = &#x27;&#x27;;
  var transferStatus = this._downloadDataSessions[peerId];
  var transferId = transferStatus.transferId;
  log.log([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;DATA&#x27;],
    &#x27;Received data chunk from peer. Data type:&#x27;], dataType);

  this._clearDataChannelTimeout(peerId, false);

  if (dataType === this.DATA_TRANSFER_DATA_TYPE.BINARY_STRING) {
    chunk = this._base64ToBlob(dataString);
  } else if (dataType === this.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER) {
    chunk = new Blob(dataString);
  } else if (dataType === this.DATA_TRANSFER_DATA_TYPE.BLOB) {
    chunk = dataString;
  } else {
    error = &#x27;Unhandled data exception: &#x27; + dataType;
    log.error([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;DATA&#x27;],
      &#x27;Failed downloading data packets:&#x27;], error);
    this._trigger(&#x27;dataTransferState&#x27;,
      this.DATA_TRANSFER_STATE.ERROR, transferId, peerId, null, {
      message: error,
      transferType: this.DATA_TRANSFER_TYPE.DOWNLOAD
    });
    return;
  }
  var receivedSize = (chunk.size * (4 / 3));
  log.log([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;DATA&#x27;],
    &#x27;Received data chunk size:&#x27;], receivedSize);
  log.log([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;DATA&#x27;],
    &#x27;Expected data chunk size:&#x27;], transferStatus.chunkSize);

  if (transferStatus.chunkSize &gt;= receivedSize) {
    this._downloadDataTransfers[peerId].push(chunk);
    transferStatus.ackN += 1;
    transferStatus.receivedSize += receivedSize;
    var totalReceivedSize = transferStatus.receivedSize;
    var percentage = ((totalReceivedSize / transferStatus.size) * 100).toFixed();

    this._sendDataChannelMessage(peerId, {
      type: this._DC_PROTOCOL_TYPE.ACK,
      sender: this._user.sid,
      ackN: transferStatus.ackN
    });
    if (transferStatus.chunkSize === receivedSize) {
      log.log([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;DATA&#x27;],
        &#x27;Transfer in progress&#x27;]);
      this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.DOWNLOADING,
        transferId, peerId, {
        percentage: percentage
      });
      this._setDataChannelTimeout(peerId, transferStatus.timeout, false);
      this._downloadDataTransfers[peerId].info = transferStatus;
    } else {
      log.log([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;DATA&#x27;],
        &#x27;Download complete&#x27;]);
      var blob = new Blob(this._downloadDataTransfers[peerId]);
      this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.DOWNLOAD_COMPLETED,
        transferId, peerId, {
        data: blob
      });
      delete this._downloadDataTransfers[peerId];
      delete this._downloadDataSessions[peerId];
    }
  } else {
    error = &#x27;Packet not match - [Received]&#x27; + receivedSize +
      &#x27; / [Expected]&#x27; + transferStatus.chunkSize;
    this._trigger(&#x27;dataTransferState&#x27;,
      this.DATA_TRANSFER_STATE.ERROR, transferId, peerId, null, {
      message: error,
      transferType: this.DATA_TRANSFER_TYPE.DOWNLOAD
    });
    log.error([peerId, &#x27;RTCDataChannel&#x27;, [channelName, &#x27;DATA&#x27;],
      &#x27;Failed downloading data packets:&#x27;], error);
  }
};

/**
 * Start a data transfer with peer(s).
 * - Note that peers have the option to download or reject receiving the blob data.
 * - This method is ideal for sending files.
 * - To send a private file to a peer, input the peerId after the
 *   data information.
 * @method sendBlobData
 * @param {Object} data The data to be sent over. Data has to be a blob.
 * @param {JSON} dataInfo The data information.
 * @param {String} dataInfo.transferId transferId of the data.
 * @param {String} dataInfo.name Data name.
 * @param {Integer} dataInfo.timeout The timeout to wait for packets.
 *   [Default is 60].
 * @param {Integer} dataInfo.size The data size
 * @param {String} targetPeerId PeerId targeted to receive data.
 *   Leave blank to send to all peers.
 * @example
 *   // Send file to all peers connected
 *   SkylinkDemo.sendBlobData(file, 67);
 *
 *   // Send file to individual peer
 *   SkylinkDemo.sendBlobData(blob, 87, targetPeerId);
 * @trigger dataTransferState
 * @since 0.5.2
 */
Skylink.prototype.sendBlobData = function(data, dataInfo, targetPeerId) {
  if (!data &amp;&amp; !dataInfo) {
    return false;
  }
  // check if datachannel is enabled first or not
  if (!this._enableDataChannel) {
    log.warn(&#x27;Unable to send any blob data. Datachannel is disabled&#x27;);
    return;
  }
  var noOfPeersSent = 0;
  dataInfo.timeout = dataInfo.timeout || 60;
  dataInfo.transferId = this._user.sid + this.DATA_TRANSFER_TYPE.UPLOAD +
    (((new Date()).toISOString().replace(/-/g, &#x27;&#x27;).replace(/:/g, &#x27;&#x27;))).replace(&#x27;.&#x27;, &#x27;&#x27;);

  if (targetPeerId) {
    if (this._dataChannels.hasOwnProperty(targetPeerId)) {
      log.log([targetPeerId, null, null, &#x27;Sending blob data -&gt;&#x27;], dataInfo);
      this._sendBlobDataToPeer(data, dataInfo, targetPeerId);
      noOfPeersSent = 1;
    } else {
      log.error([targetPeerId, null, null, &#x27;Datachannel does not exist&#x27;]);
    }
  } else {
    targetpeerId = this._user.sid;
    for (var peerId in this._dataChannels) {
      if (this._dataChannels.hasOwnProperty(peerId)) {
        // Binary String filesize [Formula n = 4/3]
        this._sendBlobDataToPeer(data, dataInfo, peerId);
        noOfPeersSent++;
      } else {
        log.error([peerId, null, null, &#x27;Datachannel does not exist&#x27;]);
      }
    }
  }
  if (noOfPeersSent &gt; 0) {
    this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.UPLOAD_STARTED,
      dataInfo.transferId, targetPeerId, {
      transferId: dataInfo.transferId,
      senderPeerId: this._user.sid,
      name: dataInfo.name,
      size: dataInfo.size,
      timeout: dataInfo.timeout || 60,
      data: data
    });
  } else {
    var error = &#x27;No available datachannels to send data.&#x27;;
    this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.ERROR,
      dataInfo.transferId, targetPeerId, null, {
      message: error,
      transferType: this.DATA_TRANSFER_TYPE.UPLOAD
    });
    log.error(&#x27;Failed sending data: &#x27;, error);
    this._uploadDataTransfers = [];
    this._uploadDataSessions = [];
  }
};

/**
 * User&#x27;s response to accept or reject data transfer request.
 * @method respondBlobRequest
 * @param {String} peerId PeerId of the peer that is expected to receive
 *   the request response.
 * @param {Boolean} accept The response of the user to accept the data
 *   transfer or not.
 * @trigger dataTransferState
 * @since 0.5.0
 */
Skylink.prototype.respondBlobRequest = function (peerId, accept) {
  if (accept) {
    log.info([peerId, null, null, &#x27;User accepted peer\&#x27;s request&#x27;]);
    this._downloadDataTransfers[peerId] = [];
    var data = this._downloadDataSessions[peerId];
    this._sendDataChannelMessage(peerId, {
      type: this._DC_PROTOCOL_TYPE.ACK,
      sender: this._user.sid,
      ackN: 0,
      agent: window.webrtcDetectedBrowser
    });
    this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.DOWNLOAD_STARTED,
      data.transferId, peerId, {
      name: data.name,
      size: data.size,
      senderPeerId: peerId
    });
  } else {
    log.info([peerId, null, null, &#x27;User rejected peer\&#x27;s request&#x27;]);
    this._sendDataChannelMessage(peerId, {
      type: this._DC_PROTOCOL_TYPE.ACK,
      sender: this._user.sid,
      ackN: -1
    });
    delete this._downloadDataSessions[peerId];
  }
};

/**
 * Reject file transfer for cancel.
 * @method cancelBlobTransfer
 * @param {String} peerId PeerId of the peer that is expected to receive
 *   the request response.
 * @param {String} transferType Transfer type [Rel: DATA_TRANSFER_TYPE]
 * @trigger dataTransferState
 * @since 0.5.0
 */
Skylink.prototype.cancelBlobTransfer = function (peerId, transferType) {
  if (accept) {
    this._downloadDataTransfers[peerId] = [];
    var data = this._downloadDataSessions[peerId];
    this._sendDataChannelMessage(peerId, {
      type: this._DC_PROTOCOL_TYPE.ACK,
      sender: this._user.sid,
      ackN: 0,
      agent: window.webrtcDetectedBrowser
    });
    this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.CANCEL,
      data.transferId, peerId, {
      name: data.name,
      size: data.size,
      senderPeerId: peerId
    });
  } else {
    this._sendDataChannelMessage(peerId, {
      type: this._DC_PROTOCOL_TYPE.ACK,
      sender: this._user.sid,
      ackN: -1
    });
    delete this._downloadDataSessions[peerId];
  }
};

/**
 * Broadcasts to all P2P datachannel messages and sends to a
 * peer only when targetPeerId is provided.
 * - This is ideal for sending strings or json objects lesser than 16KB
 *   [as noted in here](http://www.webrtc.org/chrome).
 * - For huge data, please check out function
 *   {{#crossLink &quot;Skylink/sendBlobData:method&quot;}}sendBlobData(){{/crossLink}}.
 * - &lt;b&gt;&lt;i&gt;WARNING&lt;/i&gt;&lt;/b&gt;: Map arrays data would be lost when stringified
 *   in JSON, so refrain from using map arrays.
 * @method sendP2PMessage
 * @param {String|JSON} message The message data to send.
 * @param {String} targetPeerId Optional. Provide if you want to send to
 *   only one peer
 * @example
 *   // Example 1: Send to all peers
 *   SkylinkDemo.sendP2PMessage(&#x27;Hi there! This is from a DataChannel!&#x27;);
 *
 *   // Example 2: Send to specific peer
 *   SkylinkDemo.sendP2PMessage(&#x27;Hi there peer! This is from a DataChannel!&#x27;, targetPeerId);
 * @trigger incomingMessage
 * @since 0.5.2
 */
Skylink.prototype.sendP2PMessage = function(message, targetPeerId) {
  // check if datachannel is enabled first or not
  if (!this._enableDataChannel) {
    log.warn(&#x27;Unable to send any P2P message. Datachannel is disabled&#x27;);
    return;
  }
  // Handle typeof object sent over
  for (var peerId in this._dataChannels) {
    if (this._dataChannels.hasOwnProperty(peerId)) {
      if ((targetPeerId &amp;&amp; targetPeerId === peerId) || !targetPeerId) {
        log.log([peerId, null, null, &#x27;Sending P2P message to peer&#x27;]);
        this._sendDataChannelMessage(peerId, {
          type: this._DC_PROTOCOL_TYPE.MESSAGE,
          isPrivate: !!targetPeerId,
          sender: this._user.sid,
          target: targetPeerId,
          data: message
        });
      }
    }
  }
  this._trigger(&#x27;incomingMessage&#x27;, {
    content: message,
    isPrivate: (targetPeerId) ? true : false,
    targetPeerId: targetPeerId || null, // is not null if there&#x27;s user
    isDataChannel: true,
    senderPeerId: this._user.sid
  }, this._user.sid, this._user.info, true);
};
    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
