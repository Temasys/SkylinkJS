<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Temasys Documentation - SkylinkJS 0.6.31 - Web SDK</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- font and icon -->
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <!-- styling -->
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap-theme.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- scripts -->
    <script src="../assets/vendor/js/jquery.min.js"></script>
    <script src="../assets/vendor/js/bootstrap.min.js"></script>
    <script src="../assets/js/script.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" /><small>Version: 0.6.31</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Getting Started Examples <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="https://temasys.io/getting-started-with-webrtc-and-skylinkjs/">Setting up a Video Call</a></li>
      <li><a href="https://temasys.io/screensharing-with-skylinkjs/">Setting up Screensharing</a></li>
      <li><a href="https://temasys.io/building-a-simple-peer-to-peer-webrtc-chat/">Setting up a Chatroom</a></li>
    </ul>
  </li>
  
    <li><a href="../classes/Skylink.html">Documentation</a></li>
  
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
    </ul>
  </li>-->
  <li><a class="btn btn-info btn-navbar" href="https://console.temasys.io/">Developer Console</a></li>
  <li><a class="btn btn-info btn-navbar" href="http://support.temasys.io/">Support</a></li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
          
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content content-main">
                      <h1 class="file-heading">File: source/data-transfer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Function that starts an uploading data transfer from User to Peers.
 * @method sendBlobData
 * @param {Blob} data The Blob object.
 * @param {Number} [timeout=60] The timeout to wait for response from Peer.
 * @param {String|Array} [targetPeerId] The target Peer ID to start data transfer with.
 * - When provided as an Array, it will start uploading data transfers with all connections
 *   with all the Peer IDs provided.
 * - When not provided, it will start uploading data transfers with all the currently connected Peers in the Room.
 * @param {Boolean} [sendChunksAsBinary=false] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this is currently not supported for MCU enabled Peer connections or Peer connections connecting from
 *   Android, iOS and Linux SDKs. This would fallback to &lt;code&gt;transferInfo.chunkType&lt;/code&gt; to
 *   &lt;code&gt;BINARY_STRING&lt;/code&gt; when MCU is connected. &lt;/blockquote&gt; The flag if data transfer
 *   binary data chunks should not be encoded as Base64 string during data transfers.
 * @param {Function} [callback] The callback function fired when request has completed.
 *   &lt;small&gt;Function parameters signature is &lt;code&gt;function (error, success)&lt;/code&gt;&lt;/small&gt;
 *   &lt;small&gt;Function request completion is determined by the &lt;a href=&quot;#event_dataTransferState&quot;&gt;
 *   &lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggering &lt;code&gt;state&lt;/code&gt; parameter payload
 *   as &lt;code&gt;UPLOAD_COMPLETED&lt;/code&gt; for all Peers targeted for request success.&lt;/small&gt;
 * @param {JSON} callback.error The error result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are no errors in request&lt;/small&gt;
 * @param {String} callback.error.transferId The data transfer ID.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when &lt;code&gt;sendBlobData()&lt;/code&gt; fails to start data transfer.&lt;/small&gt;
 * @param {Array} callback.error.listOfPeers The list Peer IDs targeted for the data transfer.
 * @param {JSON} callback.error.transferErrors The list of data transfer errors.
 * @param {Error|String} callback.error.transferErrors.#peerId The data transfer error associated
 *   with the Peer ID defined in &lt;code&gt;#peerId&lt;/code&gt; property.
 *   &lt;small&gt;If &lt;code&gt;#peerId&lt;/code&gt; value is &lt;code&gt;&quot;self&quot;&lt;/code&gt;, it means that it is the error when there
 *   are no Peer connections to start data transfer with.&lt;/small&gt;
 * @param {JSON} callback.error.transferInfo The data transfer information.
 *   &lt;small&gt;Object signature matches the &lt;code&gt;transferInfo&lt;/code&gt; parameter payload received in the
 *   &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; except without the
 *   &lt;code&gt;percentage&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt; property.&lt;/small&gt;
 * @param {JSON} callback.success The success result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are errors in request&lt;/small&gt;
 * @param {String} callback.success.transferId The data transfer ID.
 * @param {Array} callback.success.listOfPeers The list Peer IDs targeted for the data transfer.
 * @param {JSON} callback.success.transferInfo The data transfer information.
 *   &lt;small&gt;Object signature matches the &lt;code&gt;transferInfo&lt;/code&gt; parameter payload received in the
 *   &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; except without the
 *   &lt;code&gt;percentage&lt;/code&gt; property and &lt;code&gt;data&lt;/code&gt;.&lt;/small&gt;
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *   &lt;li&gt;Checks if User is in Room. &lt;ol&gt;
 *   &lt;li&gt;If User is not in Room: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;
 *   &lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt;
 *   as &lt;code&gt;START_ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Checks if there is any available Datachannel connections. &lt;ol&gt;
 *   &lt;li&gt;If User is not in Room: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;
 *   &lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt;
 *   as &lt;code&gt;START_ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Checks if provided &lt;code&gt;data&lt;/code&gt; parameter is valid. &lt;ol&gt;
 *   &lt;li&gt;If it is invalid: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;
 *   &lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt;
 *   as &lt;code&gt;START_ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Checks if Peer connection and Datachannel connection are in correct states. &lt;ol&gt;
 *   &lt;li&gt;If Peer connection or session does not exists: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;
 *   &lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt;
 *   as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If Peer connection is not stable: &lt;small&gt;The stable state can be checked with &lt;a href=&quot;#event_peerConnectionState&quot;&gt;
 *   &lt;code&gt;peerConnectionState&lt;/code&gt; event&lt;/a&gt; triggering parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;STABLE&lt;/code&gt;
 *   for Peer.&lt;/small&gt; &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers
 *   parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If Peer connection messaging Datachannel has not been opened: &lt;small&gt;This can be checked with
 *   &lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggering parameter
 *   payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as
 *   &lt;code&gt;MESSAGING&lt;/code&gt; for Peer.&lt;/small&gt; &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;
 *   &lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If MCU is enabled for the App Key provided in &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt;method&lt;/a&gt; and connected: &lt;ol&gt;
 *   &lt;li&gt;If MCU Peer connection is not stable: &lt;small&gt;The stable state can be checked with &lt;a href=&quot;#event_peerConnectionState&quot;&gt;
 *   &lt;code&gt;peerConnectionState&lt;/code&gt; event&lt;/a&gt; triggering parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;STABLE&lt;/code&gt;
 *   and &lt;code&gt;peerId&lt;/code&gt; value as &lt;code&gt;&quot;MCU&quot;&lt;/code&gt; for MCU Peer.&lt;/small&gt;
 *   &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers
 *   parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If MCU Peer connection messaging Datachannel has not been opened: &lt;small&gt;This can be checked with
 *   &lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggering parameter
 *   payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt;, &lt;code&gt;peerId&lt;/code&gt; value as &lt;code&gt;&quot;MCU&quot;&lt;/code&gt;
 *   and &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;MESSAGING&lt;/code&gt; for MCU Peer.&lt;/small&gt;
 *   &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers
 *   parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Checks if should open a new data Datachannel.&lt;ol&gt;
 *   &lt;li&gt;If Peer supports simultaneous data transfer, open new data Datachannel: &lt;small&gt;If MCU is connected,
 *   this opens a new data Datachannel with MCU Peer with all the Peers IDs information that supports
 *   simultaneous data transfers targeted for the data transfer session instead of opening new data Datachannel
 *   with all Peers targeted for the data transfer session.&lt;/small&gt; &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggers parameter
 *   payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;CONNECTING&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;DATA&lt;/code&gt;.
 *   &lt;small&gt;Note that there is no timeout to wait for parameter payload &lt;code&gt;state&lt;/code&gt; to be
 *   &lt;code&gt;OPEN&lt;/code&gt;.&lt;/small&gt;&lt;/li&gt;
 *   &lt;li&gt;If Datachannel has been created and opened successfully: &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;DATA&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Else: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;CREATE_ERROR&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as
 *   &lt;code&gt;DATA&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers
 *   parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and
 *   return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;Else: &lt;small&gt;If MCU is connected,
 *   this uses the messaging Datachannel with MCU Peer with all the Peers IDs information that supports
 *   simultaneous data transfers targeted for the data transfer session instead of using the messaging Datachannels
 *   with all Peers targeted for the data transfer session.&lt;/small&gt; &lt;ol&gt;&lt;li&gt;If messaging Datachannel connection has a
 *   data transfer in-progress: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and
 *   return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;If there is any conflicting &lt;a href=&quot;#method_streamData&quot;&gt;&lt;code&gt;streamData()&lt;/code&gt;
 *   method&lt;/a&gt; data streaming session: &lt;small&gt;If &lt;code&gt;sendChunksAsBinary&lt;/code&gt; is provided as &lt;code&gt;true&lt;/code&gt;,
 *   it cannot start if existing data streaming session is expected binary data chunks, and if provided as
 *   &lt;code&gt;false&lt;/code&gt;, or method invoked is &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt;,
 *   or Peer is using string data chunks fallback due to its support despite provided as &lt;code&gt;true&lt;/code&gt;,
 *   it cannot start if existing data streaming session is expected string data chunks.&lt;/small&gt;&lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and
 *   return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Starts the data transfer to Peer. &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_incomingDataRequest&quot;&gt;&lt;code&gt;incomingDataRequest&lt;/code&gt; event&lt;/a&gt; triggers.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For User only&lt;/em&gt; &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;USER_UPLOAD_REQUEST&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For Peer only&lt;/em&gt; &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;UPLOAD_REQUEST&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;Peer invokes &lt;a href=&quot;#method_acceptDataTransfer&quot;&gt;&lt;code&gt;acceptDataTransfer()&lt;/code&gt; method&lt;/a&gt;. &lt;ol&gt;
 *   &lt;li&gt;If parameter &lt;code&gt;accept&lt;/code&gt; value is &lt;code&gt;true&lt;/code&gt;: &lt;ol&gt;
 *   &lt;li&gt;User starts upload data transfer to Peer. &lt;ol&gt;
 *   &lt;li&gt;&lt;em&gt;For User only&lt;/em&gt; &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;UPLOAD_STARTED&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For Peer only&lt;/em&gt; &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;DOWNLOAD_STARTED&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If Peer / User invokes &lt;a href=&quot;#method_cancelDataTransfer&quot;&gt;&lt;code&gt;cancelDataTransfer()&lt;/code&gt; method&lt;/a&gt;: &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;CANCEL&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If data transfer has timeout errors: &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Checks for Peer connection and Datachannel connection during data transfer: &lt;ol&gt;
 *   &lt;li&gt;If MCU is enabled for the App Key provided in &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt;
 *   method&lt;/a&gt; and connected: &lt;ol&gt;
 *   &lt;li&gt;If MCU Datachannel has closed abruptly during data transfer: &lt;ol&gt;
 *   &lt;small&gt;This can be checked with &lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt;
 *   triggering parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;CLOSED&lt;/code&gt;, &lt;code&gt;peerId&lt;/code&gt; value as
 *   &lt;code&gt;&quot;MCU&quot;&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;DATA&lt;/code&gt; for targeted Peers that supports simultaneous
 *   data transfer or &lt;code&gt;MESSAGING&lt;/code&gt; for targeted Peers that do not support it.&lt;/small&gt; &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If MCU Peer connection has changed from not being stable: &lt;ol&gt;
 *   &lt;small&gt;This can be checked with &lt;a href=&quot;#event_peerConnectionState&quot;&gt;&lt;code&gt;peerConnection&lt;/code&gt; event&lt;/a&gt;
 *   triggering parameter payload &lt;code&gt;state&lt;/code&gt; as not &lt;code&gt;STABLE&lt;/code&gt;, &lt;code&gt;peerId&lt;/code&gt; value as
 *   &lt;code&gt;&quot;MCU&quot;&lt;/code&gt;.&lt;/small&gt; &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If Peer connection has changed from not being stable: &lt;ol&gt;
 *   &lt;small&gt;This can be checked with &lt;a href=&quot;#event_peerConnectionState&quot;&gt;&lt;code&gt;peerConnection&lt;/code&gt; event&lt;/a&gt;
 *   triggering parameter payload &lt;code&gt;state&lt;/code&gt; as not &lt;code&gt;STABLE&lt;/code&gt;.&lt;/small&gt; &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Else: &lt;ol&gt;&lt;li&gt;If Datachannel has closed abruptly during data transfer:
 *   &lt;small&gt;This can be checked with &lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt;
 *   triggering parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;CLOSED&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt;
 *   as &lt;code&gt;DATA&lt;/code&gt; for Peer that supports simultaneous data transfer or &lt;code&gt;MESSAGING&lt;/code&gt;
 *   for Peer that do not support it.&lt;/small&gt; &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If data transfer is still progressing: &lt;ol&gt;
 *   &lt;li&gt;&lt;em&gt;For User only&lt;/em&gt; &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;UPLOADING&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For Peer only&lt;/em&gt; &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;DOWNLOADING&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If data transfer has completed &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_incomingData&quot;&gt;&lt;code&gt;incomingData&lt;/code&gt; event&lt;/a&gt; triggers.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For User only&lt;/em&gt; &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;UPLOAD_COMPLETED&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For Peer only&lt;/em&gt; &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;DOWNLOAD_COMPLETED&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If parameter &lt;code&gt;accept&lt;/code&gt; value is &lt;code&gt;false&lt;/code&gt;: &lt;ol&gt;
 *   &lt;li&gt;&lt;em&gt;For User only&lt;/em&gt; &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;REJECTED&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For Peer only&lt;/em&gt; &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;USER_REJECTED&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
 * @example
 * &amp;lt;body&amp;gt;
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(0)&quot;&amp;gt; 1s timeout (Default)
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(120)&quot;&amp;gt; 2s timeout
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(300)&quot;&amp;gt; 5s timeout
 *  &amp;lt;hr&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;uploadFile(this.files[0], this.getAttribute(&#x27;data&#x27;))&quot; data=&quot;peerId&quot;&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;uploadFileGroup(this.files[0], this.getAttribute(&#x27;data&#x27;).split(&#x27;,&#x27;)))&quot; data=&quot;peerIdA,peerIdB&quot;&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;uploadFileAll(this.files[0])&quot; data=&quot;&quot;&amp;gt;
 *  &amp;lt;script&amp;gt;
 *    var transferTimeout = 0;
 *
 *    function setTransferTimeout (timeout) {
 *      transferTimeout = timeout;
 *    }
 *
 *    // Example 1: Upload data to a Peer
 *    function uploadFile (file, peerId) {
 *      var cb = function (error, success) {
 *        if (error) return;
 *        console.info(&quot;File has been transferred to &#x27;&quot; + peerId + &quot;&#x27; successfully&quot;);
 *      };
 *      if (transferTimeout &gt; 0) {
 *        skylinkDemo.sendBlobData(file, peerId, transferTimeout, cb);
 *      } else {
 *        skylinkDemo.sendBlobData(file, peerId, cb);
 *      }
 *    }
 *
 *    // Example 2: Upload data to a list of Peers
 *    function uploadFileGroup (file, peerIds) {
 *      var cb = function (error, success) {
 *        var listOfPeers = error ? error.listOfPeers : success.listOfPeers;
 *        var listOfPeersErrors = error ? error.transferErrors : {};
 *        for (var i = 0; i &lt; listOfPeers.length; i++) {
 *          if (listOfPeersErrors[listOfPeers[i]]) {
 *            console.error(&quot;Failed file transfer to &#x27;&quot; + listOfPeers[i] + &quot;&#x27;&quot;);
 *          } else {
 *            console.info(&quot;File has been transferred to &#x27;&quot; + listOfPeers[i] + &quot;&#x27; successfully&quot;);
 *          }
 *        }
 *      };
 *      if (transferTimeout &gt; 0) {
 *        skylinkDemo.sendBlobData(file, peerIds, transferTimeout, cb);
 *      } else {
 *        skylinkDemo.sendBlobData(file, peerIds, cb);
 *      }
 *    }
 *
 *    // Example 2: Upload data to a list of Peers
 *    function uploadFileAll (file) {
 *      var cb = function (error, success) {
 *        var listOfPeers = error ? error.listOfPeers : success.listOfPeers;
 *        var listOfPeersErrors = error ? error.transferErrors : {};
 *        for (var i = 0; i &lt; listOfPeers.length; i++) {
 *          if (listOfPeersErrors[listOfPeers[i]]) {
 *            console.error(&quot;Failed file transfer to &#x27;&quot; + listOfPeers[i] + &quot;&#x27;&quot;);
 *          } else {
 *            console.info(&quot;File has been transferred to &#x27;&quot; + listOfPeers[i] + &quot;&#x27; successfully&quot;);
 *          }
 *        }
 *      };
 *      if (transferTimeout &gt; 0) {
 *        skylinkDemo.sendBlobData(file, transferTimeout, cb);
 *      } else {
 *        skylinkDemo.sendBlobData(file, cb);
 *      }
 *    }
 * &amp;lt;/script&amp;gt;
 * &amp;lt;/body&amp;gt;
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype.sendBlobData = function(data, timeout, targetPeerId, sendChunksAsBinary, callback) {
  this._startDataTransfer(data, timeout, targetPeerId, sendChunksAsBinary, callback, &#x27;blob&#x27;);
};

/**
 * Function that starts an uploading string data transfer from User to Peers.
 * @method sendURLData
 * @param {String} data The data string to transfer to Peer.
 * @param {Number} [timeout=60] The timeout to wait for response from Peer.
 * @param {String|Array} [targetPeerId] The target Peer ID to start data transfer with.
 * - When provided as an Array, it will start uploading data transfers with all connections
 *   with all the Peer IDs provided.
 * - When not provided, it will start uploading data transfers with all the currently connected Peers in the Room.
 * @param {Function} [callback] The callback function fired when request has completed.
 *   &lt;small&gt;Function parameters signature is &lt;code&gt;function (error, success)&lt;/code&gt;&lt;/small&gt;
 *   &lt;small&gt;Function request completion is determined by the &lt;a href=&quot;#event_dataTransferState&quot;&gt;
 *   &lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggering &lt;code&gt;state&lt;/code&gt; parameter payload
 *   as &lt;code&gt;UPLOAD_COMPLETED&lt;/code&gt; for all Peers targeted for request success.&lt;/small&gt;
 * @param {JSON} callback.error The error result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are no errors in request&lt;/small&gt;
 * @param {String} callback.error.transferId The data transfer ID.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when &lt;code&gt;sendURLData()&lt;/code&gt; fails to start data transfer.&lt;/small&gt;
 * @param {Array} callback.error.listOfPeers The list Peer IDs targeted for the data transfer.
 * @param {JSON} callback.error.transferErrors The list of data transfer errors.
 * @param {Error|String} callback.error.transferErrors.#peerId The data transfer error associated
 *   with the Peer ID defined in &lt;code&gt;#peerId&lt;/code&gt; property.
 *   &lt;small&gt;If &lt;code&gt;#peerId&lt;/code&gt; value is &lt;code&gt;&quot;self&quot;&lt;/code&gt;, it means that it is the error when there
 *   are no Peer connections to start data transfer with.&lt;/small&gt;
 * @param {JSON} callback.error.transferInfo The data transfer information.
 *   &lt;small&gt;Object signature matches the &lt;code&gt;transferInfo&lt;/code&gt; parameter payload received in the
 *   &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; except without the
 *   &lt;code&gt;percentage&lt;/code&gt; property and &lt;code&gt;data&lt;/code&gt;.&lt;/small&gt;
 * @param {JSON} callback.success The success result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are errors in request&lt;/small&gt;
 * @param {String} callback.success.transferId The data transfer ID.
 * @param {Array} callback.success.listOfPeers The list Peer IDs targeted for the data transfer.
 * @param {JSON} callback.success.transferInfo The data transfer information.
 *   &lt;small&gt;Object signature matches the &lt;code&gt;transferInfo&lt;/code&gt; parameter payload received in the
 *   &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; except without the
 *   &lt;code&gt;percentage&lt;/code&gt; property and &lt;code&gt;data&lt;/code&gt;.&lt;/small&gt;
 * @trigger &lt;small&gt;Event sequence follows &lt;a href=&quot;#method_sendBlobData&quot;&gt;
 * &lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @example
 * &amp;lt;body&amp;gt;
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(0)&quot;&amp;gt; 1s timeout (Default)
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(120)&quot;&amp;gt; 2s timeout
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(300)&quot;&amp;gt; 5s timeout
 *  &amp;lt;hr&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;showImage(this.files[0], this.getAttribute(&#x27;data&#x27;))&quot; data=&quot;peerId&quot;&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;showImageGroup(this.files[0], this.getAttribute(&#x27;data&#x27;).split(&#x27;,&#x27;)))&quot; data=&quot;peerIdA,peerIdB&quot;&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;showImageAll(this.files[0])&quot; data=&quot;&quot;&amp;gt;
 *  &amp;lt;image id=&quot;target-1&quot; src=&quot;&quot;&amp;gt;
 *  &amp;lt;image id=&quot;target-2&quot; src=&quot;&quot;&amp;gt;
 *  &amp;lt;image id=&quot;target-3&quot; src=&quot;&quot;&amp;gt;
 *  &amp;lt;script&amp;gt;
 *    var transferTimeout = 0;
 *
 *    function setTransferTimeout (timeout) {
 *      transferTimeout = timeout;
 *    }
 *
 *    function retrieveImageDataURL(file, cb) {
 *      var fr = new FileReader();
 *      fr.onload = function () {
 *        cb(fr.result);
 *      };
 *      fr.readAsDataURL(files[0]);
 *    }
 *
 *    // Example 1: Send image data URL to a Peer
 *    function showImage (file, peerId) {
 *      var cb = function (error, success) {
 *        if (error) return;
 *        console.info(&quot;Image has been transferred to &#x27;&quot; + peerId + &quot;&#x27; successfully&quot;);
 *      };
 *      retrieveImageDataURL(file, function (str) {
 *        if (transferTimeout &gt; 0) {
 *          skylinkDemo.sendURLData(str, peerId, transferTimeout, cb);
 *        } else {
 *          skylinkDemo.sendURLData(str, peerId, cb);
 *        }
 *        document.getElementById(&quot;target-1&quot;).src = str;
 *      });
 *    }
 *
 *    // Example 2: Send image data URL to a list of Peers
 *    function showImageGroup (file, peerIds) {
 *      var cb = function (error, success) {
 *        var listOfPeers = error ? error.listOfPeers : success.listOfPeers;
 *        var listOfPeersErrors = error ? error.transferErrors : {};
 *        for (var i = 0; i &lt; listOfPeers.length; i++) {
 *          if (listOfPeersErrors[listOfPeers[i]]) {
 *            console.error(&quot;Failed image transfer to &#x27;&quot; + listOfPeers[i] + &quot;&#x27;&quot;);
 *          } else {
 *            console.info(&quot;Image has been transferred to &#x27;&quot; + listOfPeers[i] + &quot;&#x27; successfully&quot;);
 *          }
 *        }
 *      };
 *      retrieveImageDataURL(file, function (str) {
 *        if (transferTimeout &gt; 0) {
 *          skylinkDemo.sendURLData(str, peerIds, transferTimeout, cb);
 *        } else {
 *          skylinkDemo.sendURLData(str, peerIds, cb);
 *        }
 *        document.getElementById(&quot;target-2&quot;).src = str;
 *      });
 *    }
 *
 *    // Example 2: Send image data URL to a list of Peers
 *    function uploadFileAll (file) {
 *      var cb = function (error, success) {
 *        var listOfPeers = error ? error.listOfPeers : success.listOfPeers;
 *        var listOfPeersErrors = error ? error.transferErrors : {};
 *        for (var i = 0; i &lt; listOfPeers.length; i++) {
 *          if (listOfPeersErrors[listOfPeers[i]]) {
 *            console.error(&quot;Failed image transfer to &#x27;&quot; + listOfPeers[i] + &quot;&#x27;&quot;);
 *          } else {
 *            console.info(&quot;Image has been transferred to &#x27;&quot; + listOfPeers[i] + &quot;&#x27; successfully&quot;);
 *          }
 *        }
 *      };
 *      retrieveImageDataURL(file, function (str) {
 *        if (transferTimeout &gt; 0) {
 *          skylinkDemo.sendURLData(str, transferTimeout, cb);
 *        } else {
 *          skylinkDemo.sendURLData(str, cb);
 *        }
 *        document.getElementById(&quot;target-3&quot;).src = str;
 *      });
 *    }
 * &amp;lt;/script&amp;gt;
 * &amp;lt;/body&amp;gt;
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype.sendURLData = function(data, timeout, targetPeerId, callback) {
  this._startDataTransfer(data, timeout, targetPeerId, callback, null, &#x27;data&#x27;);
};

/**
 * Function that accepts or rejects an upload data transfer request from Peer to User.
 * @method acceptDataTransfer
 * @param {String} peerId The Peer ID.
 * @param {String} transferId The data transfer ID.
 * @param {Boolean} [accept=false] The flag if User accepts the upload data transfer request from Peer.
 * @example
 *   // Example 1: Accept Peer upload data transfer request
 *   skylinkDemo.on(&quot;incomingDataRequest&quot;, function (transferId, peerId, transferInfo, isSelf) {
 *      if (!isSelf) {
 *        skylinkDemo.acceptDataTransfer(peerId, transferId, true);
 *      }
 *   });
 *
 *   // Example 2: Reject Peer upload data transfer request
 *   skylinkDemo.on(&quot;incomingDataRequest&quot;, function (transferId, peerId, transferInfo, isSelf) {
 *      if (!isSelf) {
 *        skylinkDemo.acceptDataTransfer(peerId, transferId, false);
 *      }
 *   });
 * @trigger &lt;small&gt;Event sequence follows &lt;a href=&quot;#method_sendBlobData&quot;&gt;
 * &lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt; after &lt;code&gt;acceptDataTransfer()&lt;/code&gt; method is invoked.&lt;/small&gt;
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype.respondBlobRequest =
Skylink.prototype.acceptDataTransfer = function (peerId, transferId, accept) {
  var self = this;

  if (typeof transferId !== &#x27;string&#x27; &amp;&amp; typeof peerId !== &#x27;string&#x27;) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Aborting accept data transfer as &#x27; +
      &#x27;data transfer ID or peer ID is not provided&#x27;]);
    return;
  }

  if (!self._dataChannels[peerId]) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Aborting accept data transfer as &#x27; +
      &#x27;Peer does not have any Datachannel connections&#x27;]);
    return;
  }

  if (!self._dataTransfers[transferId]) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Aborting accept data transfer as &#x27; +
      &#x27;invalid transfer ID is provided&#x27;]);
    return;
  }

  // Check Datachannel property in _dataChannels[peerId] list
  var channelProp = &#x27;main&#x27;;
  var dataChannelStateCbFn = null;

  if (self._dataChannels[peerId][transferId]) {
    channelProp = transferId;
  }

  // From here we start detecting as completion for data transfer downloads
  self.once(&#x27;dataTransferState&#x27;, function () {
    if (dataChannelStateCbFn) {
      self.off(&#x27;dataChannelState&#x27;, dataChannelStateCbFn);
    }

    delete self._dataTransfers[transferId];

    if (self._dataChannels[peerId]) {
      if (channelProp === &#x27;main&#x27; &amp;&amp; self._dataChannels[peerId].main) {
        self._dataChannels[peerId].main.transferId = null;
      }

      if (channelProp === transferId) {
        self._closeDataChannel(peerId, transferId);
      }
    }
  }, function (state, evtTransferId, evtPeerId) {
    return evtTransferId === transferId &amp;&amp; evtPeerId === peerId &amp;&amp; [
      self.DATA_TRANSFER_STATE.ERROR,
      self.DATA_TRANSFER_STATE.CANCEL,
      self.DATA_TRANSFER_STATE.DOWNLOAD_COMPLETED,
      self.DATA_TRANSFER_STATE.USER_REJECTED].indexOf(state) &gt; -1;
  });

  if (accept) {
    log.debug([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Accepted data transfer and starting ...&#x27;]);

    dataChannelStateCbFn = function (state, evtPeerId, error, cN, cT) {
      log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Data transfer &quot;&#x27; + transferId + &#x27;&quot; has been terminated due to connection.&#x27;]);
      
      self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.ERROR, transferId, peerId,
        self._getTransferInfo(transferId, peerId, true, false, false), {
        transferType: self.DATA_TRANSFER_TYPE.DOWNLOAD,
        message: new Error(&#x27;Data transfer terminated as Peer Datachannel connection closed abruptly.&#x27;)
      });
    };
  
    self.once(&#x27;dataChannelState&#x27;, dataChannelStateCbFn, function (state, evtPeerId, error, channelName, channelType) {
      if (!(self._dataTransfers[transferId] &amp;&amp; self._dataTransfers[transferId].sessions[peerId])) {
        self.off(&#x27;dataChannelState&#x27;, dataChannelStateCbFn);
        return;
      }

      return evtPeerId === peerId &amp;&amp; (channelProp === &#x27;main&#x27; ?
        channelType === self.DATA_CHANNEL_STATE.MESSAGING : channelName === transferId) &amp;&amp; [
        self.DATA_CHANNEL_STATE.CLOSING,
        self.DATA_CHANNEL_STATE.CLOSED,
        self.DATA_CHANNEL_STATE.ERROR].indexOf(state) &gt; -1;
    });

    // Send ACK protocol to start data transfer
    // MCU sends the data transfer from the &quot;P2P&quot; Datachannel
    self._sendMessageToDataChannel(peerId, {
      type: self._DC_PROTOCOL_TYPE.ACK,
      sender: self._user.sid,
      ackN: 0
    }, channelProp);

    self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.DOWNLOAD_STARTED, transferId, peerId,
      self._getTransferInfo(transferId, peerId, true, false, false), null);

  } else {
    log.warn([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Rejected data transfer and data transfer request has been aborted&#x27;]);

    // Send ACK protocol to terminate data transfer request
    // MCU sends the data transfer from the &quot;P2P&quot; Datachannel
    self._sendMessageToDataChannel(peerId, {
      type: self._DC_PROTOCOL_TYPE.ACK,
      sender: self._user.sid,
      ackN: -1
    }, channelProp);

    self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.USER_REJECTED, transferId, peerId,
      self._getTransferInfo(transferId, peerId, true, false, false), {
      message: new Error(&#x27;Data transfer terminated as User has rejected data transfer request.&#x27;),
      transferType: self.DATA_TRANSFER_TYPE.DOWNLOAD
    });
  }
};

/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   For MCU enabled Peer connections, the cancel data transfer functionality may differ, as it
 *   will result in all Peers related to the data transfer ID to be terminated.
 * &lt;/blockquote&gt;
 * Function that terminates a currently uploading / downloading data transfer from / to Peer.
 * @method cancelDataTransfer
 * @param {String} peerId The Peer ID.
 * @param {String} transferId The data transfer ID.
 * @example
 *   // Example 1: Cancel Peer data transfer
 *   var transferSessions = {};
 *
 *   skylinkDemo.on(&quot;dataTransferState&quot;, function (state, transferId, peerId) {
 *     if ([skylinkDemo.DATA_TRANSFER_STATE.DOWNLOAD_STARTED,
 *       skylinkDemo.DATA_TRANSFER_STATE.UPLOAD_STARTED].indexOf(state) &gt; -1) {
 *       if (!Array.isArray(transferSessions[transferId])) {
 *         transferSessions[transferId] = [];
 *       }
 *       transferSessions[transferId].push(peerId);
 *     } else {
 *       transferSessions[transferId].splice(transferSessions[transferId].indexOf(peerId), 1);
 *     }
 *   });
 *
 *   function cancelTransfer (peerId, transferId) {
 *     skylinkDemo.cancelDataTransfer(peerId, transferId);
 *   }
 * @trigger &lt;small&gt;Event sequence follows &lt;a href=&quot;#method_sendBlobData&quot;&gt;
 * &lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt; after &lt;code&gt;cancelDataTransfer()&lt;/code&gt; method is invoked.&lt;/small&gt;
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype.cancelBlobTransfer =
Skylink.prototype.cancelDataTransfer = function (peerId, transferId) {
  var self = this;

  if (!(transferId &amp;&amp; typeof transferId === &#x27;string&#x27;)) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Aborting cancel data transfer as data transfer ID is not provided&#x27;]);
    return;
  }

  if (!(peerId &amp;&amp; typeof peerId === &#x27;string&#x27;)) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Aborting cancel data transfer as peer ID is not provided&#x27;]);
    return;
  }

  if (!self._dataTransfers[transferId]) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Aborting cancel data transfer as &#x27; +
      &#x27;data transfer session does not exists.&#x27;]);
    return;
  }

  log.debug([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Canceling data transfer ...&#x27;]);

  /**
   * Emit data state event function.
   */
  var emitEventFn = function (peers, transferInfoPeerId) {
    for (var i = 0; i &lt; peers.length; i++) {
      self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.CANCEL, transferId, peers[i],
        self._getTransferInfo(transferId, transferInfoPeerId, false, false, false), {
        transferType: self._dataTransfers[transferId].direction,
        message: new Error(&#x27;User cancelled download transfer&#x27;)
      });
    }
  };

  // For uploading from Peer to MCU case of broadcast
  if (self._hasMCU &amp;&amp; self._dataTransfers[transferId].direction === self.DATA_TRANSFER_TYPE.UPLOAD) {
    if (!self._dataChannels.MCU) {
      log.error([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Aborting cancel data transfer as &#x27; +
        &#x27;Peer does not have any Datachannel connections&#x27;]);
      return;
    }

    // We abort all data transfers to all Peers if uploading via MCU since it broadcasts to MCU
    log.warn([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Aborting all data transfers to Peers&#x27;]);

    // If data transfer to MCU broadcast has interop Peers, send to MCU via the &quot;main&quot; Datachannel
    if (Object.keys(self._dataTransfers[transferId].peers.main).length &gt; 0) {
      self._sendMessageToDataChannel(&#x27;MCU&#x27;, {
        type: self._DC_PROTOCOL_TYPE.CANCEL,
        sender: self._user.sid,
        content: &#x27;Peer cancelled download transfer&#x27;,
        name: self._dataTransfers[transferId].name,
        ackN: 0
      }, &#x27;main&#x27;);
    }

    // If data transfer to MCU broadcast has non-interop Peers, send to MCU via the new Datachanel
    if (Object.keys(self._dataTransfers[transferId].peers[transferId]).length &gt; 0) {
      self._sendMessageToDataChannel(&#x27;MCU&#x27;, {
        type: self._DC_PROTOCOL_TYPE.CANCEL,
        sender: self._user.sid,
        content: &#x27;Peer cancelled download transfer&#x27;,
        name: self._dataTransfers[transferId].name,
        ackN: 0
      }, transferId);
    }

    emitEventFn(Object.keys(self._dataTransfers[transferId].peers.main).concat(
      Object.keys(self._dataTransfers[transferId].peers[transferId])));
  } else {
    var channelProp = &#x27;main&#x27;;

    if (!self._dataChannels[peerId]) {
      log.error([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Aborting cancel data transfer as &#x27; +
        &#x27;Peer does not have any Datachannel connections&#x27;]);
      return;
    }

    if (self._dataChannels[peerId][transferId]) {
      channelProp = transferId;
    }

    self._sendMessageToDataChannel(peerId, {
      type: self._DC_PROTOCOL_TYPE.CANCEL,
      sender: self._user.sid,
      content: &#x27;Peer cancelled download transfer&#x27;,
      name: self._dataTransfers[transferId].name,
      ackN: 0
    }, channelProp);

    emitEventFn([peerId], peerId);
  }
};

/**
 * Function that sends a message to Peers via the Datachannel connection.
 * &lt;small&gt;Consider using &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; if you are
 * sending large strings to Peers.&lt;/small&gt;
 * @method sendP2PMessage
 * @param {String|JSON} message The message.
 * @param {String|Array} [targetPeerId] The target Peer ID to send message to.
 * - When provided as an Array, it will send the message to only Peers which IDs are in the list.
 * - When not provided, it will broadcast the message to all connected Peers with Datachannel connection in the Room.
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *  &lt;li&gt;Sends P2P message to all targeted Peers. &lt;ol&gt;
 *  &lt;li&gt;If Peer connection Datachannel has not been opened: &lt;small&gt;This can be checked with
 *  &lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt;
 *  triggering parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt; and
 *  &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;MESSAGING&lt;/code&gt; for Peer.&lt;/small&gt; &lt;ol&gt;
 *  &lt;li&gt;&lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggers
 *  parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;SEND_MESSAGE_ERROR&lt;/code&gt;.&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *  &lt;li&gt;&lt;a href=&quot;#event_incomingMessage&quot;&gt;&lt;code&gt;incomingMessage&lt;/code&gt; event&lt;/a&gt; triggers
 *  parameter payload &lt;code&gt;message.isDataChannel&lt;/code&gt; value as &lt;code&gt;true&lt;/code&gt; and
 *  &lt;code&gt;isSelf&lt;/code&gt; value as &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
 * @example
 *   // Example 1: Broadcasting to all Peers
 *   skylinkDemo.on(&quot;dataChannelState&quot;, function (state, peerId, error, channelName, channelType) {
 *      if (state === skylinkDemo.DATA_CHANNEL_STATE.OPEN &amp;&amp;
 *        channelType === skylinkDemo.DATA_CHANNEL_TYPE.MESSAGING) {
 *        skylinkDemo.sendP2PMessage(&quot;Hi all!&quot;);
 *      }
 *   });
 *
 *   // Example 2: Sending to specific Peers
 *   var peersInExclusiveParty = [];
 *
 *   skylinkDemo.on(&quot;peerJoined&quot;, function (peerId, peerInfo, isSelf) {
 *     if (isSelf) return;
 *     if (peerInfo.userData.exclusive) {
 *       peersInExclusiveParty[peerId] = false;
 *     }
 *   });
 *
 *   skylinkDemo.on(&quot;dataChannelState&quot;, function (state, peerId, error, channelName, channelType) {
 *      if (state === skylinkDemo.DATA_CHANNEL_STATE.OPEN &amp;&amp;
 *        channelType === skylinkDemo.DATA_CHANNEL_TYPE.MESSAGING) {
 *        peersInExclusiveParty[peerId] = true;
 *      }
 *   });
 *
 *   function updateExclusivePartyStatus (message) {
 *     var readyToSend = [];
 *     for (var p in peersInExclusiveParty) {
 *       if (peersInExclusiveParty.hasOwnProperty(p)) {
 *         readyToSend.push(p);
 *       }
 *     }
 *     skylinkDemo.sendP2PMessage(message, readyToSend);
 *   }
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype.sendP2PMessage = function(message, targetPeerId) {
  var listOfPeers = Object.keys(this._dataChannels);
  var isPrivate = false;

  if (Array.isArray(targetPeerId)) {
    listOfPeers = targetPeerId;
    isPrivate = true;
  } else if (targetPeerId &amp;&amp; typeof targetPeerId === &#x27;string&#x27;) {
    listOfPeers = [targetPeerId];
    isPrivate = true;
  }

  if (!this._inRoom || !(this._user &amp;&amp; this._user.sid)) {
    log.error(&#x27;Unable to send message as User is not in Room. -&gt;&#x27;, message);
    return;
  }

  if (!this._initOptions.enableDataChannel) {
    log.error(&#x27;Unable to send message as User does not have Datachannel enabled. -&gt;&#x27;, message);
    return;
  }

  // Loop out unwanted Peers
  for (var i = 0; i &lt; listOfPeers.length; i++) {
    var peerId = listOfPeers[i];

    if (!this._dataChannels[peerId]) {
      log.error([peerId, &#x27;RTCDataChannel&#x27;, null, &#x27;Dropping of sending message to Peer as &#x27; +
        &#x27;Datachannel connection does not exists&#x27;]);
      listOfPeers.splice(i, 1);
      i--;
    } else if (peerId === &#x27;MCU&#x27;) {
      listOfPeers.splice(i, 1);
      i--;
    } else if (!this._hasMCU) {
      log.debug([peerId, &#x27;RTCDataChannel&#x27;, null, &#x27;Sending &#x27; + (isPrivate ? &#x27;private&#x27; : &#x27;&#x27;) +
        &#x27; P2P message to Peer&#x27;]);

      this._sendMessageToDataChannel(peerId, {
        type: this._DC_PROTOCOL_TYPE.MESSAGE,
        isPrivate: isPrivate,
        sender: this._user.sid,
        target: peerId,
        data: message
      }, &#x27;main&#x27;);
    }
  }

  if (listOfPeers.length === 0) {
    log.warn(&#x27;Currently there are no Peers to send P2P message to (unless the message is queued &#x27; +
      &#x27;and there are Peer connected by then).&#x27;);
  }

  if (this._hasMCU) {
    log.debug([&#x27;MCU&#x27;, &#x27;RTCDataChannel&#x27;, null, &#x27;Broadcasting &#x27; + (isPrivate ? &#x27;private&#x27; : &#x27;&#x27;) +
      &#x27; P2P message to Peers&#x27;]);

    this._sendMessageToDataChannel(&#x27;MCU&#x27;, {
      type: this._DC_PROTOCOL_TYPE.MESSAGE,
      isPrivate: isPrivate,
      sender: this._user.sid,
      target: listOfPeers,
      data: message
    }, &#x27;main&#x27;);
  }

  this._trigger(&#x27;incomingMessage&#x27;, {
    content: message,
    isPrivate: isPrivate,
    targetPeerId: targetPeerId || null,
    listOfPeers: listOfPeers,
    isDataChannel: true,
    senderPeerId: this._user.sid
  }, this._user.sid, this.getPeerInfo(), true);
};

/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this feature is not supported by MCU enabled Peer connections and the
 *   &lt;code&gt;enableSimultaneousTransfers&lt;/code&gt; flag has to be enabled in the &lt;a href=&quot;#method_init&quot;&gt;
 *   &lt;code&gt;init()&lt;/code&gt; method&lt;/a&gt; in order for this functionality to work.&lt;br&gt;
 *   To start streaming data, see the &lt;a href=&quot;#method_streamData&quot;&gt;&lt;code&gt;streamData()&lt;/code&gt;
 *   method&lt;/a&gt;. To stop data streaming session, see the &lt;a href=&quot;#method_stopStreamingData&quot;&gt;&lt;code&gt;
 *   stopStreamingData()&lt;/code&gt; method&lt;/a&gt;.
 * &lt;/blockquote&gt;
 * Function that starts a data chunks streaming session from User to Peers.
 * @method startStreamingData
 * @param {Boolean} [isStringStream=false] The flag if data streaming session sending data chunks
 *   should be expected as string data chunks sent.
 *   &lt;small&gt;By default, data chunks are expected to be sent in Blob or ArrayBuffer, and ArrayBuffer
 *   data chunks will be converted to Blob.&lt;/small&gt;
 * @param {String|Array} [targetPeerId] The target Peer ID to send message to.
 * - When provided as an Array, it will start streaming session to only Peers which IDs are in the list.
 * - When not provided, it will start the streaming session to all connected Peers with Datachannel connection in the Room.
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *   &lt;li&gt;Checks if User is in Room. &lt;ol&gt;
 *   &lt;li&gt;If User is not in Room: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataStreamState&quot;&gt;
 *   &lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt;
 *   as &lt;code&gt;START_ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Checks if there is any available Datachannel connections. &lt;ol&gt;
 *   &lt;li&gt;If User is not in Room: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataStreamState&quot;&gt;
 *   &lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt;
 *   as &lt;code&gt;START_ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Checks if Peer connection and Datachannel connection are in correct states. &lt;ol&gt;
 *   &lt;li&gt;If Peer connection or session does not exists: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataStreamState&quot;&gt;
 *   &lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt;
 *   as &lt;code&gt;START_ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If Peer connection messaging Datachannel has not been opened: &lt;small&gt;This can be checked with
 *   &lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggering parameter
 *   payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as
 *   &lt;code&gt;MESSAGING&lt;/code&gt; for Peer.&lt;/small&gt; &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataStreamState&quot;&gt;
 *   &lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;START_ERROR&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If MCU is enabled for the App Key provided in &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt;method&lt;/a&gt; and connected: &lt;ol&gt;
 *   &lt;li&gt;If MCU Peer connection messaging Datachannel has not been opened: &lt;small&gt;This can be checked with
 *   &lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggering parameter
 *   payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt;, &lt;code&gt;peerId&lt;/code&gt; value as &lt;code&gt;&quot;MCU&quot;&lt;/code&gt;
 *   and &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;MESSAGING&lt;/code&gt; for MCU Peer.&lt;/small&gt;
 *   &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataStreamState&quot;&gt;&lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt; triggers
 *   parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;START_ERROR&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Checks if should open a new data Datachannel.&lt;ol&gt;
 *   &lt;li&gt;If Peer supports simultaneous data streaming, open new data Datachannel: &lt;small&gt;If MCU is connected,
 *   this opens a new data Datachannel with MCU Peer with all the Peers IDs information that supports
 *   simultaneous data transfers targeted for the data streaming session instead of opening new data Datachannel
 *   with all Peers targeted for the data streaming session.&lt;/small&gt; &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggers parameter
 *   payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;CONNECTING&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;DATA&lt;/code&gt;.
 *   &lt;small&gt;Note that there is no timeout to wait for parameter payload &lt;code&gt;state&lt;/code&gt; to be
 *   &lt;code&gt;OPEN&lt;/code&gt;.&lt;/small&gt;&lt;/li&gt;
 *   &lt;li&gt;If Datachannel has been created and opened successfully: &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;DATA&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Else: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;CREATE_ERROR&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as
 *   &lt;code&gt;DATA&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;#event_dataStreamState&quot;&gt;&lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt; triggers
 *   parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;START_ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and
 *   return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;Else: &lt;small&gt;If MCU is connected,
 *   this uses the messaging Datachannel with MCU Peer with all the Peers IDs information that supports
 *   simultaneous data transfers targeted for the data streaming session instead of using the messaging Datachannels
 *   with all Peers targeted for the data streaming session.&lt;/small&gt; &lt;ol&gt;&lt;li&gt;If messaging Datachannel connection has a
 *   data streaming in-progress: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataStreamState&quot;&gt;&lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;START_ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and
 *   return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;If there is any conflicting &lt;a href=&quot;#method_streamData&quot;&gt;&lt;code&gt;streamData()&lt;/code&gt;
 *   method&lt;/a&gt; data streaming session: &lt;small&gt;If &lt;code&gt;isStringStream&lt;/code&gt; is provided as &lt;code&gt;true&lt;/code&gt; and
 *   &lt;a href=&quot;#method_sendBlobData&quot;&gt;&lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt; or &lt;a href=&quot;#method_sendURLData&quot;&gt;
 *   &lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; has an existing binary string transfer, it cannot start string data
 *   streaming session. Else if &lt;a href=&quot;#method_sendBlobData&quot;&gt;&lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt;
 *   has an existing binary data transfer, it cannot start binary data streaming session.&lt;/small&gt;&lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataStreamState&quot;&gt;&lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;START_ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and
 *   return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Starts the data streaming session with Peer. &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_incomingDataStreamStarted&quot;&gt;&lt;code&gt;incomingDataStreamStarted&lt;/code&gt; event&lt;/a&gt; triggers.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For User only&lt;/em&gt; &lt;a href=&quot;#event_dataStreamState&quot;&gt;&lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;SENDING_STARTED&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For Peer only&lt;/em&gt; &lt;a href=&quot;#event_dataStreamState&quot;&gt;&lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;RECEIVING_STARTED&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
 * @example
 *   // Example 1: Start streaming to all Peers
 *   skylinkDemo.on(&quot;dataChannelState&quot;, function (state, peerId, error, channelName, channelType) {
 *      if (state === skylinkDemo.DATA_CHANNEL_STATE.OPEN &amp;&amp;
 *        channelType === skylinkDemo.DATA_CHANNEL_TYPE.MESSAGING) {
 *        skylinkDemo.startStreamingData(false);
 *      }
 *   });
 *
 *   // Example 2: Start streaming to specific Peers
 *   var peersInExclusiveParty = [];
 *
 *   skylinkDemo.on(&quot;peerJoined&quot;, function (peerId, peerInfo, isSelf) {
 *     if (isSelf) return;
 *     if (peerInfo.userData.exclusive) {
 *       peersInExclusiveParty[peerId] = false;
 *     }
 *   });
 *
 *   skylinkDemo.on(&quot;dataChannelState&quot;, function (state, peerId, error, channelName, channelType) {
 *      if (state === skylinkDemo.DATA_CHANNEL_STATE.OPEN &amp;&amp;
 *        channelType === skylinkDemo.DATA_CHANNEL_TYPE.MESSAGING) {
 *        peersInExclusiveParty[peerId] = true;
 *      }
 *   });
 *
 *   function updateExclusivePartyStatus (message) {
 *     var readyToSend = [];
 *     for (var p in peersInExclusiveParty) {
 *       if (peersInExclusiveParty.hasOwnProperty(p)) {
 *         readyToSend.push(p);
 *       }
 *     }
 *     skylinkDemo.startStreamingData(message, readyToSend);
 *   }
 * @beta
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype.startStreamingData = function(isStringStream, targetPeerId) {
  var self = this;
  var listOfPeers = Object.keys(self._dataChannels);
  var isPrivate = false;
  var sessionChunkType = &#x27;binary&#x27;;

  if (Array.isArray(targetPeerId)) {
    listOfPeers = targetPeerId;
    isPrivate = true;
  } else if (targetPeerId &amp;&amp; typeof targetPeerId === &#x27;string&#x27;) {
    listOfPeers = [targetPeerId];
    isPrivate = true;
  }

  if (Array.isArray(isStringStream)) {
    listOfPeers = isStringStream;
    targetPeerId = isStringStream;
    isPrivate = true;
  } else if (isStringStream &amp;&amp; typeof isStringStream === &#x27;string&#x27;) {
    listOfPeers = [isStringStream];
    targetPeerId = isStringStream;
    isPrivate = true;
  } else if (isStringStream &amp;&amp; typeof isStringStream === &#x27;boolean&#x27;) {
    sessionChunkType = &#x27;string&#x27;;
  }

  var sessionInfo = {
    chunk: null,
    chunkSize: 0,
    chunkType: sessionChunkType === &#x27;string&#x27; ? self.DATA_TRANSFER_DATA_TYPE.STRING : self._binaryChunkType,
    isPrivate: isPrivate,
    isStringStream: sessionChunkType === &#x27;string&#x27;,
    senderPeerId: self._user &amp;&amp; self._user.sid ? self._user.sid : null
  };

  // Remove MCU from list
  if (listOfPeers.indexOf(&#x27;MCU&#x27;) &gt; -1) {
    listOfPeers.splice(listOfPeers.indexOf(&#x27;MCU&#x27;), 1);
  }

  var emitErrorBeforeStreamingFn = function (error) {
    log.error(error);

    /*if (listOfPeers.length &gt; 0) {
      for (var i = 0; i &lt; listOfPeers.length; i++) {
        self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.START_ERROR, null,
          listOfPeers[i], sessionInfo, new Error(error));
      }
    } else {
      self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.START_ERROR, null,
        null, sessionInfo, new Error(error));
    }*/
  };

  if (!this._inRoom || !(this._user &amp;&amp; this._user.sid)) {
    return emitErrorBeforeStreamingFn(&#x27;Unable to start data streaming as User is not in Room.&#x27;);
  }

  if (!this._initOptions.enableDataChannel) {
    return emitErrorBeforeStreamingFn(&#x27;Unable to start data streaming as User does not have Datachannel enabled.&#x27;);
  }

  if (listOfPeers.length === 0) {
    return emitErrorBeforeStreamingFn(&#x27;Unable to start data streaming as there are no Peers to start session with.&#x27;);
  }

  if (self._hasMCU) {
    return emitErrorBeforeStreamingFn(&#x27;Unable to start data streaming as this feature is current not supported by MCU yet.&#x27;);
  }

  if (!self._initOptions.enableSimultaneousTransfers) {
    return emitErrorBeforeStreamingFn(&#x27;Unable to start data streaming as this feature requires simultaneous data transfers to be enabled&#x27;);
  }

  var transferId = &#x27;stream_&#x27; + (self._user &amp;&amp; self._user.sid ? self._user.sid : &#x27;-&#x27;) + &#x27;_&#x27; + (new Date()).getTime();
  var peersInterop = [];
  var peersNonInterop = [];
  var sessions = {};
  var listenToPeerFn = function (peerId, channelProp) {
    var hasStarted = false;
    sessions[peerId] = channelProp;

    self.once(&#x27;dataStreamState&#x27;, function () {}, function (state, evtTransferId, evtPeerId, evtSessionInfo) {
      if (!(evtTransferId === transferId &amp;&amp; evtPeerId === peerId)) {
        return;
      }

      var dataChunk = evtSessionInfo.chunk;
      var updatedSessionInfo = clone(evtSessionInfo);
      delete updatedSessionInfo.chunk;

      if (state === self.DATA_STREAM_STATE.SENDING_STARTED) {
        hasStarted = true;
        return;
      }

      if (hasStarted &amp;&amp; [self.DATA_STREAM_STATE.ERROR, self.DATA_STREAM_STATE.SENDING_STOPPED].indexOf(state) &gt; -1) {
        if (channelProp === transferId) {
          self._closeDataChannel(peerId, transferId);
        }

        if (self._dataStreams[transferId] &amp;&amp; self._dataStreams[transferId].sessions[peerId]) {
          delete self._dataStreams[transferId].sessions[peerId];

          if (Object.keys(self._dataStreams[transferId].sessions).length === 0) {
            delete self._dataStreams[transferId];
          }
        }
        return true;
      }
    });
  };

  // Loop out unwanted Peers
  for (var i = 0; i &lt; listOfPeers.length; i++) {
    var peerId = listOfPeers[i];
    var error = null;
    var dtProtocolVersion = ((self._peerInformations[peerId] || {}).agent || {}).DTProtocolVersion || &#x27;&#x27;;
    var channelProp = self._isLowerThanVersion(dtProtocolVersion, &#x27;0.1.2&#x27;) || !self._initOptions.enableSimultaneousTransfers ? &#x27;main&#x27; : transferId;

    if (!(self._dataChannels[peerId] &amp;&amp; self._dataChannels[peerId].main)) {
      error = &#x27;Datachannel connection does not exists&#x27;;
    } else if (self._hasMCU &amp;&amp; !(self._dataChannels.MCU &amp;&amp; self._dataChannels.MCU.main)) {
      error = &#x27;MCU Datachannel connection does not exists&#x27;;
    } else if (self._isLowerThanVersion(dtProtocolVersion, &#x27;0.1.3&#x27;)) {
      error = &#x27;Peer DTProtocolVersion does not support data streaming. (received: &quot;&#x27; + dtProtocolVersion + &#x27;&quot;, expected: &quot;0.1.3&quot;)&#x27;;
    } else {
      if (channelProp === &#x27;main&#x27;) {
        var dataTransferId = self._hasMCU ? self._dataChannels.MCU.main.transferId : self._dataChannels[peerId].main.transferId;

        if (self._dataChannels[peerId].main.streamId) {
          error = &#x27;Peer Datachannel currently has an active data transfer session.&#x27;;
        } else if (self._hasMCU &amp;&amp; self._dataChannels.MCU.main.streamId) {
          error = &#x27;MCU Peer Datachannel currently has an active data transfer session.&#x27;;
        } else if (self._dataTransfers[dataTransferId] &amp;&amp; self._dataTransfers[dataTransferId].sessionChunkType === sessionChunkType) {
          error = (self._hasMCU ? &#x27;MCU &#x27; : &#x27;&#x27;) + &#x27;Peer Datachannel currently has an active &#x27; + sessionChunkType + &#x27; data transfer.&#x27;;
        } else {
          peersInterop.push(peerId);
        }
      } else {
        peersNonInterop.push(peerId);
      }
    }

    if (error) {
      self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.START_ERROR, transferId, peerId, sessionInfo, new Error(error));
      listOfPeers.splice(i, 1);
      i--;
    } else {
      listenToPeerFn(peerId, channelProp);
    }
  }

  if (listOfPeers.length === 0) {
    log.warn(&#x27;There are no Peers to start data session with.&#x27;);
    return;
  }

  self._dataStreams[transferId] = {
    sessions: sessions,
    chunkType: sessionChunkType === &#x27;string&#x27; ? self.DATA_TRANSFER_DATA_TYPE.STRING : self._binaryChunkType,
    sessionChunkType: sessionChunkType,
    isPrivate: isPrivate,
    isStringStream: sessionChunkType === &#x27;string&#x27;,
    senderPeerId: self._user &amp;&amp; self._user.sid ? self._user.sid : null,
    isUpload: true
  };

  var startDataSessionFn = function (peerId, channelProp, targetPeers) {
    self.once(&#x27;dataChannelState&#x27;, function () {}, function (state, evtPeerId, channelName, channelType, error) {
      if (!self._dataStreams[transferId]) {
        return true;
      }

      if (!(evtPeerId === peerId &amp;&amp; (channelProp === &#x27;main&#x27; ? channelType === self.DATA_CHANNEL_TYPE.MESSAGING :
        channelName === transferId &amp;&amp; channelType === self.DATA_CHANNEL_TYPE.DATA))) {
        return;
      }

      if ([self.DATA_CHANNEL_STATE.ERROR, self.DATA_CHANNEL_STATE.CLOSED].indexOf(state) &gt; -1) {
        var updatedError = new Error(error &amp;&amp; error.message ? error.message :
          &#x27;Failed data transfer as datachannel state is &quot;&#x27; + state + &#x27;&quot;.&#x27;);

        if (peerId === &#x27;MCU&#x27;) {
          for (var mp = 0; mp &lt; targetPeers.length; mp++) {
            self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.ERROR, transferId, targetPeers[mp], sessionInfo, updatedError);
          }
        } else {
          self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.ERROR, transferId, peerId, sessionInfo, updatedError);
        }
        return true;
      }
    });

    if (!(self._dataChannels[peerId][channelProp] &amp;&amp;
      self._dataChannels[peerId][channelProp].channel.readyState === self.DATA_CHANNEL_STATE.OPEN)) {
      var notOpenError = new Error(&#x27;Failed starting data streaming session as channel is not opened.&#x27;);
      if (peerId === &#x27;MCU&#x27;) {
        for (i = 0; i &lt; targetPeers.length; i++) {
          self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.START_ERROR, transferId, targetPeers[i], sessionInfo, notOpenError);
        }
      } else {
        self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.START_ERROR, transferId, peerId, sessionInfo, notOpenError);
      }
    }

    self._sendMessageToDataChannel(peerId, {
      type: self._DC_PROTOCOL_TYPE.WRQ,
      transferId: transferId,
      name: transferId,
      size: 0,
      originalSize: 0,
      dataType: &#x27;fastBinaryStart&#x27;,
      mimeType: null,
      chunkType: sessionChunkType,
      chunkSize: 0,
      timeout: 0,
      isPrivate: isPrivate,
      sender: self._user.sid,
      agent: AdapterJS.webrtcDetectedBrowser,
      version: AdapterJS.webrtcDetectedVersion,
      target: peerId === &#x27;MCU&#x27; ? targetPeers : peerId
    }, channelProp);
    self._dataChannels[peerId][channelProp].streamId = transferId;

    var updatedSessionInfo = clone(sessionInfo);
    delete updatedSessionInfo.chunk;

    if (peerId === &#x27;MCU&#x27;) {
      for (var tp = 0; tp &lt; targetPeers.length; tp++) {
        self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.SENDING_STARTED, transferId, targetPeers[tp], sessionInfo, null);
        self._trigger(&#x27;incomingDataStreamStarted&#x27;, transferId, targetPeers[tp], updatedSessionInfo, true);
      }
    } else {
      self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.SENDING_STARTED, transferId, peerId, sessionInfo, null);
      self._trigger(&#x27;incomingDataStreamStarted&#x27;, transferId, peerId, updatedSessionInfo, true);
    }
  };

  var waitForChannelOpenFn = function (peerId, targetPeers) {
    self.once(&#x27;dataChannelState&#x27;, function (state, evtPeerId, error) {
      if (state === self.DATA_CHANNEL_STATE.CREATE_ERROR) {
        if (peerId === &#x27;MCU&#x27;) {
          for (var mp = 0; mp &lt; targetPeers.length; mp++) {
            self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.START_ERROR, transferId, targetPeers[mp], sessionInfo, error);
          }
        } else {
          self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.START_ERROR, transferId, peerId, sessionInfo, error);
        }
        return;
      }
      startDataSessionFn(peerId, transferId, targetPeers);
    }, function (state, evtPeerId, error, channelName, channelType) {
      if (evtPeerId === peerId &amp;&amp; channelName === transferId &amp;&amp; channelType === self.DATA_CHANNEL_TYPE.DATA) {
        return [self.DATA_CHANNEL_STATE.CREATE_ERROR, self.DATA_CHANNEL_STATE.OPEN].indexOf(state) &gt; -1;
      }
    });
    self._createDataChannel(peerId, transferId, sessionChunkType === &#x27;string&#x27; ? self._CHUNK_DATAURL_SIZE :
      (AdapterJS.webrtcDetectedBrowser === &#x27;firefox&#x27; ? self._MOZ_BINARY_FILE_SIZE : self._BINARY_FILE_SIZE));
  };

  if (peersNonInterop.length &gt; 0) {
    if (self._hasMCU) {
      waitForChannelOpenFn(&#x27;MCU&#x27;, peersNonInterop);
    } else {
      for (var pni = 0; pni &lt; peersNonInterop.length; pni++) {
        waitForChannelOpenFn(peersNonInterop[pni], null);
      }
    }
  }

  if (peersInterop.length &gt; 0) {
    if (self._hasMCU) {
      startDataSessionFn(&#x27;MCU&#x27;, &#x27;main&#x27;, peersInterop);
    } else {
      for (var pi = 0; pi &lt; peersInterop.length; pi++) {
        startDataSessionFn(peersInterop[pi], &#x27;main&#x27;, null);
      }
    }
  }
};

/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this feature is not supported by MCU enabled Peer connections.&lt;br&gt;
 *   To start data streaming session, see the &lt;a href=&quot;#method_startStreamingData&quot;&gt;&lt;code&gt;startStreamingData()&lt;/code&gt;
 *   method&lt;/a&gt;. To stop data streaming session, see the &lt;a href=&quot;#method_stopStreamingData&quot;&gt;&lt;code&gt;stopStreamingData()&lt;/code&gt; method&lt;/a&gt;
 * &lt;/blockquote&gt;
 * Function that sends a data chunk from User to Peers for an existing active data streaming session.
 * @method streamData
 * @param {String} streamId The data streaming session ID.
 * @param {String|Blob|ArrayBuffer} chunk The data chunk.
 *   &lt;small&gt;By default when it is not string data streaming, data chunks when is are expected to be
 *   sent in Blob or ArrayBuffer, and ArrayBuffer data chunks will be converted to Blob.&lt;/small&gt;
 *   &lt;small&gt;For binary data chunks, the limit is &lt;code&gt;65456&lt;/code&gt;.&lt;/small&gt;
 *   &lt;small&gt;For string data chunks, the limit is &lt;code&gt;1212&lt;/code&gt;.&lt;/small&gt;
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *   &lt;li&gt;Checks if Peer connection and Datachannel connection are in correct states. &lt;ol&gt;
 *   &lt;li&gt;If Peer connection (or MCU Peer connection if enabled)
 *   data streaming Datachannel has not been opened: &lt;small&gt;This can be checked with
 *   &lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggering parameter
 *   payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as
 *   &lt;code&gt;MESSAGING&lt;/code&gt; for Peer.&lt;/small&gt; &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataStreamState&quot;&gt;
 *   &lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Starts sending the data chunk to Peer. &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_incomingDataStream&quot;&gt;&lt;code&gt;incomingDataStream&lt;/code&gt; event&lt;/a&gt; triggers.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For User only&lt;/em&gt; &lt;a href=&quot;#event_dataStreamState&quot;&gt;&lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;SENT&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For Peer only&lt;/em&gt; &lt;a href=&quot;#event_dataStreamState&quot;&gt;&lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;RECEIVED&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
 * @example
 *   // Example 1: Start streaming
 *   var currentStreamId = null
 *   if (file.size &gt; chunkLimit) {
 *     while ((file.size - 1) &gt; endCount) {
 *       endCount = startCount + chunkLimit;
 *       chunks.push(file.slice(startCount, endCount));
 *       startCount += chunkLimit;
 *     }
 *     if ((file.size - (startCount + 1)) &gt; 0) {
 *       chunks.push(file.slice(startCount, file.size - 1));
 *     }
 *   } else {
 *     chunks.push(file);
 *   }
 *   var processNextFn = function () {
 *     if (chunks.length &gt; 0) {
 *       skylinkDemo.once(&quot;incomingDataStream&quot;, function () {
 *         setTimeout(processNextFn, 1);
 *       }, function (data, evtStreamId, evtPeerId, streamInfo, isSelf) {
 *         return isSelf &amp;&amp; evtStreamId === currentStreamId;
 *       });
 *       var chunk = chunks[0];
 *       chunks.splice(0, 1);
 *       skylinkDemo.streamData(currentStreamId, chunk);
 *     } else {
 *       skylinkDemo.stopStreamingData(currentStreamId);
 *     }
 *   };
 *   skylinkDemo.once(&quot;incomingDataStreamStarted&quot;, processNextFn, function (streamId, peerId, streamInfo, isSelf) {
 *     currentStreamId = streamId;
 *     return isSelf;
 *   });
 *   skylinkDemo.once(&quot;incomingDataStreamStopped&quot;, function () {
 *     // Render file
 *   }, function (streamId, peerId, streamInfo, isSelf) {
 *     return currentStreamId === streamId &amp;&amp; isSelf;
 *   });
 *   skylinkDemo.startStreamingData(false);
 * @beta
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype.streamData = function(transferId, dataChunk) {
  var self = this;

  if (!(transferId &amp;&amp; typeof transferId === &#x27;string&#x27;)) {
    log.error(&#x27;Failed streaming data chunk as stream session ID is not provided.&#x27;);
    return;
  }

  if (!(dataChunk &amp;&amp; typeof dataChunk === &#x27;object&#x27; &amp;&amp; (dataChunk instanceof Blob || dataChunk instanceof ArrayBuffer))) {
    log.error(&#x27;Failed streaming data chunk as it is not provided.&#x27;);
    return;
  }

  if (!(self._inRoom &amp;&amp; self._user &amp;&amp; self._user.sid)) {
    log.error(&#x27;Failed streaming data chunk as User is not in the Room.&#x27;);
    return;
  }

  if (!self._dataStreams[transferId]) {
    log.error(&#x27;Failed streaming data chunk as session does not exists.&#x27;);
    return;
  }

  if (!self._dataStreams[transferId].isUpload) {
    log.error(&#x27;Failed streaming data chunk as session is not sending.&#x27;);
    return;
  }

  if (self._dataStreams[transferId].sessionChunkType === &#x27;string&#x27; ? typeof dataChunk !== &#x27;string&#x27; :
    typeof dataChunk !== &#x27;object&#x27;) {
    log.error(&#x27;Failed streaming data chunk as data chunk does not match expected data type.&#x27;);
    return;
  }

  if (self._hasMCU) {
    log.error(&#x27;Failed streaming data chunk as MCU does not support this feature yet.&#x27;);
    return;
  }

  var updatedDataChunk = dataChunk instanceof ArrayBuffer ? new Blob(dataChunk) : dataChunk;

  if (self._dataStreams[transferId].sessionChunkType === &#x27;string&#x27; ? updatedDataChunk.length &gt; self._CHUNK_DATAURL_SIZE :
    updatedDataChunk.length &gt; self._BINARY_FILE_SIZE) {
    log.error(&#x27;Failed streaming data chunk as data chunk exceeds maximum chunk limit.&#x27;);
    return;
  }

  var sessionInfo = {
    chunk: updatedDataChunk,
    chunkSize: updatedDataChunk.size || updatedDataChunk.length || updatedDataChunk.byteLength,
    chunkType: self._dataStreams[transferId].sessionChunkType === &#x27;string&#x27; ?
      self.DATA_TRANSFER_DATA_TYPE.STRING : self._binaryChunkType,
    isPrivate: self._dataStreams[transferId].sessionChunkType.isPrivate,
    isStringStream: self._dataStreams[transferId].sessionChunkType === &#x27;string&#x27;,
    senderPeerId: self._user &amp;&amp; self._user.sid ? self._user.sid : null
  };

  var peersInterop = [];
  var peersNonInterop = [];
  var sendDataFn = function (peerId, channelProp, targetPeers) {
    // When ready to be sent
    var onSendDataFn = function (buffer) {
      self._sendMessageToDataChannel(peerId, buffer, channelProp, true);

      var updatedSessionInfo = clone(sessionInfo);
      delete updatedSessionInfo.chunk;

      if (targetPeers) {
        for (var i = 0; i &lt; targetPeers.length; i++) {
          self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.SENT, transferId, targetPeers[i], sessionInfo, null);
          self._trigger(&#x27;incomingDataStream&#x27;, dataChunk, transferId, targetPeers[i], updatedSessionInfo, true);
        }
      } else {
        self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.SENT, transferId, peerId, sessionInfo, null);
        self._trigger(&#x27;incomingDataStream&#x27;, dataChunk, transferId, peerId, updatedSessionInfo, true);
      }
    };

    if (dataChunk instanceof Blob &amp;&amp; sessionInfo.chunkType === self.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER) {
      self._blobToArrayBuffer(dataChunk, onSendDataFn);
    } else if (!(dataChunk instanceof Blob) &amp;&amp; sessionInfo.chunkType === self.DATA_TRANSFER_DATA_TYPE.BLOB) {
      onSendDataFn(new Blob([dataChunk]));
    } else if (AdapterJS.webrtcDetectedType === &#x27;plugin&#x27; &amp;&amp; typeof dataChunk !== &#x27;string&#x27;) {
      onSendDataFn(new Int8Array(dataChunk));
    } else {
      onSendDataFn(dataChunk);
    }
  };

  for (var peerId in self._dataStreams[transferId].sessions) {
    if (self._dataStreams[transferId].sessions.hasOwnProperty(peerId) &amp;&amp; self._dataStreams[transferId].sessions[peerId]) {
      var channelProp = self._dataStreams[transferId].sessions[peerId];

      if (!(self._dataChannels[self._hasMCU ? &#x27;MCU&#x27; : peerId] &amp;&amp; self._dataChannels[self._hasMCU ? &#x27;MCU&#x27; : peerId][channelProp] &amp;&amp;
        self._dataChannels[self._hasMCU ? &#x27;MCU&#x27; : peerId][channelProp].channel.readyState === self.DATA_CHANNEL_STATE.OPEN &amp;&amp;
        self._dataChannels[self._hasMCU ? &#x27;MCU&#x27; : peerId][channelProp].streamId === transferId)) {
        log.error([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Failed streaming data as it has not started or is ready.&#x27;]);
        self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.ERROR, transferId, peerId, sessionInfo,
          new Error(&#x27;Streaming as it has not started or Datachannel connection is not open.&#x27;));
        return;
      }

      if (self._hasMCU) {
        if (channelProp === &#x27;main&#x27;) {
          peersInterop.push(peerId);
        } else {
          peersNonInterop.push(peerId);
        }
      } else {
        sendDataFn(peerId, channelProp);
      }
    }
  }

  if (self._hasMCU) {
    if (peersInterop.length &gt; 0) {
      sendDataFn(peerId, &#x27;main&#x27;, peersInterop);
    }
    if (peersNonInterop.length &gt; 0) {
      sendDataFn(peerId, transferId, peersNonInterop);
    }
  }
};

/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   To start data streaming session, see the &lt;a href=&quot;#method_startStreamingData&quot;&gt;&lt;code&gt;startStreamingData()&lt;/code&gt;
 *   method&lt;/a&gt; To start streaming data, see the &lt;a href=&quot;#method_streamData&quot;&gt;&lt;code&gt;streamData()&lt;/code&gt;
 *   method&lt;/a&gt;.
 * &lt;/blockquote&gt;
 * Function that stops a data chunks streaming session from User to Peers.
 * @method stopStreamingData
 * @param {String} streamId The data streaming session ID.
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *   &lt;li&gt;Checks if Peer connection and Datachannel connection are in correct states. &lt;ol&gt;
 *   &lt;li&gt;If Peer connection (or MCU Peer connection if enabled)
 *   data streaming Datachannel has not been opened: &lt;small&gt;This can be checked with
 *   &lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggering parameter
 *   payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as
 *   &lt;code&gt;MESSAGING&lt;/code&gt; for Peer.&lt;/small&gt; &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_dataStreamState&quot;&gt;
 *   &lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; step and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Stops the data streaming session to Peer. &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_incomingDataStreamStopped&quot;&gt;&lt;code&gt;incomingDataStreamStopped&lt;/code&gt; event&lt;/a&gt; triggers.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For User only&lt;/em&gt; &lt;a href=&quot;#event_dataStreamState&quot;&gt;&lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;SENDING_STOPPED&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;em&gt;For Peer only&lt;/em&gt; &lt;a href=&quot;#event_dataStreamState&quot;&gt;&lt;code&gt;dataStreamState&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;RECEIVING_STOPPED&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
 * @example
 *   skylinkDemo.stopStreamData(streamId);
 * @beta
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype.stopStreamingData = function(transferId) {
  var self = this;

  if (!(transferId &amp;&amp; typeof transferId === &#x27;string&#x27;)) {
    log.error(&#x27;Failed streaming data chunk as stream session ID is not provided.&#x27;);
    return;
  }

  if (!(self._inRoom &amp;&amp; self._user &amp;&amp; self._user.sid)) {
    log.error(&#x27;Failed streaming data chunk as User is not in the Room.&#x27;);
    return;
  }

  if (!self._dataStreams[transferId]) {
    log.error(&#x27;Failed stopping data streaming session as it does not exists.&#x27;);
    return;
  }

  if (!self._dataStreams[transferId].isUpload) {
    log.error(&#x27;Failed stopping data streaming session as it is not sending.&#x27;);
    return;
  }

  if (self._hasMCU) {
    log.error(&#x27;Failed stopping data streaming session as MCU does not support this feature yet.&#x27;);
    return;
  }

  var sessionInfo = {
    chunk: null,
    chunkSize: 0,
    chunkType: self._dataStreams[transferId].sessionChunkType === &#x27;string&#x27; ?
      self.DATA_TRANSFER_DATA_TYPE.STRING : self._binaryChunkType,
    isPrivate: self._dataStreams[transferId].sessionChunkType.isPrivate,
    isStringStream: self._dataStreams[transferId].sessionChunkType === &#x27;string&#x27;,
    senderPeerId: self._user &amp;&amp; self._user.sid ? self._user.sid : null
  };

  var peersInterop = [];
  var peersNonInterop = [];
  var sendDataFn = function (peerId, channelProp, targetPeers) {
    self._sendMessageToDataChannel(peerId, {
      type: self._DC_PROTOCOL_TYPE.WRQ,
      transferId: transferId,
      name: transferId,
      size: 0,
      originalSize: 0,
      dataType: &#x27;fastBinaryStop&#x27;,
      mimeType: null,
      chunkType: self._dataStreams[transferId].sessionChunkType,
      chunkSize: 0,
      timeout: 0,
      isPrivate: self._dataStreams[transferId].isPrivate,
      sender: self._user.sid,
      agent: AdapterJS.webrtcDetectedBrowser,
      version: AdapterJS.webrtcDetectedVersion,
      target: targetPeers ? targetPeers : peerId
    }, channelProp);

    var updatedSessionInfo = clone(sessionInfo);
    delete updatedSessionInfo.chunk;

    if (targetPeers) {
      for (var i = 0; i &lt; targetPeers.length; i++) {
        self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.SENDING_STOPPED, transferId, targetPeers[i], sessionInfo, null);
        self._trigger(&#x27;incomingDataStreamStopped&#x27;, transferId, targetPeers[i], updatedSessionInfo, true);
      }
    } else {
      self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.SENDING_STOPPED, transferId, peerId, sessionInfo, null);
      self._trigger(&#x27;incomingDataStreamStopped&#x27;, transferId, peerId, updatedSessionInfo, true);
    }
  };

  for (var peerId in self._dataStreams[transferId].sessions) {
    if (self._dataStreams[transferId].sessions.hasOwnProperty(peerId) &amp;&amp; self._dataStreams[transferId].sessions[peerId]) {
      var channelProp = self._dataStreams[transferId].sessions[peerId];

      if (!(self._dataChannels[self._hasMCU ? &#x27;MCU&#x27; : peerId] &amp;&amp; self._dataChannels[self._hasMCU ? &#x27;MCU&#x27; : peerId][channelProp] &amp;&amp;
        self._dataChannels[self._hasMCU ? &#x27;MCU&#x27; : peerId][channelProp].channel.readyState === self.DATA_CHANNEL_STATE.OPEN &amp;&amp;
        self._dataChannels[self._hasMCU ? &#x27;MCU&#x27; : peerId][channelProp].streamId === transferId)) {
        log.error([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Failed stopping data streaming session as channel is closed.&#x27;]);
        self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.ERROR, transferId, peerId, sessionInfo,
          new Error(&#x27;Failed stopping data streaming session as Datachannel connection is not open or is active.&#x27;));
        return;
      }

      if (self._hasMCU) {
        if (self._dataStreams[transferId].sessions[peerId] === &#x27;main&#x27;) {
          peersInterop.push(peerId);
        } else {
          peersNonInterop.push(peerId);
        }
      } else {
        sendDataFn(peerId, channelProp);
      }
    }
  }

  if (self._hasMCU) {
    if (peersInterop.length &gt; 0) {
      sendDataFn(peerId, &#x27;main&#x27;, peersInterop);
    }
    if (peersNonInterop.length &gt; 0) {
      sendDataFn(peerId, transferId, peersNonInterop);
    }
  }
};


/**
 * Function that starts the data transfer to Peers.
 * @method _startDataTransfer
 * @private
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype._startDataTransfer = function(data, timeout, targetPeerId, sendChunksAsBinary, callback, sessionType) {
  var self = this;
  var transferId = (self._user ? self._user.sid : &#x27;&#x27;) + &#x27;_&#x27; + (new Date()).getTime();
  var transferErrors = {};
  var transferCompleted = [];
  var chunks = [];
  var listOfPeers = Object.keys(self._peerConnections);
  var sessionChunkType = &#x27;string&#x27;;
  var transferInfo = {
    name: null,
    size: null,
    chunkSize: null,
    chunkType: null,
    dataType: null,
    mimeType: null,
    direction: self.DATA_TRANSFER_TYPE.UPLOAD,
    timeout: 60,
    isPrivate: false,
    percentage: 0
  };

  // sendBlobData(.., timeout)
  if (typeof timeout === &#x27;number&#x27;) {
    transferInfo.timeout = timeout;
  } else if (Array.isArray(timeout)) {
    listOfPeers = timeout;
  } else if (timeout &amp;&amp; typeof timeout === &#x27;string&#x27;) {
    listOfPeers = [timeout];
  } else if (timeout &amp;&amp; typeof timeout === &#x27;boolean&#x27;) {
    sessionChunkType = &#x27;binary&#x27;;
  } else if (typeof timeout === &#x27;function&#x27;) {
    callback = timeout;
  }

  // sendBlobData(.., .., targetPeerId)
  if (Array.isArray(targetPeerId)) {
    listOfPeers = targetPeerId;
  } else if (targetPeerId &amp;&amp; typeof targetPeerId === &#x27;string&#x27;) {
    listOfPeers = [targetPeerId];
  } else if (targetPeerId &amp;&amp; typeof targetPeerId === &#x27;boolean&#x27;) {
    sessionChunkType = &#x27;binary&#x27;;
  } else if (typeof targetPeerId === &#x27;function&#x27;) {
    callback = targetPeerId;
  }

  // sendBlobData(.., .., .., sendChunksAsBinary)
  if (sendChunksAsBinary &amp;&amp; typeof sendChunksAsBinary === &#x27;boolean&#x27;) {
    sessionChunkType = &#x27;binary&#x27;;
  } else if (typeof sendChunksAsBinary === &#x27;function&#x27;) {
    callback = sendChunksAsBinary;
  }

  // Remove MCU Peer as list of Peers
  if (listOfPeers.indexOf(&#x27;MCU&#x27;) &gt; -1) {
    listOfPeers.splice(listOfPeers.indexOf(&#x27;MCU&#x27;), 1);
  }

  // Function that returns the error emitted before data transfer has started
  var emitErrorBeforeDataTransferFn = function (error) {
    log.error(error);

    if (typeof callback === &#x27;function&#x27;) {
      var transferErrors = {};

      if (listOfPeers.length === 0) {
        transferErrors.self = new Error(error);
        /*self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.START_ERROR, null, null, transferInfo, {
          transferType: self.DATA_TRANSFER_TYPE.DOWNLOAD,
          message: new Error(error)
        });*/
      } else {
        for (var i = 0; i &lt; listOfPeers.length; i++) {
          transferErrors[listOfPeers[i]] = new Error(error);
          /*self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.START_ERROR, null, listOfPeers[i], transferInfo, {
            transferType: self.DATA_TRANSFER_TYPE.DOWNLOAD,
            message: new Error(error)
          });*/
        }
      }

      callback({
        transferId: null,
        transferInfo: transferInfo,
        listOfPeers: listOfPeers,
        transferErrors: transferErrors
      }, null);
    }
  };

  if (sessionType === &#x27;blob&#x27;) {
    if (self._hasMCU &amp;&amp; sessionChunkType === &#x27;binary&#x27;) {
      log.warn(&#x27;Binary data chunks transfer is not yet supported with MCU environment. &#x27; +
        &#x27;Fallbacking to binary string data chunks transfer.&#x27;);
      sessionChunkType = &#x27;string&#x27;;
    }

    var chunkSize = sessionChunkType === &#x27;string&#x27; ? (AdapterJS.webrtcDetectedBrowser === &#x27;firefox&#x27; ?
      self._MOZ_CHUNK_FILE_SIZE : self._CHUNK_FILE_SIZE) : (AdapterJS.webrtcDetectedBrowser === &#x27;firefox&#x27; ?
      self._MOZ_BINARY_FILE_SIZE : self._BINARY_FILE_SIZE);

    transferInfo.dataType = self.DATA_TRANSFER_SESSION_TYPE.BLOB;
    transferInfo.chunkSize = sessionChunkType === &#x27;string&#x27; ? 4 * Math.ceil(chunkSize / 3) : chunkSize;
    transferInfo.chunkType = sessionChunkType === &#x27;binary&#x27; ? self._binaryChunkType : self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING;

    // Start checking if data transfer can start
    if (!(data &amp;&amp; typeof data === &#x27;object&#x27; &amp;&amp; data instanceof Blob)) {
      emitErrorBeforeDataTransferFn(&#x27;Provided data is not a Blob data&#x27;);
      return;
    }

    transferInfo.name = data.name || transferId;
    transferInfo.mimeType = data.type || null;

    if (data.size &lt; 1) {
      emitErrorBeforeDataTransferFn(&#x27;Provided data is not a valid Blob data.&#x27;);
      return;
    }

    transferInfo.originalSize = data.size;
    transferInfo.size = sessionChunkType === &#x27;string&#x27; ? 4 * Math.ceil(data.size / 3) : data.size;
    chunks = self._chunkBlobData(data, chunkSize);
  } else {
    transferInfo.dataType = self.DATA_TRANSFER_SESSION_TYPE.DATA_URL;
    transferInfo.chunkSize = self._CHUNK_DATAURL_SIZE;
    transferInfo.chunkType = self.DATA_TRANSFER_DATA_TYPE.STRING;

    // Start checking if data transfer can start
    if (!(data &amp;&amp; typeof data === &#x27;string&#x27;)) {
      emitErrorBeforeDataTransferFn(&#x27;Provided data is not a dataURL&#x27;);
      return;
    }

    transferInfo.originalSize = transferInfo.size = data.length || data.size;
    chunks = self._chunkDataURL(data, transferInfo.chunkSize);
  }

  if (!(self._user &amp;&amp; self._user.sid)) {
    emitErrorBeforeDataTransferFn(&#x27;Unable to send any &#x27; +
      sessionType.replace(&#x27;data&#x27;, &#x27;dataURL&#x27;) + &#x27; data. User is not in Room.&#x27;);
    return;
  }

  if (!self._initOptions.enableDataChannel) {
    emitErrorBeforeDataTransferFn(&#x27;Unable to send any &#x27; +
      sessionType.replace(&#x27;data&#x27;, &#x27;dataURL&#x27;) + &#x27; data. Datachannel is disabled&#x27;);
    return;
  }

  if (listOfPeers.length === 0) {
    emitErrorBeforeDataTransferFn(&#x27;Unable to send any &#x27; +
      sessionType.replace(&#x27;data&#x27;, &#x27;dataURL&#x27;) + &#x27; data. There are no Peers to start data transfer with&#x27;);
    return;
  }

  self._dataTransfers[transferId] = clone(transferInfo);
  self._dataTransfers[transferId].peers = {};
  self._dataTransfers[transferId].peers.main = {};
  self._dataTransfers[transferId].peers[transferId] = {};
  self._dataTransfers[transferId].sessions = {};
  self._dataTransfers[transferId].chunks = chunks;
  self._dataTransfers[transferId].enforceBSPeers = [];
  self._dataTransfers[transferId].enforcedBSInfo = {};
  self._dataTransfers[transferId].sessionType = sessionType;
  self._dataTransfers[transferId].sessionChunkType = sessionChunkType;
  self._dataTransfers[transferId].senderPeerId = self._user.sid;

  // Check if fallback chunks is required
  if (sessionType === &#x27;blob&#x27; &amp;&amp; sessionChunkType === &#x27;binary&#x27;) {
    for (var p = 0; p &lt; listOfPeers.length; p++) {
      var protocolVer = (((self._peerInformations[listOfPeers[p]]) || {}).agent || {}).DTProtocolVersion || &#x27;0.1.0&#x27;;

      // C++ SDK does not support binary file transfer for now
      if (self._isLowerThanVersion(protocolVer, &#x27;0.1.3&#x27;)) {
        self._dataTransfers[transferId].enforceBSPeers.push(listOfPeers[p]);
      }
    }

    if (self._dataTransfers[transferId].enforceBSPeers.length &gt; 0) {
      var bsChunkSize = AdapterJS.webrtcDetectedBrowser === &#x27;firefox&#x27; ? self._MOZ_CHUNK_FILE_SIZE : self._CHUNK_FILE_SIZE;
      var bsChunks = self._chunkBlobData(new Blob(chunks), bsChunkSize);

      self._dataTransfers[transferId].enforceBSInfo = {
        chunkSize: 4 * Math.ceil(bsChunkSize / 3),
        chunkType: self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING,
        size: 4 * Math.ceil(transferInfo.originalSize / 3),
        chunks: bsChunks
      };
    }
  }

  /**
   * Complete Peer function.
   */
  var completeFn = function (peerId, error) {
    // Ignore if already added.
    if (transferCompleted.indexOf(peerId) &gt; -1) {
      return;
    }

    log.debug([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Data transfer result. Is errors present? -&gt;&#x27;], error);

    transferCompleted.push(peerId);

    if (error) {
      transferErrors[peerId] = new Error(error);
    }

    if (listOfPeers.length === transferCompleted.length) {
      log.log([null, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Data transfer request completed&#x27;]);

      if (typeof callback === &#x27;function&#x27;) {
        if (Object.keys(transferErrors).length &gt; 0) {
          callback({
            transferId: transferId,
            transferInfo: self._getTransferInfo(transferId, peerId, false, true, false),
            transferErrors: transferErrors,
            listOfPeers: listOfPeers
          }, null);
        } else {
          callback(null, {
            transferId: transferId,
            transferInfo: self._getTransferInfo(transferId, peerId, false, true, false),
            listOfPeers: listOfPeers
          });
        }
      }
    }
  };

  for (var i = 0; i &lt; listOfPeers.length; i++) {
    var MCUInteropStatus = self._startDataTransferToPeer(transferId, listOfPeers[i], completeFn, null, null);

    if (typeof MCUInteropStatus === &#x27;boolean&#x27;) {
      if (MCUInteropStatus === true) {
        self._dataTransfers[transferId].peers.main[listOfPeers[i]] = true;
      } else {
        self._dataTransfers[transferId].peers[transferId][listOfPeers[i]] = true;
      }
    }
  }

  if (self._hasMCU) {
    if (Object.keys(self._dataTransfers[transferId].peers.main).length &gt; 0) {
      self._startDataTransferToPeer(transferId, &#x27;MCU&#x27;, completeFn, &#x27;main&#x27;,
        Object.keys(self._dataTransfers[transferId].peers.main));
    }

    if (Object.keys(self._dataTransfers[transferId].peers[transferId]).length &gt; 0) {
      self._startDataTransferToPeer(transferId, &#x27;MCU&#x27;, completeFn, transferId,
        Object.keys(self._dataTransfers[transferId].peers[transferId]));
    }
  }
};

/**
 * Function that starts or listens the data transfer status to Peer.
 * This reacts differently during MCU environment.
 * @method _startDataTransferToPeer
 * @return {Boolean} Returns a Boolean only during MCU environment which flag indicates if Peer requires interop
 *   (Use messaging Datachannel connection instead).
 * @private
 * @since 0.6.16
 */
Skylink.prototype._startDataTransferToPeer = function (transferId, peerId, callback, channelProp, targetPeers) {
  var self = this;
  var peerConnectionStateCbFn = null;
  var dataChannelStateCbFn = null;

  /**
   * Emit event for Peers function.
   */
  var emitEventFn = function (cb) {
    var peers = targetPeers || [peerId];
    for (var i = 0; i &lt; peers.length; i++) {
      cb(peers[i]);
    }
  };

  /**
   * Return error and trigger them if failed before or during data transfers function.
   */
  var returnErrorBeforeTransferFn = function (error) {
    // Replace if it is a MCU Peer errors for clear indication in error message
    var updatedError = peerId === &#x27;MCU&#x27; ? error.replace(/Peer/g, &#x27;MCU Peer&#x27;) : error;

    emitEventFn(function (evtPeerId) {
      self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.ERROR, transferId, evtPeerId,
        self._getTransferInfo(transferId, peerId, true, true, false), {
        message: new Error(updatedError),
        transferType: self.DATA_TRANSFER_TYPE.UPLOAD
      });
    });
  };

  /**
   * Send WRQ protocol to start data transfers.
   */
  var sendWRQFn = function () {
    var size = self._dataTransfers[transferId].size;
    var chunkSize = self._dataTransfers[transferId].chunkSize;
    var chunkType = self._dataTransfers[transferId].sessionChunkType;

    if (self._dataTransfers[transferId].enforceBSPeers.indexOf(peerId) &gt; -1) {
      log.warn([peerId, &#x27;RTCDataChannel&#x27;, transferId,
        &#x27;Binary data chunks transfer is not yet supported with Peer connecting from &#x27; +
        &#x27;Android, iOS and C++ SDK. Fallbacking to binary string data chunks transfer.&#x27;]);

      size = self._dataTransfers[transferId].enforceBSInfo.size;
      chunkSize = self._dataTransfers[transferId].enforceBSInfo.chunkSize;
      chunkType = &#x27;string&#x27;;
    }

    self._sendMessageToDataChannel(peerId, {
      type: self._DC_PROTOCOL_TYPE.WRQ,
      transferId: transferId,
      name: self._dataTransfers[transferId].name,
      size: size,
      originalSize: self._dataTransfers[transferId].originalSize,
      dataType: self._dataTransfers[transferId].sessionType,
      mimeType: self._dataTransfers[transferId].mimeType,
      chunkType: chunkType,
      chunkSize: chunkSize,
      timeout: self._dataTransfers[transferId].timeout,
      isPrivate: self._dataTransfers[transferId].isPrivate,
      sender: self._user.sid,
      agent: AdapterJS.webrtcDetectedBrowser,
      version: AdapterJS.webrtcDetectedVersion,
      target: targetPeers ? targetPeers : peerId
    }, channelProp);

    emitEventFn(function (evtPeerId) {
      self._trigger(&#x27;incomingDataRequest&#x27;, transferId, evtPeerId,
        self._getTransferInfo(transferId, peerId, false, false, false), true);

      self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.USER_UPLOAD_REQUEST, transferId, evtPeerId,
        self._getTransferInfo(transferId, peerId, true, false, false), null);
    });
  };

  // Listen to data transfer state
  if (peerId !== &#x27;MCU&#x27;) {
    var dataTransferStateCbFn = function (state, evtTransferId, evtPeerId, transferInfo, error) {
      if (peerConnectionStateCbFn) {
        self.off(&#x27;peerConnectionState&#x27;, peerConnectionStateCbFn);
      }

      if (dataChannelStateCbFn) {
        self.off(&#x27;dataChannelState&#x27;, dataChannelStateCbFn);
      }

      if (channelProp) {
        delete self._dataTransfers[transferId].peers[channelProp][peerId];
      }

      callback(peerId, state === self.DATA_TRANSFER_STATE.UPLOAD_COMPLETED ? null :
        error.message.message || error.message.toString());

      delete self._dataTransfers[transferId].sessions[peerId];

      if (self._hasMCU &amp;&amp; Object.keys(self._dataTransfers[transferId].peers.main).length === 0 &amp;&amp;
        self._dataChannels.MCU &amp;&amp; self._dataChannels.MCU.main) {
        self._dataChannels.MCU.main.transferId = null;

      } else if (channelProp === &#x27;main&#x27; &amp;&amp; self._dataChannels[peerId] &amp;&amp; self._dataChannels[peerId].main) {
        self._dataChannels[peerId].main.transferId = null;
      }

      if (Object.keys(self._dataTransfers[transferId].sessions).length === 0) {
        delete self._dataTransfers[transferId];
      }
    };

    self.once(&#x27;dataTransferState&#x27;, dataTransferStateCbFn, function (state, evtTransferId, evtPeerId) {
      if (!(self._dataTransfers[transferId] &amp;&amp; (self._hasMCU ?
        (self._dataTransfers[transferId].peers.main[peerId] || self._dataTransfers[transferId].peers[transferId][peerId]) :
        self._dataTransfers[transferId].sessions[peerId]))) {

        if (dataTransferStateCbFn) {
          self.off(&#x27;dataTransferState&#x27;, dataTransferStateCbFn);
        }

        if (peerConnectionStateCbFn) {
          self.off(&#x27;peerConnectionState&#x27;, peerConnectionStateCbFn);
        }

        if (dataChannelStateCbFn) {
          self.off(&#x27;dataChannelState&#x27;, dataChannelStateCbFn);
        }
        return;
      }

      return evtTransferId === transferId &amp;&amp; evtPeerId === peerId &amp;&amp; [
        self.DATA_TRANSFER_STATE.UPLOAD_COMPLETED,
        self.DATA_TRANSFER_STATE.ERROR,
        self.DATA_TRANSFER_STATE.CANCEL,
        self.DATA_TRANSFER_STATE.REJECTED].indexOf(state) &gt; -1;
    });
  }

  // When Peer connection does not exists
  if (!self._peerConnections[peerId]) {
    returnErrorBeforeTransferFn(&#x27;Unable to start data transfer as Peer connection does not exists.&#x27;);
    return;
  }

  // When Peer session does not exists
  if (!self._peerInformations[peerId]) {
    returnErrorBeforeTransferFn(&#x27;Unable to start data transfer as Peer connection does not exists.&#x27;);
    return;
  }

  // When Peer connection is not STABLE
  if (self._peerConnections[peerId].signalingState !== self.PEER_CONNECTION_STATE.STABLE) {
    returnErrorBeforeTransferFn(&#x27;Unable to start data transfer as Peer connection is not stable.&#x27;);
    return;
  }

  if (!self._dataTransfers[transferId]) {
    returnErrorBeforeTransferFn(&#x27;Unable to start data transfer as data transfer session is not in order.&#x27;);
    return;
  }

  if (!(self._dataChannels[peerId] &amp;&amp; self._dataChannels[peerId].main)) {
    returnErrorBeforeTransferFn(&#x27;Unable to start data transfer as Peer Datachannel connection does not exists.&#x27;);
    return;
  }

  if (self._dataChannels[peerId].main.channel.readyState !== self.DATA_CHANNEL_STATE.OPEN) {
    returnErrorBeforeTransferFn(&#x27;Unable to start data transfer as Peer Datachannel connection is not opened.&#x27;);
    return;
  }

  var streamId = self._dataChannels[peerId].main.streamId;

  if (streamId &amp;&amp; channelProp === &#x27;main&#x27; &amp;&amp; self._dataStreams[streamId] &amp;&amp;
  // Check if session chunk streaming is string and sending is string for Peer
    ((self._dataStreams[streamId].sessionChunkType === &#x27;string&#x27; &amp;&amp;
    (self._dataTransfers[transferId].sessionChunkType === &#x27;string&#x27; ||
    self._dataTransfers[transferId].enforceBSPeers.indexOf(peerId) &gt; -1)) ||
  // Check if session chunk streaming is binary and sending is binary for Peer
    (self._dataStreams[streamId].sessionChunkType === &#x27;binary&#x27; &amp;&amp;
    self._dataStreams[streamId].sessionChunkType === &#x27;binary&#x27; &amp;&amp;
    self._dataTransfers[transferId].enforceBSPeers.indexOf(peerId) === -1))) {
    returnErrorBeforeTransferFn(&#x27;Unable to start data transfer as Peer Datachannel currently has an active &#x27; +
      self._dataStreams[streamId].sessionChunkType + &#x27; data streaming session.&#x27;);
    return;
  }

  var protocolVer = (self._peerInformations[peerId].agent || {}).DTProtocolVersion || &#x27;0.1.0&#x27;;
  var requireInterop = self._isLowerThanVersion(protocolVer, &#x27;0.1.2&#x27;) || !self._initOptions.enableSimultaneousTransfers;

  // Prevent DATA_URL (or &quot;string&quot; dataType transfers) with Android / iOS / C++ SDKs
  if (self._isLowerThanVersion(protocolVer, &#x27;0.1.2&#x27;) &amp;&amp; self._dataTransfers[transferId].sessionType === &#x27;data&#x27; &amp;&amp;
    self._dataTransfers[transferId].sessionChunkType === &#x27;string&#x27;) {
    returnErrorBeforeTransferFn(&#x27;Unable to start data transfer as Peer do not support DATA_URL type of data transfers&#x27;);
    return;
  }

  // Listen to Peer connection state for MCU Peer
  if (peerId !== &#x27;MCU&#x27; &amp;&amp; self._hasMCU) {
    channelProp = requireInterop ? &#x27;main&#x27; : transferId;

    peerConnectionStateCbFn = function () {
      returnErrorBeforeTransferFn(&#x27;Data transfer terminated as Peer connection is not stable.&#x27;);
    };

    self.once(&#x27;peerConnectionState&#x27;, peerConnectionStateCbFn, function (state, evtPeerId) {
      if (!self._dataTransfers[transferId]) {
        self.off(&#x27;peerConnectionState&#x27;, peerConnectionStateCbFn);
        return;
      }
      return state !== self.PEER_CONNECTION_STATE.STABLE &amp;&amp; evtPeerId === peerId;
    });
    return requireInterop;
  }

  if (requireInterop || channelProp === &#x27;main&#x27;) {
    // When MCU Datachannel connection has a transfer in-progress
    if (self._dataChannels[peerId].main.transferId) {
      returnErrorBeforeTransferFn(&#x27;Unable to start data transfer as Peer Datachannel has a data transfer in-progress.&#x27;);
      return;
    }
  }

  self._dataTransfers[transferId].sessions[peerId] = {
    timer: null,
    ackN: 0
  };

  dataChannelStateCbFn = function (state, evtPeerId, error) {
    // Prevent from triggering in instances where the ackN === chunks.length
    if (self._dataTransfers[transferId].sessions[peerId].ackN &gt;= (self._dataTransfers[transferId].chunks.length - 1)) {
      return;
    }

    if (error) {
      returnErrorBeforeTransferFn(error.message || error.toString());
    } else {
      returnErrorBeforeTransferFn(&#x27;Data transfer terminated as Peer Datachannel connection closed abruptly.&#x27;);
    }
  };

  self.once(&#x27;dataChannelState&#x27;, dataChannelStateCbFn, function (state, evtPeerId, error, channelName, channelType) {
    if (!(self._dataTransfers[transferId] &amp;&amp; self._dataTransfers[transferId].sessions[peerId])) {
      self.off(&#x27;dataChannelState&#x27;, dataChannelStateCbFn);
      return;
    }

    if (!(evtPeerId === peerId &amp;&amp; (channelProp === &#x27;main&#x27; ? 
      channelType === self.DATA_CHANNEL_TYPE.MESSAGING : channelName === transferId))) {
      return;
    }

    if (state === self.DATA_CHANNEL_STATE.OPEN &amp;&amp; channelProp !== &#x27;main&#x27; &amp;&amp; channelName === transferId) {
      self._dataChannels[peerId][channelProp].transferId = transferId;
      sendWRQFn();
      return false;
    }

    return [
      self.DATA_CHANNEL_STATE.CREATE_ERROR,
      self.DATA_CHANNEL_STATE.ERROR,
      self.DATA_CHANNEL_STATE.CLOSING,
      self.DATA_CHANNEL_STATE.CLOSED].indexOf(state) &gt; -1;
  });

  // Create new Datachannel for Peer to start data transfer
  if (!((requireInterop &amp;&amp; peerId !== &#x27;MCU&#x27;) || channelProp === &#x27;main&#x27;)) {
    channelProp = transferId;
    self._createDataChannel(peerId, transferId, self._dataTransfers[transferId].sessionType === &#x27;data&#x27; ?
      self._CHUNK_DATAURL_SIZE : (self._dataTransfers[transferId].sessionChunkType === &#x27;string&#x27; ?
      (AdapterJS.webrtcDetectedBrowser === &#x27;firefox&#x27; ? 16384 : 65546) : // After conversion to base64 string computed size
      (AdapterJS.webrtcDetectedBrowser === &#x27;firefox&#x27; ? self._MOZ_BINARY_FILE_SIZE : self._BINARY_FILE_SIZE)));
  } else {
    channelProp = &#x27;main&#x27;;
    self._dataChannels[peerId].main.transferId = transferId;
    sendWRQFn();
  }
};

/**
 * Function that returns the data transfer session.
 * @method _getTransferInfo
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._getTransferInfo = function (transferId, peerId, returnDataProp, hidePercentage, returnDataAtStart) {
  if (!this._dataTransfers[transferId]) {
    return {};
  }

  var transferInfo = {
    name: this._dataTransfers[transferId].name,
    size: this._dataTransfers[transferId].size,
    dataType: this._dataTransfers[transferId].dataType || this.DATA_TRANSFER_SESSION_TYPE.BLOB,
    mimeType: this._dataTransfers[transferId].mimeType || null,
    chunkSize: this._dataTransfers[transferId].chunkSize,
    chunkType: this._dataTransfers[transferId].chunkType,
    timeout: this._dataTransfers[transferId].timeout,
    isPrivate: this._dataTransfers[transferId].isPrivate,
    direction: this._dataTransfers[transferId].direction
  };

  if (this._dataTransfers[transferId].originalSize) {
    transferInfo.size = this._dataTransfers[transferId].originalSize;

  } else if (this._dataTransfers[transferId].chunkType === this.DATA_TRANSFER_DATA_TYPE.BINARY_STRING) {
    transferInfo.size = Math.ceil(transferInfo.size * 3 / 4);
  }

  if (!hidePercentage) {
    transferInfo.percentage = 0;

    if (!this._dataTransfers[transferId].sessions[peerId]) {
      if (returnDataProp) {
        transferInfo.data = null;
      }
      return transferInfo;
    }

    if (this._dataTransfers[transferId].direction === this.DATA_TRANSFER_TYPE.DOWNLOAD) {
      if (this._dataTransfers[transferId].sessions[peerId].receivedSize === this._dataTransfers[transferId].sessions[peerId].size) {
        transferInfo.percentage = 100;

      } else {
        transferInfo.percentage = parseFloat(((this._dataTransfers[transferId].sessions[peerId].receivedSize /
          this._dataTransfers[transferId].size) * 100).toFixed(2), 10);
      }
    } else {
      var chunksLength = (this._dataTransfers[transferId].enforceBSPeers.indexOf(peerId) &gt; -1 ?
        this._dataTransfers[transferId].enforceBSInfo.chunks.length : this._dataTransfers[transferId].chunks.length);

      if (this._dataTransfers[transferId].sessions[peerId].ackN === chunksLength) {
        transferInfo.percentage = 100;

      } else {
        transferInfo.percentage = parseFloat(((this._dataTransfers[transferId].sessions[peerId].ackN /
          chunksLength) * 100).toFixed(2), 10);
      }
    }

    if (returnDataProp) {
      if (typeof returnDataAtStart !== &#x27;number&#x27;) {
        if (transferInfo.percentage === 100) {
          transferInfo.data = this._getTransferData(transferId);
        } else {
          transferInfo.data = null;
        }
      } else {
        transferInfo.percentage = returnDataAtStart;

        if (returnDataAtStart === 0) {
          transferInfo.data = this._getTransferData(transferId);
        }
      }
    }
  }

  return transferInfo;
};

/**
 * Function that returns the compiled data transfer data.
 * @method _getTransferData
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._getTransferData = function (transferId) {
  if (!this._dataTransfers[transferId]) {
    return null;
  }

  if (this._dataTransfers[transferId].dataType === this.DATA_TRANSFER_SESSION_TYPE.BLOB) {
    var mimeType = {
      name: this._dataTransfers[transferId].name
    };

    if (this._dataTransfers[transferId].mimeType) {
      mimeType.type = this._dataTransfers[transferId].mimeType;
    }

    return new Blob(this._dataTransfers[transferId].chunks, mimeType);
  }

  return this._dataTransfers[transferId].chunks.join(&#x27;&#x27;);
};

/**
 * Function that handles the data transfers sessions timeouts.
 * @method _handleDataTransferTimeoutForPeer
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._handleDataTransferTimeoutForPeer = function (transferId, peerId, setPeerTO) {
  var self = this;

  if (!(self._dataTransfers[transferId] &amp;&amp; self._dataTransfers[transferId].sessions[peerId])) {
    log.debug([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Data transfer does not exists for Peer. Ignoring timeout.&#x27;]);
    return;
  }

  log.debug([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Clearing data transfer timer for Peer.&#x27;]);

  if (self._dataTransfers[transferId].sessions[peerId].timer) {
    clearTimeout(self._dataTransfers[transferId].sessions[peerId].timer);
  }

  self._dataTransfers[transferId].sessions[peerId].timer = null;

  if (setPeerTO) {
    log.debug([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Setting data transfer timer for Peer.&#x27;]);

    self._dataTransfers[transferId].sessions[peerId].timer = setTimeout(function () {
      if (!(self._dataTransfers[transferId] &amp;&amp; self._dataTransfers[transferId].sessions[peerId])) {
        log.debug([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Data transfer already ended for Peer. Ignoring expired timeout.&#x27;]);
        return;
      }

      if (!(self._user &amp;&amp; self._user.sid)) {
        log.debug([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;User is not in Room. Ignoring expired timeout.&#x27;]);
        return;
      }

      if (!self._dataChannels[peerId]) {
        log.debug([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Datachannel connection does not exists. Ignoring expired timeout.&#x27;]);
        return;
      }

      log.error([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Data transfer response has timed out.&#x27;]);

      /**
       * Emit event for Peers function.
       */
      var emitEventFn = function (cb) {
        if (peerId === &#x27;MCU&#x27;) {
          var broadcastedPeers = [self._dataTransfers[transferId].peers.main,
            self._dataTransfers[transferId].peers[transferId]];

          for (var i = 0; i &lt; broadcastedPeers.length; i++) {
            // Should not happen but insanity check
            if (!broadcastedPeers[i]) {
              continue;
            }

            for (var bcPeerId in broadcastedPeers[i]) {
              if (broadcastedPeers[i].hasOwnProperty(bcPeerId) &amp;&amp; broadcastedPeers[i][bcPeerId]) {
                cb(bcPeerId);
              }
            }
          }
        } else {
          cb(peerId);
        }
      };

      var errorMsg = &#x27;Connection Timeout. Longer than &#x27; + self._dataTransfers[transferId].timeout +
        &#x27; seconds. Connection is abolished.&#x27;;

      self._sendMessageToDataChannel(peerId, {
        type: self._DC_PROTOCOL_TYPE.ERROR,
        content: errorMsg,
        isUploadError: self._dataTransfers[transferId].direction === self.DATA_TRANSFER_TYPE.UPLOAD,
        sender: self._user.sid,
        name: self._dataTransfers[transferId].name
      }, self._dataChannels[peerId][transferId] ? transferId : &#x27;main&#x27;);

      emitEventFn(function (evtPeerId) {
        self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.ERROR, transferId, peerId,
          self._getTransferInfo(transferId, peerId, true, false, false), {
          transferType: self.DATA_TRANSFER_TYPE.DOWNLOAD,
          message: new Error(errorMsg)
        });
      });
    }, self._dataTransfers[transferId].timeout * 1000);
  }
};

/**
 * Function that handles the data received from Datachannel and
 * routes to the relevant data transfer protocol handler.
 * @method _processDataChannelData
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._processDataChannelData = function(rawData, peerId, channelName, channelType) {
  var self = this;

  var channelProp = channelType === self.DATA_CHANNEL_TYPE.MESSAGING ? &#x27;main&#x27; : channelName;
  var transferId = self._dataChannels[peerId][channelProp].transferId || null;
  var streamId = self._dataChannels[peerId][channelProp].streamId || null;
  var isStreamChunk = false;

  if (streamId &amp;&amp; self._dataStreams[streamId]) {
    isStreamChunk = self._dataStreams[streamId].sessionChunkType === &#x27;string&#x27; ? typeof rawData === &#x27;string&#x27; :
      typeof rawData === &#x27;object&#x27;;
  }

  if (!self._peerConnections[peerId]) {
    log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Dropping data received from Peer &#x27; +
      &#x27;as connection is not present -&gt;&#x27;], rawData);
    return;
  }

  if (!(self._dataChannels[peerId] &amp;&amp; self._dataChannels[peerId][channelProp])) {
    log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Dropping data received from Peer &#x27; +
      &#x27;as Datachannel connection is not present -&gt;&#x27;], rawData);
    return;
  }

  // Expect as string
  if (typeof rawData === &#x27;string&#x27;) {
    try {
      var protocolData = JSON.parse(rawData);
      isStreamChunk = false;

      log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Received protocol &quot;&#x27; + protocolData.type + &#x27;&quot; message -&gt;&#x27;], protocolData);

      // Ignore ACK, ERROR and CANCEL if there is no data transfer session in-progress
      if ([self._DC_PROTOCOL_TYPE.ACK, self._DC_PROTOCOL_TYPE.ERROR, self._DC_PROTOCOL_TYPE.CANCEL].indexOf(protocolData.type) &gt; -1 &amp;&amp;
        !(transferId &amp;&amp; self._dataTransfers[transferId] &amp;&amp; self._dataTransfers[transferId].sessions[peerId])) {
          log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Discarded protocol message as data transfer session &#x27; +
            &#x27;is not present -&gt;&#x27;], protocolData);
          return;
      }

      switch (protocolData.type) {
        case self._DC_PROTOCOL_TYPE.WRQ:
          // Discard iOS bidirectional upload when Datachannel is in-progress for data transfers
          if (transferId &amp;&amp; self._dataTransfers[transferId] &amp;&amp; self._dataTransfers[transferId].sessions[peerId]) {
            log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Rejecting bidirectional data transfer request as &#x27; +
              &#x27;it is currently not supported in the SDK -&gt;&#x27;], protocolData);

            self._sendMessageToDataChannel(peerId, {
              type: self._DC_PROTOCOL_TYPE.ACK,
              ackN: -1,
              sender: self._user.sid
            }, channelProp);
            return;
          }
          self._WRQProtocolHandler(peerId, protocolData, channelProp);
          break;
        case self._DC_PROTOCOL_TYPE.ACK:
          self._ACKProtocolHandler(peerId, protocolData, channelProp);
          break;
        case self._DC_PROTOCOL_TYPE.ERROR:
          self._ERRORProtocolHandler(peerId, protocolData, channelProp);
          break;
        case self._DC_PROTOCOL_TYPE.CANCEL:
          self._CANCELProtocolHandler(peerId, protocolData, channelProp);
          break;
        case self._DC_PROTOCOL_TYPE.MESSAGE:
          self._MESSAGEProtocolHandler(peerId, protocolData, channelProp);
          break;
        default:
          log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Discarded unknown &quot;&#x27; + protocolData.type + &#x27;&quot; message -&gt;&#x27;], protocolData);
      }

    } catch (error) {
      if (rawData.indexOf(&#x27;{&#x27;) &gt; -1 &amp;&amp; rawData.indexOf(&#x27;}&#x27;) &gt; 0) {
        log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Failed parsing protocol step data error -&gt;&#x27;], {
          data: rawData,
          error: error
        });

        self._trigger(&#x27;dataChannelState&#x27;, self.DATA_CHANNEL_STATE.ERROR, peerId, error, channelName,
          channelType, null, self._getDataChannelBuffer(peerId, channelProp));
        throw error;
      }

      if (!isStreamChunk &amp;&amp; !(transferId &amp;&amp; self._dataTransfers[transferId] &amp;&amp; self._dataTransfers[transferId].sessions[peerId])) {
        log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Discarded data chunk without session -&gt;&#x27;], rawData);
        return;
      }

      if (!isStreamChunk &amp;&amp; transferId) {
        if (self._dataTransfers[transferId].chunks[self._dataTransfers[transferId].sessions[peerId].ackN]) {
          log.warn([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Dropping data chunk &#x27; + (!isStreamChunk ? &#x27;@&#x27; +
            self._dataTransfers[transferId].sessions[peerId].ackN : &#x27;&#x27;) + &#x27; as it has already been added -&gt;&#x27;], rawData);
          return;
        }
      }

      var chunkType = self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING;

      if (!isStreamChunk ? self._dataTransfers[transferId].dataType === self.DATA_TRANSFER_SESSION_TYPE.DATA_URL : true) {
        log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Received string data chunk &#x27; + (!isStreamChunk ? &#x27;@&#x27; +
          self._dataTransfers[transferId].sessions[peerId].ackN : &#x27;&#x27;) + &#x27; with size -&gt;&#x27;], rawData.length || rawData.size);

        self._DATAProtocolHandler(peerId, rawData, self.DATA_TRANSFER_DATA_TYPE.STRING,
          rawData.length || rawData.size || 0, channelProp);

      } else {
        var removeSpaceData = rawData.replace(/\s|\r|\n/g, &#x27;&#x27;);

        log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Received binary string data chunk @&#x27; +
          self._dataTransfers[transferId].sessions[peerId].ackN + &#x27; with size -&gt;&#x27;],
          removeSpaceData.length || removeSpaceData.size);

        self._DATAProtocolHandler(peerId, self._base64ToBlob(removeSpaceData), self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING,
          removeSpaceData.length || removeSpaceData.size || 0, channelProp);
      }
    }
  } else {
    if (!isStreamChunk &amp;&amp; !(transferId &amp;&amp; self._dataTransfers[transferId] &amp;&amp; self._dataTransfers[transferId].sessions[peerId])) {
      log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Discarded data chunk without session -&gt;&#x27;], rawData);
      return;
    }

    if (!isStreamChunk &amp;&amp; transferId) {
      if (self._dataTransfers[transferId].chunks[self._dataTransfers[transferId].sessions[peerId].ackN]) {
        log.warn([peerId, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Dropping data chunk &#x27; + (!isStreamChunk ? &#x27;@&#x27; +
          self._dataTransfers[transferId].sessions[peerId].ackN : &#x27;&#x27;) + &#x27; as it has already been added -&gt;&#x27;], rawData);
        return;
      }
    }

    if (rawData instanceof Blob) {
      log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Received blob data chunk &#x27; + (isStreamChunk ? &#x27;&#x27; :
        &#x27;@&#x27; + self._dataTransfers[transferId].sessions[peerId].ackN) + &#x27; with size -&gt;&#x27;], rawData.size);

      self._DATAProtocolHandler(peerId, rawData, self.DATA_TRANSFER_DATA_TYPE.BLOB, rawData.size, channelProp);

    } else {
      var byteArray = rawData;
      var blob = null;

      // Plugin binary handling
      if (rawData.constructor &amp;&amp; rawData.constructor.name === &#x27;Array&#x27;) {
        // Need to re-parse on some browsers
        byteArray = new Int8Array(rawData);
      }

      // Fallback for older IE versions
      if (AdapterJS.webrtcDetectedBrowser === &#x27;IE&#x27;) {
        if (window.BlobBuilder) {
          var bb = new BlobBuilder();
          bb.append(rawData.constructor &amp;&amp; rawData.constructor.name === &#x27;ArrayBuffer&#x27; ?
            byteArray : (new Uint8Array(byteArray)).buffer);
          blob = bb.getBlob();
        }
      } else {
        blob = new Blob([byteArray]);
      }

      log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Received arraybuffer data chunk &#x27; + (isStreamChunk ? &#x27;&#x27; :
        &#x27;@&#x27; + self._dataTransfers[transferId].sessions[peerId].ackN) + &#x27; with size -&gt;&#x27;], blob.size);

      self._DATAProtocolHandler(peerId, blob, self.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER, blob.size, channelProp);
    }
  }
};

/**
 * Function that handles the &quot;WRQ&quot; data transfer protocol.
 * @method _WRQProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._WRQProtocolHandler = function(peerId, data, channelProp) {
  var self = this;
  var transferId = channelProp === &#x27;main&#x27; ? data.transferId || null : channelProp;
  var senderPeerId = data.sender || peerId;

  if ([&#x27;fastBinaryStart&#x27;, &#x27;fastBinaryStop&#x27;].indexOf(data.dataType) &gt; -1) {
    if (data.dataType === &#x27;fastBinaryStart&#x27;) {
      if (!transferId) {
        transferId = &#x27;stream_&#x27; + peerId + &#x27;_&#x27; + (new Date()).getTime();
      }
      self._dataStreams[transferId] = {
        chunkSize: 0,
        chunkType: data.chunkType === &#x27;string&#x27; ? self.DATA_TRANSFER_DATA_TYPE.STRING : self._binaryChunkType,
        sessionChunkType: data.chunkType,
        isPrivate: !!data.isPrivate,
        isStringStream: data.chunkType === &#x27;string&#x27;,
        senderPeerId: senderPeerId,
        isUpload: false
      };
      self._dataChannels[peerId][channelProp].streamId = transferId;
      var hasStarted = false;
      self.once(&#x27;dataChannelState&#x27;, function () {}, function (state, evtPeerId, channelName, channelType, error) {
        if (!self._dataStreams[transferId]) {
          return true;
        }

        if (!(evtPeerId === peerId &amp;&amp; (channelProp === &#x27;main&#x27; ? channelType === self.DATA_CHANNEL_TYPE.MESSAGING :
          channelName === transferId &amp;&amp; channelType === self.DATA_CHANNEL_TYPE.DATA))) {
          return;
        }

        if ([self.DATA_CHANNEL_STATE.ERROR, self.DATA_CHANNEL_STATE.CLOSED].indexOf(state) &gt; -1) {
          var updatedError = new Error(error &amp;&amp; error.message ? error.message :
            &#x27;Failed data transfer as datachannel state is &quot;&#x27; + state + &#x27;&quot;.&#x27;);

          self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.ERROR, transferId, senderPeerId, {
            chunk: null,
            chunkSize: 0,
            chunkType: self._dataStreams[transferId].chunkType,
            isPrivate: self._dataStreams[transferId].isPrivate,
            isStringStream: self._dataStreams[transferId].sessionChunkType === &#x27;string&#x27;,
            senderPeerId: senderPeerId
          }, updatedError);
          return true;
        }
      });

      self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.RECEIVING_STARTED, transferId, senderPeerId, {
        chunk: null,
        chunkSize: 0,
        chunkType: self._dataStreams[transferId].chunkType,
        isPrivate: self._dataStreams[transferId].isPrivate,
        isStringStream: self._dataStreams[transferId].sessionChunkType === &#x27;string&#x27;,
        senderPeerId: senderPeerId
      }, null);
      self._trigger(&#x27;incomingDataStreamStarted&#x27;, transferId, senderPeerId, {
        chunkSize: 0,
        chunkType: self._dataStreams[transferId].chunkType,
        isPrivate: self._dataStreams[transferId].isPrivate,
        isStringStream: self._dataStreams[transferId].sessionChunkType === &#x27;string&#x27;,
        senderPeerId: senderPeerId
      }, false);

    } else {
      transferId = self._dataChannels[peerId][channelProp].streamId;
      if (self._dataStreams[transferId] &amp;&amp; !self._dataStreams[transferId].isUpload) {
        self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.RECEIVING_STOPPED, transferId, senderPeerId, {
          chunk: null,
          chunkSize: 0,
          chunkType: self._dataStreams[transferId].chunkType,
          isPrivate: self._dataStreams[transferId].isPrivate,
          isStringStream: self._dataStreams[transferId].sessionChunkType === &#x27;string&#x27;,
          senderPeerId: senderPeerId
        }, null);
        self._trigger(&#x27;incomingDataStreamStopped&#x27;, transferId, senderPeerId, {
          chunkSize: 0,
          chunkType: self._dataStreams[transferId].chunkType,
          isPrivate: self._dataStreams[transferId].isPrivate,
          isStringStream: self._dataStreams[transferId].sessionChunkType === &#x27;string&#x27;,
          senderPeerId: senderPeerId
        }, false);
        self._dataChannels[peerId][channelProp].streamId = null;
        if (channelProp !== &#x27;main&#x27;) {
          self._closeDataChannel(peerId, channelProp);
        }

        delete self._dataStreams[transferId];
      }
    }
  } else {
    if (!transferId) {
      transferId = &#x27;transfer_&#x27; + peerId + &#x27;_&#x27; + (new Date()).getTime();
    }

    self._dataTransfers[transferId] = {
      name: data.name || transferId,
      size: data.size || 0,
      chunkSize: data.chunkSize,
      originalSize: data.originalSize || 0,
      timeout: data.timeout || 60,
      isPrivate: !!data.isPrivate,
      senderPeerId: data.sender || peerId,
      dataType: self.DATA_TRANSFER_SESSION_TYPE.BLOB,
      mimeType: data.mimeType || null,
      chunkType: self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING,
      direction: self.DATA_TRANSFER_TYPE.DOWNLOAD,
      chunks: [],
      sessions: {},
      sessionType: data.dataType || &#x27;blob&#x27;,
      sessionChunkType: data.chunkType || &#x27;string&#x27;
    };

    if (self._dataTransfers[transferId].sessionType === &#x27;data&#x27; &amp;&amp;
      self._dataTransfers[transferId].sessionChunkType === &#x27;string&#x27;) {
      self._dataTransfers[transferId].dataType = self.DATA_TRANSFER_SESSION_TYPE.DATA_URL;
      self._dataTransfers[transferId].chunkType = self.DATA_TRANSFER_DATA_TYPE.STRING;
    } else if (self._dataTransfers[transferId].sessionType === &#x27;blob&#x27; &amp;&amp;
      self._dataTransfers[transferId].sessionChunkType === &#x27;binary&#x27;) {
      self._dataTransfers[transferId].chunkType = self._binaryChunkType;
    }

    self._dataChannels[peerId][channelProp].transferId = transferId;
    self._dataTransfers[transferId].sessions[peerId] = {
      timer: null,
      ackN: 0,
      receivedSize: 0
    };

    self._trigger(&#x27;incomingDataRequest&#x27;, transferId, senderPeerId,
      self._getTransferInfo(transferId, peerId, false, false, false), false);

    self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.UPLOAD_REQUEST, transferId, senderPeerId,
      self._getTransferInfo(transferId, peerId, true, false, false), null);
  }
};

/**
 * Function that handles the &quot;ACK&quot; data transfer protocol.
 * @method _ACKProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._ACKProtocolHandler = function(peerId, data, channelProp) {
  var self = this;

  var transferId = channelProp;
  var senderPeerId = data.sender || peerId;

  if (channelProp === &#x27;main&#x27;) {
    transferId = self._dataChannels[peerId].main.transferId;
  }

  self._handleDataTransferTimeoutForPeer(transferId, peerId, false);

  /**
   * Emit event for Peers function.
   */
  var emitEventFn = function (cb) {
    if (peerId === &#x27;MCU&#x27;) {
      if (!self._dataTransfers[transferId].peers[channelProp]) {
        log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Dropping triggering of ACK event as &#x27; +
          &#x27;Peers list does not exists&#x27;]);
        return;
      }
      for (var evtPeerId in self._dataTransfers[transferId].peers[channelProp]) {
        if (self._dataTransfers[transferId].peers[channelProp].hasOwnProperty(evtPeerId) &amp;&amp;
          self._dataTransfers[transferId].peers[channelProp][evtPeerId]) {
          cb(evtPeerId);
        }
      }
    } else {
      cb(senderPeerId);
    }
  };

  if (data.ackN &gt; -1) {
    if (data.ackN === 0) {
      emitEventFn(function (evtPeerId) {
        self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.UPLOAD_STARTED, transferId, evtPeerId,
          self._getTransferInfo(transferId, peerId, true, false, 0), null);
      });
    } else if (self._dataTransfers[transferId].enforceBSPeers.indexOf(peerId) &gt; -1 ?
      data.ackN === self._dataTransfers[transferId].enforceBSInfo.chunks.length :
      data.ackN === self._dataTransfers[transferId].chunks.length) {
      self._dataTransfers[transferId].sessions[peerId].ackN = data.ackN;

      emitEventFn(function (evtPeerId) {
        self._trigger(&#x27;incomingData&#x27;, self._getTransferData(transferId), transferId, evtPeerId,
          self._getTransferInfo(transferId, peerId, false, false, false), true);

        self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.UPLOAD_COMPLETED, transferId, evtPeerId,
          self._getTransferInfo(transferId, peerId, true, false, 100), null);
      });

      if (self._dataChannels[peerId][channelProp]) {
        self._dataChannels[peerId][channelProp].transferId = null;

        if (channelProp !== &#x27;main&#x27;) {
          self._closeDataChannel(peerId, channelProp);
        }
      }
      return;
    }

    var uploadFn = function (chunk) {
      self._sendMessageToDataChannel(peerId, chunk, channelProp, true);

      if (data.ackN &lt; self._dataTransfers[transferId].chunks.length) {
        emitEventFn(function (evtPeerId) {
          self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.UPLOADING, transferId, evtPeerId,
            self._getTransferInfo(transferId, peerId, true, false, false), null);
        });
      }

      self._handleDataTransferTimeoutForPeer(transferId, peerId, true);
    };

    self._dataTransfers[transferId].sessions[peerId].ackN = data.ackN;

    if (self._dataTransfers[transferId].enforceBSPeers.indexOf(peerId) &gt; -1) {
      self._blobToBase64(self._dataTransfers[transferId].enforceBSInfo.chunks[data.ackN], uploadFn);
    } else if (self._dataTransfers[transferId].chunkType === self.DATA_TRANSFER_DATA_TYPE.BINARY_STRING) {
      self._blobToBase64(self._dataTransfers[transferId].chunks[data.ackN], uploadFn);
    } else if (self._dataTransfers[transferId].chunkType === self.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER) {
      self._blobToArrayBuffer(self._dataTransfers[transferId].chunks[data.ackN], uploadFn);
    } else {
      uploadFn(self._dataTransfers[transferId].chunks[data.ackN]);
    }
  } else {
    self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.REJECTED, transferId, senderPeerId,
      self._getTransferInfo(transferId, peerId, true, false, false), {
      message: new Error(&#x27;Data transfer terminated as Peer has rejected data transfer request&#x27;),
      transferType: self.DATA_TRANSFER_TYPE.UPLOAD
    });
  }
};

/**
 * Function that handles the &quot;MESSAGE&quot; data transfer protocol.
 * @method _MESSAGEProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._MESSAGEProtocolHandler = function(peerId, data, channelProp) {
  var senderPeerId = data.sender || peerId;

  log.log([senderPeerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Received P2P message from peer:&#x27;], data);

  this._trigger(&#x27;incomingMessage&#x27;, {
    content: data.data,
    isPrivate: data.isPrivate,
    isDataChannel: true,
    targetPeerId: this._user.sid,
    senderPeerId: senderPeerId
  }, senderPeerId, this.getPeerInfo(senderPeerId), false);
};

/**
 * Function that handles the &quot;ERROR&quot; data transfer protocol.
 * @method _ERRORProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._ERRORProtocolHandler = function(peerId, data, channelProp) {
  var self = this;

  var transferId = channelProp;
  var senderPeerId = data.sender || peerId;

  if (channelProp === &#x27;main&#x27;) {
    transferId = self._dataChannels[peerId].main.transferId;
  }

  self._handleDataTransferTimeoutForPeer(transferId, peerId, false);

  /**
   * Emit event for Peers function.
   */
  var emitEventFn = function (cb) {
    if (peerId === &#x27;MCU&#x27;) {
      if (!self._dataTransfers[transferId].peers[channelProp]) {
        log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Dropping triggering of ERROR event as &#x27; +
          &#x27;Peers list does not exists&#x27;]);
        return;
      }
      for (var evtPeerId in self._dataTransfers[transferId].peers[channelProp]) {
        if (self._dataTransfers[transferId].peers[channelProp].hasOwnProperty(evtPeerId) &amp;&amp;
          self._dataTransfers[transferId].peers[channelProp][evtPeerId]) {
          cb(evtPeerId);
        }
      }
    } else {
      cb(senderPeerId);
    }
  };

  log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Received an error from peer -&gt;&#x27;], data);

  emitEventFn(function (evtPeerId) {
    self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.ERROR, transferId, evtPeerId,
      self._getTransferInfo(transferId, peerID, true, false, false), {
      message: new Error(data.content),
      transferType: self._dataTransfers[transferId].direction
    });
  });
};

/**
 * Function that handles the &quot;CANCEL&quot; data transfer protocol.
 * @method _CANCELProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.0
 */
Skylink.prototype._CANCELProtocolHandler = function(peerId, data, channelProp) {
  var self = this;
  var transferId = channelProp;

  if (channelProp === &#x27;main&#x27;) {
    transferId = self._dataChannels[peerId].main.transferId;
  }

  self._handleDataTransferTimeoutForPeer(transferId, peerId, false);

  /**
   * Emit event for Peers function.
   */
  var emitEventFn = function (cb) {
    if (peerId === &#x27;MCU&#x27;) {
      if (!self._dataTransfers[transferId].peers[channelProp]) {
        log.warn([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Dropping triggering of CANCEL event as &#x27; +
          &#x27;Peers list does not exists&#x27;]);
        return;
      }
      for (var evtPeerId in self._dataTransfers[transferId].peers[channelProp]) {
        if (self._dataTransfers[transferId].peers[channelProp].hasOwnProperty(evtPeerId) &amp;&amp;
          self._dataTransfers[transferId].peers[channelProp][evtPeerId]) {
          cb(evtPeerId);
        }
      }
    } else {
      cb(peerId);
    }
  };

  log.error([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Received data transfer termination from peer -&gt;&#x27;], data);

  emitEventFn(function (evtPeerId) {
    self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.CANCEL, transferId, evtPeerId,
      self._getTransferInfo(transferId, peerId, true, false, false), {
      message: new Error(data.content || &#x27;Peer has terminated data transfer.&#x27;),
      transferType: self._dataTransfers[transferId].direction
    });
  });
};

/**
 * Function that handles the data transfer chunk received.
 * @method _DATAProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype._DATAProtocolHandler = function(peerId, chunk, chunkType, chunkSize, channelProp) {
  var self = this;
  var transferId = channelProp;
  var senderPeerId = peerId;

  if (!(self._dataChannels[peerId] &amp;&amp; self._dataChannels[peerId][channelProp])) {
    return;
  }

  var streamId = self._dataChannels[peerId][channelProp].streamId;

  if (streamId &amp;&amp; self._dataStreams[streamId] &amp;&amp; ((typeof chunk === &#x27;string&#x27; &amp;&amp;
    self._dataStreams[streamId].sessionChunkType === &#x27;string&#x27;) || (chunk instanceof Blob &amp;&amp;
    self._dataStreams[streamId].sessionChunkType === &#x27;binary&#x27;))) {
    senderPeerId = self._dataStreams[streamId].senderPeerId || peerId;
    self._trigger(&#x27;dataStreamState&#x27;, self.DATA_STREAM_STATE.RECEIVED, streamId, senderPeerId, {
      chunk: chunk,
      chunkSize: chunkSize,
      chunkType: chunkType,
      isPrivate: self._dataStreams[streamId].sessionChunkType.isPrivate,
      isStringStream: self._dataStreams[streamId].sessionChunkType === &#x27;string&#x27;,
      senderPeerId: senderPeerId
    }, null);
    self._trigger(&#x27;incomingDataStream&#x27;, chunk, transferId, senderPeerId, {
      chunkSize: chunkSize,
      chunkType: chunkType,
      isPrivate: self._dataStreams[streamId].sessionChunkType.isPrivate,
      isStringStream: self._dataStreams[streamId].sessionChunkType === &#x27;string&#x27;,
      senderPeerId: senderPeerId
    }, false);
    return;
  }

  if (channelProp === &#x27;main&#x27;) {
    transferId = self._dataChannels[peerId].main.transferId;
  }

  if (self._dataTransfers[transferId].senderPeerId) {
    senderPeerId = self._dataTransfers[transferId].senderPeerId;
  }

  self._handleDataTransferTimeoutForPeer(transferId, peerId, false);

  self._dataTransfers[transferId].chunkType = chunkType;
  self._dataTransfers[transferId].sessions[peerId].receivedSize += chunkSize;
  self._dataTransfers[transferId].chunks[self._dataTransfers[transferId].sessions[peerId].ackN] = chunk;

  if (self._dataTransfers[transferId].sessions[peerId].receivedSize &gt;= self._dataTransfers[transferId].size) {
    log.log([peerId, &#x27;RTCDataChannel&#x27;, channelProp, &#x27;Data transfer has been completed. Computed size -&gt;&#x27;],
      self._dataTransfers[transferId].sessions[peerId].receivedSize);

    // Send last ACK to Peer to indicate completion of data transfers
    self._sendMessageToDataChannel(peerId, {
      type: self._DC_PROTOCOL_TYPE.ACK,
      sender: self._user.sid,
      ackN: self._dataTransfers[transferId].sessions[peerId].ackN + 1
    }, channelProp);

    self._trigger(&#x27;incomingData&#x27;, self._getTransferData(transferId), transferId, senderPeerId,
      self._getTransferInfo(transferId, peerId, false, false, false), null);

    self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.DOWNLOAD_COMPLETED, transferId, senderPeerId,
      self._getTransferInfo(transferId, peerId, true, false, false), null);
    return;
  }

  self._dataTransfers[transferId].sessions[peerId].ackN += 1;

  self._sendMessageToDataChannel(peerId, {
    type: self._DC_PROTOCOL_TYPE.ACK,
    sender: self._user.sid,
    ackN: self._dataTransfers[transferId].sessions[peerId].ackN
  }, channelProp);

  self._handleDataTransferTimeoutForPeer(transferId, peerId, true);

  self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.DOWNLOADING, transferId, senderPeerId,
    self._getTransferInfo(transferId, peerId, true, false, false), null);
};
    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
