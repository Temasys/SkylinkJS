<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>SkylinkJS 0.6.14</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- font and icon -->
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <!-- styling -->
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap-theme.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- scripts -->
    <script src="../assets/vendor/js/jquery.min.js"></script>
    <script src="../assets/vendor/js/bootstrap.min.js"></script>
    <script src="../assets/js/script.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" />JS<small>Version: 0.6.14</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Getting Started Examples <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="https://temasys.com.sg/getting-started-with-webrtc-and-skylinkjs/">Setting up a Video Call</a></li>
      <li><a href="https://temasys.com.sg/screensharing-with-skylinkjs/">Setting up Screensharing</a></li>
      <li><a href="https://temasys.com.sg/building-a-simple-peer-to-peer-webrtc-chat/">Setting up a Chatroom</a></li>
    </ul>
  </li>
  
    <li><a href="../classes/Skylink.html">Documentation</a></li>
  
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
    </ul>
  </li>-->
  <li><a class="btn btn-info btn-navbar" href="http://developer.temasys.com.sg/">Developer Console</a></li>
  <li><a class="btn btn-info btn-navbar" href="http://support.temasys.com.sg/">Support</a></li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
          
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content content-main">
                      <h1 class="file-heading">File: source/data-transfer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this is used only for SDK developer purposes.&lt;br&gt;
 *   Current version: &lt;code&gt;0.1.0&lt;/code&gt;
 * &lt;/blockquote&gt;
 * The value of the current version of the data transfer protocol.
 * @attribute DT_PROTOCOL_VERSION
 * @type String
 * @readOnly
 * @for Skylink
 * @since 0.5.10
 */
Skylink.prototype.DT_PROTOCOL_VERSION = &#x27;0.1.0&#x27;;

/**
 * The list of data transfers directions.
 * @attribute DATA_TRANSFER_TYPE
 * @param {String} UPLOAD &lt;small&gt;Value &lt;code&gt;&quot;upload&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the data transfer direction when User is uploading data to Peer.
 * @param {String} DOWNLOAD &lt;small&gt;Value &lt;code&gt;&quot;download&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the data transfer direction when User is downloading data from Peer.
 * @type JSON
 * @readOnly
 * @for Skylink
 * @since 0.1.0
 */
Skylink.prototype.DATA_TRANSFER_TYPE = {
  UPLOAD: &#x27;upload&#x27;,
  DOWNLOAD: &#x27;download&#x27;
};

/**
 * The list of data transfers session types.
 * @attribute DATA_TRANSFER_SESSION_TYPE
 * @param {String} BLOB     &lt;small&gt;Value &lt;code&gt;&quot;blob&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the session type for
 *   &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; data transfer.
 * @param {String} DATA_URL &lt;small&gt;Value &lt;code&gt;&quot;dataURL&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the session type for
 *   &lt;a href=&quot;#method_sendBlobData&quot;&gt;&lt;code&gt;method_sendBlobData()&lt;/code&gt; method&lt;/a&gt; data transfer.
 * @type JSON
 * @readOnly
 * @for Skylink
 * @since 0.1.0
 */
Skylink.prototype.DATA_TRANSFER_SESSION_TYPE = {
  BLOB: &#x27;blob&#x27;,
  DATA_URL: &#x27;dataURL&#x27;
};

/**
 * The list of data transfer states.
 * @attribute DATA_TRANSFER_STATE
 * @param {String} UPLOAD_REQUEST     &lt;small&gt;Value &lt;code&gt;&quot;request&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when receiving an upload data transfer request from Peer to User.
 *   &lt;small&gt;At this stage, the upload data transfer request from Peer may be accepted or rejected with the
 *   &lt;a href=&quot;#method_acceptDataTransfer&quot;&gt;&lt;code&gt;acceptDataTransfer()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {String} UPLOAD_STARTED     &lt;small&gt;Value &lt;code&gt;&quot;uploadStarted&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when the data transfer request has been accepted
 *   and data transfer will start uploading data to Peer.
 *   &lt;small&gt;At this stage, the data transfer may be terminated with the
 *   &lt;a href=&quot;#method_cancelDataTransfer&quot;&gt;&lt;code&gt;cancelDataTransfer()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {String} DOWNLOAD_STARTED   &lt;small&gt;Value &lt;code&gt;&quot;downloadStarted&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when the data transfer request has been accepted
 *   and data transfer will start downloading data from Peer.
 *   &lt;small&gt;At this stage, the data transfer may be terminated with the
 *   &lt;a href=&quot;#method_cancelDataTransfer&quot;&gt;&lt;code&gt;cancelDataTransfer()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {String} REJECTED           &lt;small&gt;Value &lt;code&gt;&quot;rejected&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when upload data transfer request to Peer has been rejected and terminated.
 * @param {String} UPLOADING          &lt;small&gt;Value &lt;code&gt;&quot;uploading&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when data transfer is uploading data to Peer.
 * @param {String} DOWNLOADING        &lt;small&gt;Value &lt;code&gt;&quot;downloading&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when data transfer is downloading data from Peer.
 * @param {String} UPLOAD_COMPLETED   &lt;small&gt;Value &lt;code&gt;&quot;uploadCompleted&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when data transfer has uploaded successfully to Peer.
 * @param {String} DOWNLOAD_COMPLETED &lt;small&gt;Value &lt;code&gt;&quot;downloadCompleted&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when data transfer has downloaded successfully from Peer.
 * @param {String} CANCEL             &lt;small&gt;Value &lt;code&gt;&quot;cancel&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when data transfer has been terminated from / to Peer.
 * @param {String} ERROR              &lt;small&gt;Value &lt;code&gt;&quot;error&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when data transfer has errors and has been terminated.
 * @type JSON
 * @readOnly
 * @for Skylink
 * @since 0.4.0
 */
Skylink.prototype.DATA_TRANSFER_STATE = {
  UPLOAD_REQUEST: &#x27;request&#x27;,
  UPLOAD_STARTED: &#x27;uploadStarted&#x27;,
  DOWNLOAD_STARTED: &#x27;downloadStarted&#x27;,
  REJECTED: &#x27;rejected&#x27;,
  CANCEL: &#x27;cancel&#x27;,
  ERROR: &#x27;error&#x27;,
  UPLOADING: &#x27;uploading&#x27;,
  DOWNLOADING: &#x27;downloading&#x27;,
  UPLOAD_COMPLETED: &#x27;uploadCompleted&#x27;,
  DOWNLOAD_COMPLETED: &#x27;downloadCompleted&#x27;
};

/**
 * Stores the fixed delimiter that concats the Datachannel label and actual transfer ID.
 * @attribute _TRANSFER_DELIMITER
 * @type String
 * @readOnly
 * @private
 * @for Skylink
 * @since 0.5.10
 */
Skylink.prototype._TRANSFER_DELIMITER = &#x27;_skylink__&#x27;;

/**
 * Stores the list of data transfer protocols.
 * @attribute _DC_PROTOCOL_TYPE
 * @param {String} WRQ The protocol to initiate data transfer.
 * @param {String} ACK The protocol to request for data transfer chunk.
 *   Give &lt;code&gt;-1&lt;/code&gt; to reject the request at the beginning and &lt;code&gt;0&lt;/code&gt; to accept
 *   the data transfer request.
 * @param {String} CANCEL The protocol to terminate data transfer.
 * @param {String} ERROR The protocol when data transfer has errors and has to be terminated.
 * @param {String} MESSAGE The protocol that is used to send P2P messages.
 * @type JSON
 * @readOnly
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._DC_PROTOCOL_TYPE = {
  WRQ: &#x27;WRQ&#x27;,
  ACK: &#x27;ACK&#x27;,
  ERROR: &#x27;ERROR&#x27;,
  CANCEL: &#x27;CANCEL&#x27;,
  MESSAGE: &#x27;MESSAGE&#x27;
};

/**
 * Stores the list of types of SDKs that do not support simultaneous data transfers.
 * @attribute _INTEROP_MULTI_TRANSFERS
 * @type Array
 * @readOnly
 * @private
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype._INTEROP_MULTI_TRANSFERS = [&#x27;Android&#x27;, &#x27;iOS&#x27;];

/**
 * Stores the list of uploading data transfers chunks to Peers.
 * @attribute _uploadDataTransfers
 * @param {Array} &lt;#transferId&gt; The uploading data transfer chunks.
 * @type JSON
 * @private
 * @for Skylink
 * @since 0.4.1
 */
Skylink.prototype._uploadDataTransfers = {};

/**
 * Stores the list of uploading data transfer sessions to Peers.
 * @attribute _uploadDataSessions
 * @param {JSON} &lt;#transferId&gt; The uploading data transfer session.
 * @type JSON
 * @private
 * @for Skylink
 * @since 0.4.1
 */
Skylink.prototype._uploadDataSessions = {};

/**
 * Stores the list of downloading data transfers chunks to Peers.
 * @attribute _downloadDataTransfers
 * @param {Array} &lt;#transferId&gt; The downloading data transfer chunks.
 * @type JSON
 * @private
 * @for Skylink
 * @since 0.4.1
 */
Skylink.prototype._downloadDataTransfers = {};

/**
 * Stores the list of downloading data transfer sessions to Peers.
 * @attribute _downloadDataSessions
 * @param {JSON} &lt;#transferId&gt; The downloading data transfer session.
 * @type JSON
 * @private
 * @for Skylink
 * @since 0.4.1
 */
Skylink.prototype._downloadDataSessions = {};

/**
 * Stores the list of data transfer &quot;wait-for-response&quot; timeouts.
 * @attribute _dataTransfersTimeout
 * @param {Object} &lt;#transferId&gt; The data transfer session &quot;wait-for-response&quot; timeout.
 * @type JSON
 * @private
 * @for Skylink
 * @since 0.4.1
 */
Skylink.prototype._dataTransfersTimeout = {};

/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that Android and iOS SDKs do not support simultaneous data transfers.
 * &lt;/blockquote&gt;
 * Function that starts an uploading data transfer from User to Peers.
 * @method sendBlobData
 * @param {Blob} data The Blob object.
 * @param {Number} [timeout=60] The timeout to wait for response from Peer.
 * @param {String|Array} [targetPeerId] The target Peer ID to start data transfer with.
 * - When provided as an Array, it will start uploading data transfers with all connections
 *   with all the Peer IDs provided.
 * - When not provided, it will start uploading data transfers with all the currently connected Peers in the Room.
 * @param {Function} [callback] The callback function fired when request has completed.
 *   &lt;small&gt;Function parameters signature is &lt;code&gt;function (error, success)&lt;/code&gt;&lt;/small&gt;
 *   &lt;small&gt;Function request completion is determined by the &lt;a href=&quot;#event_dataTransferState&quot;&gt;
 *   &lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggering &lt;code&gt;state&lt;/code&gt; parameter payload
 *   as &lt;code&gt;UPLOAD_COMPLETED&lt;/code&gt; for all Peers targeted for request success.&lt;/small&gt;
 * @param {JSON} callback.error The error result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are no errors in request&lt;/small&gt;
 * @param {String} callback.error.transferId &lt;blockquote class=&quot;info&quot;&gt;
 *   &lt;b&gt;Deprecation Warning!&lt;/b&gt; This property has been deprecated.
 *   Please use &lt;code&gt;callback.error.transferInfo.transferId&lt;/code&gt; instead.
 *   &lt;/blockquote&gt; The data transfer ID.
 *   &lt;small&gt;Defined only for single targeted Peer data transfer.&lt;/small&gt;
 * @param {String} callback.error.state &lt;blockquote class=&quot;info&quot;&gt;
 *   &lt;b&gt;Deprecation Warning!&lt;/b&gt; This property has been deprecated.
 *   Please use &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt;
 *   event&lt;/a&gt; instead. &lt;/blockquote&gt; The data transfer state that resulted in error.
 *   &lt;small&gt;Defined only for single targeted Peer data transfer.&lt;/small&gt; [Rel: Skylink.DATA_TRANSFER_STATE]
 * @param {String} callback.error.peerId &lt;blockquote class=&quot;info&quot;&gt;
 *   &lt;b&gt;Deprecation Warning!&lt;/b&gt; This property has been deprecated.
 *   Please use &lt;code&gt;callback.error.listOfPeers&lt;/code&gt; instead.
 *   &lt;/blockquote&gt; The targeted Peer ID for data transfer.
 *   &lt;small&gt;Defined only for single targeted Peer data transfer.&lt;/small&gt;
 * @param {Boolean} callback.error.isPrivate &lt;blockquote class=&quot;info&quot;&gt;
 *   &lt;b&gt;Deprecation Warning!&lt;/b&gt; This property has been deprecated.
 *   Please use &lt;code&gt;callback.error.transferInfo.isPrivate&lt;/code&gt; instead.
 *   &lt;/blockquote&gt; The flag if data transfer is targeted or not, basing
 *   off the &lt;code&gt;targetPeerId&lt;/code&gt; parameter being defined.
 *   &lt;small&gt;Defined only for single targeted Peer data transfer.&lt;/small&gt;
 * @param {Error|String} callback.error.error &lt;blockquote class=&quot;info&quot;&gt;
 *   &lt;b&gt;Deprecation Warning!&lt;/b&gt; This property has been deprecated.
 *   Please use &lt;code&gt;callback.error.transferErrors&lt;/code&gt; instead.
 *   &lt;/blockquote&gt; The error received that resulted in error.
 *   &lt;small&gt;Defined only for single targeted Peer data transfer.&lt;/small&gt;
 * @param {Array} callback.error.listOfPeers The list Peer IDs targeted for the data transfer.
 * @param {JSON} callback.error.transferErrors The list of data transfer errors.
 * @param {Error|String} callback.error.transferErrors.#peerId The data transfer error associated
 *   with the Peer ID defined in &lt;code&gt;#peerId&lt;/code&gt; property.
 *   &lt;small&gt;If &lt;code&gt;#peerId&lt;/code&gt; value is &lt;code&gt;&quot;self&quot;&lt;/code&gt;, it means that it is the error when there
 *   are no Peer connections to start data transfer with.&lt;/small&gt;
 * @param {JSON} callback.error.transferInfo The data transfer information.
 *   &lt;small&gt;Object signature matches the &lt;code&gt;transferInfo&lt;/code&gt; parameter payload received in the
 *   &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;.&lt;/small&gt;
 * @param {JSON} callback.success The success result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are errors in request&lt;/small&gt;
 * @param {String} callback.success.transferId &lt;blockquote class=&quot;info&quot;&gt;
 *   &lt;b&gt;Deprecation Warning!&lt;/b&gt; This property has been deprecated.
 *   Please use &lt;code&gt;callback.success.transferInfo.transferId&lt;/code&gt; instead.
 *   &lt;/blockquote&gt; The data transfer ID.
 * @param {String} callback.success.state &lt;blockquote class=&quot;info&quot;&gt;
 *   &lt;b&gt;Deprecation Warning!&lt;/b&gt; This property has been deprecated.
 *   Please use &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt;
 *   event&lt;/a&gt; instead. &lt;/blockquote&gt; The data transfer state that resulted in error.
 *   &lt;small&gt;Defined only for single targeted Peer data transfer.&lt;/small&gt; [Rel: Skylink.DATA_TRANSFER_STATE]
 * @param {String} callback.success.peerId &lt;blockquote class=&quot;info&quot;&gt;
 *   &lt;b&gt;Deprecation Warning!&lt;/b&gt; This property has been deprecated.
 *   Please use &lt;code&gt;callback.success.listOfPeers&lt;/code&gt; instead.
 *   &lt;/blockquote&gt; The targeted Peer ID for data transfer.
 *   &lt;small&gt;Defined only for single targeted Peer data transfer.&lt;/small&gt;
 * @param {Boolean} callback.success.isPrivate &lt;blockquote class=&quot;info&quot;&gt;
 *   &lt;b&gt;Deprecation Warning!&lt;/b&gt; This property has been deprecated.
 *   Please use &lt;code&gt;callback.success.transferInfo.isPrivate&lt;/code&gt; instead.
 *   &lt;/blockquote&gt; The flag if data transfer is targeted or not, basing
 *   off the &lt;code&gt;targetPeerId&lt;/code&gt; parameter being defined.
 *   &lt;small&gt;Defined only for single targeted Peer data transfer.&lt;/small&gt;
 * @param {Array} callback.success.listOfPeers The list Peer IDs targeted for the data transfer.
 * @param {JSON} callback.success.transferInfo The data transfer information.
 *   &lt;small&gt;Object signature matches the &lt;code&gt;transferInfo&lt;/code&gt; parameter payload received in the
 *   &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt;.&lt;/small&gt;
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *   &lt;li&gt;When Peer supports simultaneous data transfers, &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;CONNECTING&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;DATA&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;DATA&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;
 *   &lt;small&gt;For Peers that do not support simultaneous data transfers, the
 *   &lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt; must trigger parameter payload
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt; and &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;MESSAGING&lt;/code&gt;.&lt;/small&gt;&lt;/li&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_incomingDataRequest&quot;&gt;&lt;code&gt;incomingDataRequest&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;isSelf&lt;/code&gt; value as &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;When Peers accepts the uploading data transfer request from User &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;UPLOAD_STARTED&lt;/code&gt;.
 *   &lt;small&gt;For Peers, the parameter payload &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;DOWNLOAD_STARTED&lt;/code&gt;.&lt;/small&gt;&lt;/li&gt;
 *   &lt;li&gt;When data transfer is still uploading, &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt;
 *   event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;UPLOADING&lt;/code&gt;.
 *   &lt;small&gt;For Peers, the parameter payload &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;DOWNLOADING&lt;/code&gt;.&lt;/small&gt;&lt;/li&gt;
 *   &lt;li&gt;When response has timed out from Peer (based on the &lt;code&gt;timeout&lt;/code&gt; parameter configured in the method),
 *   &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt; and data transfer has been terminated.&lt;/li&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt;
 *   event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;UPLOAD_COMPLETED&lt;/code&gt;.
 *   &lt;small&gt;For Peers, the parameter payload &lt;code&gt;state&lt;/code&gt; is &lt;code&gt;DOWNLOAD_COMPLETED&lt;/code&gt;.
 *   &lt;/small&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;When Peers rejects the uploading data transfer request from User &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;REJECTED&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
 * @example
 * &amp;lt;body&amp;gt;
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(0)&quot;&amp;gt; 1s timeout (Default)
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(120)&quot;&amp;gt; 2s timeout
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(300)&quot;&amp;gt; 5s timeout
 *  &amp;lt;hr&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;uploadFile(this.Files[0], this.getAttribute(&#x27;data&#x27;))&quot; data=&quot;peerId&quot;&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;uploadFileGroup(this.Files[0], this.getAttribute(&#x27;data&#x27;).split(&#x27;,&#x27;)))&quot; data=&quot;peerIdA,peerIdB&quot;&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;uploadFileAll(this.Files[0])&quot; data=&quot;&quot;&amp;gt;
 *  &amp;lt;script&amp;gt;
 *    var transferTimeout = 0;
 *
 *    function setTransferTimeout (timeout) {
 *      transferTimeout = timeout;
 *    }
 *
 *    // Example 1: Upload data to a Peer
 *    function uploadFile (file, peerId) {
 *      var cb = function (error, success) {
 *        if (error) return;
 *        console.info(&quot;File has been transferred to &#x27;&quot; + peerId + &quot;&#x27; successfully&quot;);
 *      };
 *      if (transferTimeout &gt; 0) {
 *        skylinkDemo.sendBlobData(file, peerId, transferTimeout, cb);
 *      } else {
 *        skylinkDemo.sendBlobData(file, peerId, cb);
 *      }
 *    }
 *
 *    // Example 2: Upload data to a list of Peers
 *    function uploadFileGroup (file, peerIds) {
 *      var cb = function (error, success) {
 *        var listOfPeers = error ? error.listOfPeers : success.listOfPeers;
 *        var listOfPeersErrors = error ? error.transferErrors : {};
 *        for (var i = 0; i &lt; listOfPeers.length; i++) {
 *          if (listOfPeersErrors[listOfPeers[i]]) {
 *            console.error(&quot;Failed file transfer to &#x27;&quot; + listOfPeers[i] + &quot;&#x27;&quot;);
 *          } else {
 *            console.info(&quot;File has been transferred to &#x27;&quot; + listOfPeers[i] + &quot;&#x27; successfully&quot;);
 *          }
 *        }
 *      };
 *      if (transferTimeout &gt; 0) {
 *        skylinkDemo.sendBlobData(file, peerIds, transferTimeout, cb);
 *      } else {
 *        skylinkDemo.sendBlobData(file, peerIds, cb);
 *      }
 *    }
 *
 *    // Example 2: Upload data to a list of Peers
 *    function uploadFileAll (file) {
 *      var cb = function (error, success) {
 *        var listOfPeers = error ? error.listOfPeers : success.listOfPeers;
 *        var listOfPeersErrors = error ? error.transferErrors : {};
 *        for (var i = 0; i &lt; listOfPeers.length; i++) {
 *          if (listOfPeersErrors[listOfPeers[i]]) {
 *            console.error(&quot;Failed file transfer to &#x27;&quot; + listOfPeers[i] + &quot;&#x27;&quot;);
 *          } else {
 *            console.info(&quot;File has been transferred to &#x27;&quot; + listOfPeers[i] + &quot;&#x27; successfully&quot;);
 *          }
 *        }
 *      };
 *      if (transferTimeout &gt; 0) {
 *        skylinkDemo.sendBlobData(file, transferTimeout, cb);
 *      } else {
 *        skylinkDemo.sendBlobData(file, cb);
 *      }
 *    }
 * &amp;lt;/script&amp;gt;
 * &amp;lt;/body&amp;gt;
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype.sendBlobData = function(data, timeout, targetPeerId, callback) {
  var listOfPeers = Object.keys(this._peerConnections);
  var isPrivate = false;
  var dataInfo = {};
  var transferId = this._user.sid + this.DATA_TRANSFER_TYPE.UPLOAD +
    (((new Date()).toISOString().replace(/-/g, &#x27;&#x27;).replace(/:/g, &#x27;&#x27;))).replace(&#x27;.&#x27;, &#x27;&#x27;);
  // for error case
  var errorMsg, errorPayload, i, peerId; // for jshint
  var singleError = null;
  var transferErrors = {};
  var stateError = null;
  var singlePeerId = null;

  //Shift parameters
  // timeout
  if (typeof timeout === &#x27;function&#x27;) {
    callback = timeout;

  } else if (typeof timeout === &#x27;string&#x27;) {
    listOfPeers = [timeout];
    isPrivate = true;

  } else if (Array.isArray(timeout)) {
    listOfPeers = timeout;
    isPrivate = true;
  }

  // targetPeerId
  if (typeof targetPeerId === &#x27;function&#x27;){
    callback = targetPeerId;

  // data, timeout, target [array], callback
  } else if(Array.isArray(targetPeerId)) {
    listOfPeers = targetPeerId;
    isPrivate = true;

  // data, timeout, target [string], callback
  } else if (typeof targetPeerId === &#x27;string&#x27;) {
    listOfPeers = [targetPeerId];
    isPrivate = true;
  }

  //state: String, Deprecated. But for consistency purposes. Null if not a single peer
  //error: Object, Deprecated. But for consistency purposes. Null if not a single peer
  //transferId: String,
  //peerId: String, Deprecated. But for consistency purposes. Null if not a single peer
  //listOfPeers: Array, NEW!!
  //isPrivate: isPrivate, NEW!!
  //transferErrors: JSON, NEW!! - Array of errors
  //transferInfo: JSON The same payload as dataTransferState transferInfo payload

  // check if it&#x27;s blob data
  if (!(typeof data === &#x27;object&#x27; &amp;&amp; data instanceof Blob)) {
    errorMsg = &#x27;Provided data is not a Blob data&#x27;;

    if (listOfPeers.length === 0) {
      transferErrors.self = errorMsg;

    } else {
      for (i = 0; i &lt; listOfPeers.length; i++) {
        peerId = listOfPeers[i];
        transferErrors[peerId] = errorMsg;
      }

      // Deprecated but for consistency purposes. Null if not a single peer.
      if (listOfPeers.length === 1 &amp;&amp; isPrivate) {
        stateError = self.DATA_TRANSFER_STATE.ERROR;
        singleError = errorMsg;
        singlePeerId = listOfPeers[0];
      }
    }

    errorPayload = {
      state: stateError,
      error: singleError,
      transferId: transferId,
      peerId: singlePeerId,
      listOfPeers: listOfPeers,
      transferErrors: transferErrors,
      transferInfo: dataInfo,
      isPrivate: isPrivate
    };

    log.error(errorMsg, errorPayload);

    if (typeof callback === &#x27;function&#x27;){
      log.log([null, &#x27;RTCDataChannel&#x27;, null, &#x27;Error occurred. Firing callback &#x27; +
        &#x27;with error -&gt; &#x27;],errorPayload);
      callback(errorPayload, null);
    }
    return;
  }

  // populate data
  dataInfo.name = data.name || transferId;
  dataInfo.size = data.size;
  dataInfo.timeout = typeof timeout === &#x27;number&#x27; ? timeout : 60;
  dataInfo.transferId = transferId;
  dataInfo.dataType = &#x27;blob&#x27;;
  dataInfo.isPrivate = isPrivate;

  // check if datachannel is enabled first or not
  if (!this._enableDataChannel) {
    errorMsg = &#x27;Unable to send any blob data. Datachannel is disabled&#x27;;

    if (listOfPeers.length === 0) {
      transferErrors.self = errorMsg;

    } else {
      for (i = 0; i &lt; listOfPeers.length; i++) {
        peerId = listOfPeers[i];
        transferErrors[peerId] = errorMsg;
      }

      // Deprecated but for consistency purposes. Null if not a single peer.
      if (listOfPeers.length === 1 &amp;&amp; isPrivate) {
        stateError = self.DATA_TRANSFER_STATE.ERROR;
        singleError = errorMsg;
        singlePeerId = listOfPeers[0];
      }
    }

    errorPayload = {
      state: stateError,
      error: singleError,
      transferId: transferId,
      peerId: singlePeerId,
      listOfPeers: listOfPeers,
      transferErrors: transferErrors,
      transferInfo: dataInfo,
      isPrivate: isPrivate
    };

    log.error(errorMsg, errorPayload);

    if (typeof callback === &#x27;function&#x27;){
      log.log([null, &#x27;RTCDataChannel&#x27;, null, &#x27;Error occurred. Firing callback &#x27; +
        &#x27;with error -&gt; &#x27;], errorPayload);
      callback(errorPayload, null);
    }
    return;
  }

  this._startDataTransfer(data, dataInfo, listOfPeers, callback);
};

/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   &lt;b&gt;Deprecation Warning!&lt;/b&gt; This method has been deprecated, please use &lt;a href=&quot;#method_acceptDataTransfer&quot;&gt;
 *   &lt;code&gt;acceptDataTransfer()&lt;/code&gt; method&lt;/a&gt; instead.
 * &lt;/blockquote&gt;
 * Function that accepts or rejects an upload data transfer request from Peer to User.
 * &lt;small&gt;Parameter signature follows &lt;a href=&quot;#method_acceptDataTransfer&quot;&gt;
 * &lt;code&gt;acceptDataTransfer()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @method respondBlobRequest
 * @example
 *   // Example 1: Accept Peer upload data transfer request
 *   skylinkDemo.on(&quot;incomingDataRequest&quot;, function (transferId, peerId, transferInfo, isSelf) {
 *      if (!isSelf) {
 *        skylinkDemo.respondBlobRequest(peerId, transferId, true);
 *      }
 *   });
 *
 *   // Example 2: Reject Peer upload data transfer request
 *   skylinkDemo.on(&quot;incomingDataRequest&quot;, function (transferId, peerId, transferInfo, isSelf) {
 *      if (!isSelf) {
 *        skylinkDemo.respondBlobRequest(peerId, transferId, false);
 *      }
 *   });
 * @deprecated true
 * @trigger &lt;small&gt;Event sequence follows &lt;a href=&quot;#method_acceptDataTransfer&quot;&gt;
 * &lt;code&gt;acceptDataTransfer()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @for Skylink
 * @since 0.5.0
 */
Skylink.prototype.respondBlobRequest =
/**
 * Function that accepts or rejects an upload data transfer request from Peer to User.
 * @method acceptDataTransfer
 * @param {String} peerId The Peer ID.
 * @param {String} transferId The data transfer ID.
 * @param {Boolean} [accept=false] The flag if User accepts the upload data transfer request from Peer.
 * @example
 *   // Example 1: Accept Peer upload data transfer request
 *   skylinkDemo.on(&quot;incomingDataRequest&quot;, function (transferId, peerId, transferInfo, isSelf) {
 *      if (!isSelf) {
 *        skylinkDemo.acceptDataTransfer(peerId, transferId, true);
 *      }
 *   });
 *
 *   // Example 2: Reject Peer upload data transfer request
 *   skylinkDemo.on(&quot;incomingDataRequest&quot;, function (transferId, peerId, transferInfo, isSelf) {
 *      if (!isSelf) {
 *        skylinkDemo.acceptDataTransfer(peerId, transferId, false);
 *      }
 *   });
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *   &lt;li&gt;When User accepts the uploading data transfer request from Peer,
 *   &lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;DOWNLOAD_STARTED&lt;/code&gt;.
 *   &lt;li&gt;When User rejects the uploading data transfer request from Peer,
 *   &lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;REJECTED&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype.acceptDataTransfer = function (peerId, transferId, accept) {
  if (typeof transferId !== &#x27;string&#x27; &amp;&amp; typeof peerId !== &#x27;string&#x27;) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, null, &#x27;Aborting accept data transfer as &#x27; +
      &#x27;transfer ID and peer ID is not provided&#x27;], {
        accept: accept,
        peerId: peerId,
        transferId: transferId
    });
    return;
  }

  if (transferId.indexOf(this._TRANSFER_DELIMITER) === -1) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, null, &#x27;Aborting accept data transfer as &#x27; +
      &#x27;invalid transfer ID is provided&#x27;], {
        accept: accept,
        transferId: transferId
    });
    return;
  }
  var channelName = transferId.split(this._TRANSFER_DELIMITER)[0];

  if (accept) {

    log.info([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;User accepted peer\&#x27;s request&#x27;], {
      accept: accept,
      transferId: transferId
    });

    if (!this._peerInformations[peerId] &amp;&amp; !this._peerInformations[peerId].agent) {
      log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Aborting accept data transfer as &#x27; +
        &#x27;Peer informations for peer is missing&#x27;], {
          accept: accept,
          transferId: transferId
      });
      return;
    }

    this._downloadDataTransfers[channelName] = [];

    var data = this._downloadDataSessions[channelName];
    this._sendDataChannelMessage(peerId, {
      type: this._DC_PROTOCOL_TYPE.ACK,
      sender: this._user.sid,
      ackN: 0,
      agent: window.webrtcDetectedBrowser
    }, channelName);
    this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.DOWNLOAD_STARTED,
      data.transferId, peerId, {
        name: data.name,
        size: data.size,
        data: null,
        dataType: data.dataType,
        percentage: 0,
        senderPeerId: peerId,
        timeout: data.timeout,
        isPrivate: data.isPrivate
    });
  } else {
    log.info([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;User rejected peer\&#x27;s request&#x27;], {
      accept: accept,
      transferId: transferId
    });
    this._sendDataChannelMessage(peerId, {
      type: this._DC_PROTOCOL_TYPE.ACK,
      sender: this._user.sid,
      ackN: -1
    }, channelName);
    delete this._downloadDataSessions[channelName];
    delete this._downloadDataTransfers[channelName];
  }
};

/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   &lt;b&gt;Deprecation Warning!&lt;/b&gt; This method has been deprecated, please use &lt;a href=&quot;#method_cancelDataTransfer&quot;&gt;
 *   &lt;code&gt;method_cancelDataTransfer()&lt;/code&gt; method&lt;/a&gt; instead.
 * &lt;/blockquote&gt;
 * Function that terminates a currently uploading / downloading data transfer from / to Peer.
 * &lt;small&gt;Parameter signature follows &lt;a href=&quot;#method_cancelDataTransfer&quot;&gt;
 * &lt;code&gt;cancelDataTransfer()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @method cancelBlobTransfer
 * @trigger &lt;small&gt;Event sequence follows &lt;a href=&quot;#method_acceptDataTransfer&quot;&gt;
 * @example
 *   // Example 1: Cancel Peer data transfer
 *   var transferSessions = {};
 *
 *   skylinkDemo.on(&quot;dataTransferState&quot;, function (state, transferId, peerId) {
 *     if ([skylinkDemo.DATA_TRANSFER_STATE.DOWNLOAD_STARTED,
 *       skylinkDemo.DATA_TRANSFER_STATE.UPLOAD_STARTED].indexOf(state) &gt; -1) {
 *       if (!Array.isArray(transferSessions[transferId])) {
 *         transferSessions[transferId] = [];
 *       }
 *       transferSessions[transferId].push(peerId);
 *     } else {
 *       transferSessions[transferId].splice(transferSessions[transferId].indexOf(peerId), 1);
 *     }
 *   });
 *
 *   function cancelTransfer (peerId, transferId) {
 *     skylinkDemo.cancelBlobTransfer(peerId, transferId);
 *   }
 * @trigger &lt;small&gt;Event sequence follows &lt;a href=&quot;#method_cancelDataTransfer&quot;&gt;
 * &lt;code&gt;cancelDataTransfer()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @for Skylink
 * @deprecated true
 * @for Skylink
 * @since 0.5.7
 */
Skylink.prototype.cancelBlobTransfer =
/**
 * Function that terminates a currently uploading / downloading data transfer from / to Peer.
 * @method cancelDataTransfer
 * @param {String} peerId The Peer ID.
 * @param {String} transferId The data transfer ID.
 * @example
 *   // Example 1: Cancel Peer data transfer
 *   var transferSessions = {};
 *
 *   skylinkDemo.on(&quot;dataTransferState&quot;, function (state, transferId, peerId) {
 *     if ([skylinkDemo.DATA_TRANSFER_STATE.DOWNLOAD_STARTED,
 *       skylinkDemo.DATA_TRANSFER_STATE.UPLOAD_STARTED].indexOf(state) &gt; -1) {
 *       if (!Array.isArray(transferSessions[transferId])) {
 *         transferSessions[transferId] = [];
 *       }
 *       transferSessions[transferId].push(peerId);
 *     } else {
 *       transferSessions[transferId].splice(transferSessions[transferId].indexOf(peerId), 1);
 *     }
 *   });
 *
 *   function cancelTransfer (peerId, transferId) {
 *     skylinkDemo.cancelDataTransfer(peerId, transferId);
 *   }
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *  &lt;li&gt;&lt;a href=&quot;#event_dataTransferState&quot;&gt;&lt;code&gt;dataTransferState&lt;/code&gt; event&lt;/a&gt; triggers
 *  parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;CANCEL&lt;/code&gt;.&lt;/li&gt;
 *  &lt;/ol&gt;
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype.cancelDataTransfer = function (peerId, transferId) {
  var data;

  // targetPeerId + &#x27;-&#x27; + transferId
  var channelName = peerId + &#x27;-&#x27; + transferId;

  if (transferId.indexOf(this._TRANSFER_DELIMITER) &gt; 0) {
    channelName = transferId.split(this._TRANSFER_DELIMITER)[0];
  } else {

    var peerAgent = (this._peerInformations[peerId] || {}).agent;

    if (!peerAgent &amp;&amp; !peerAgent.name) {
      log.error([peerId, &#x27;RTCDataChannel&#x27;, null, &#x27;Cancel transfer to peer &#x27; +
        &#x27;failed as peer agent information for peer does not exists&#x27;], transferId);
      return;
    }

    if (self._INTEROP_MULTI_TRANSFERS.indexOf(peerAgent.name) &gt; -1) {
      channelName = peerId;
    }
  }

  if (this._uploadDataSessions[channelName]) {
    data = this._uploadDataSessions[channelName];

    delete this._uploadDataSessions[channelName];
    delete this._uploadDataTransfers[channelName];

    // send message
    this._sendDataChannelMessage(peerId, {
      type: this._DC_PROTOCOL_TYPE.CANCEL,
      sender: this._user.sid,
      name: data.name,
      content: &#x27;Peer cancelled upload transfer&#x27;
    }, channelName);

    log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName,
      &#x27;Cancelling upload data transfers&#x27;], transferId);

  } else if (this._downloadDataSessions[channelName]) {
    data = this._downloadDataSessions[channelName];

    delete this._downloadDataSessions[channelName];
    delete this._downloadDataTransfers[channelName];

    // send message
    this._sendDataChannelMessage(peerId, {
      type: this._DC_PROTOCOL_TYPE.CANCEL,
      sender: this._user.sid,
      name: data.name,
      content: &#x27;Peer cancelled download transfer&#x27;
    }, channelName);

    log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName,
      &#x27;Cancelling download data transfers&#x27;], transferId);

  } else {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, null, &#x27;Cancel transfer to peer &#x27; +
      &#x27;failed as transfer session with peer does not exists&#x27;], transferId);
    return;
  }

  this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.CANCEL,
    data.transferId, peerId, {
      name: data.name,
      size: data.size,
      percentage: data.percentage,
      data: null,
      dataType: data.dataType,
      senderPeerId: data.senderPeerId,
      timeout: data.timeout,
      isPrivate: data.isPrivate
  });
};

/**
 * Function that sends a message to Peers via the Datachannel connection.
 * &lt;small&gt;Consider using &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; if you are
 * sending large strings to Peers.&lt;/small&gt;
 * @method sendP2PMessage
 * @param {String|JSON} message The message.
 * @param {String|Array} [targetPeerId] The target Peer ID to send message to.
 * - When provided as an Array, it will send the message to only Peers which IDs are in the list.
 * - When not provided, it will broadcast the message to all connected Peers in the Room.
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *  &lt;li&gt;&lt;a href=&quot;#event_incomingMessage&quot;&gt;&lt;code&gt;incomingMessage&lt;/code&gt; event&lt;/a&gt; triggers
 *  parameter payload &lt;code&gt;isSelf&lt;/code&gt; value as &lt;code&gt;true&lt;/code&gt;
 *  &lt;small&gt;Note that the &lt;a href=&quot;#event_dataChannelState&quot;&gt;&lt;code&gt;dataChannelState&lt;/code&gt; event&lt;/a&gt;
 *  must trigger parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;OPEN&lt;/code&gt; and
 *  &lt;code&gt;channelType&lt;/code&gt; as &lt;code&gt;MESSAGING&lt;/code&gt; for targeted Peers or the message
 *  will not be sent.&lt;/small&gt;&lt;/li&gt;&lt;/ol&gt;
 * @example
 *   // Example 1: Sending m
 *   skylinkDemo.on(&quot;dataChannelState&quot;, function (state, peerId, error, channelName, channelType) {
 *      if (state === skylinkDemo.DATA_CHANNEL_STATE.OPEN &amp;&amp;
 *        channelType === skylinkDemo.DATA_CHANNEL_TYPE.MESSAGING) {
 *        skylinkDemo.sendP2PMessage(&quot;test&quot;, peerId);
 *      }
 *   });
 *
 *   // Example 1: Broadcasting to all Peers
 *   skylinkDemo.sendP2PMessage(&quot;Hi all!&quot;);
 *
 *   // Example 2: Sending to specific Peers
 *   var peersInExclusiveParty = [];
 *
 *   skylinkDemo.on(&quot;peerJoined&quot;, function (peerId, peerInfo, isSelf) {
 *     if (isSelf) return;
 *     if (peerInfo.userData.exclusive) {
 *       peersInExclusiveParty[peerId] = false;
 *     }
 *   });
 *
 *   skylinkDemo.on(&quot;dataChannelState&quot;, function (state, peerId, error, channelName, channelType) {
 *      if (state === skylinkDemo.DATA_CHANNEL_STATE.OPEN &amp;&amp;
 *        channelType === skylinkDemo.DATA_CHANNEL_TYPE.MESSAGING) {
 *        peersInExclusiveParty[peerId] = true;
 *      }
 *   });
 *
 *   function updateExclusivePartyStatus (message) {
 *     skylinkDemo.sendP2PMessage(message, peersInExclusiveParty);
 *   }
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype.sendP2PMessage = function(message, targetPeerId) {
  var self = this;

  // check if datachannel is enabled first or not
  if (!self._enableDataChannel) {
    log.warn(&#x27;Unable to send any P2P message. Datachannel is disabled&#x27;);
    return;
  }

  var listOfPeers = Object.keys(self._dataChannels);
  var isPrivate = false;

  //targetPeerId is defined -&gt; private message
  if (Array.isArray(targetPeerId)) {
    listOfPeers = targetPeerId;
    isPrivate = true;

  } else if (typeof targetPeerId === &#x27;string&#x27;) {
    listOfPeers = [targetPeerId];
    isPrivate = true;
  }

  // sending public message to MCU to relay. MCU case only
  if (self._hasMCU) {
    if (isPrivate) {
      log.log([&#x27;MCU&#x27;, null, null, &#x27;Relaying private P2P message to peers&#x27;], listOfPeers);
      self._sendDataChannelMessage(&#x27;MCU&#x27;, {
        type: self._DC_PROTOCOL_TYPE.MESSAGE,
        isPrivate: isPrivate,
        sender: self._user.sid,
        target: listOfPeers,
        data: message
      });
    } else {
      log.log([&#x27;MCU&#x27;, null, null, &#x27;Relaying P2P message to peers&#x27;]);

      self._sendDataChannelMessage(&#x27;MCU&#x27;, {
        type: self._DC_PROTOCOL_TYPE.MESSAGE,
        isPrivate: isPrivate,
        sender: self._user.sid,
        target: &#x27;MCU&#x27;,
        data: message
      });
    }
  } else {
    for (var i = 0; i &lt; listOfPeers.length; i++) {
      var peerId = listOfPeers[i];
      var useChannel = (self._hasMCU) ? &#x27;MCU&#x27; : peerId;

      // Ignore MCU peer
      if (peerId === &#x27;MCU&#x27;) {
        continue;
      }

      log.log([peerId, null, useChannel, &#x27;Sending P2P message to peer&#x27;]);

      self._sendDataChannelMessage(useChannel, {
        type: self._DC_PROTOCOL_TYPE.MESSAGE,
        isPrivate: isPrivate,
        sender: self._user.sid,
        target: peerId,
        data: message
      });
    }
  }

  self._trigger(&#x27;incomingMessage&#x27;, {
    content: message,
    isPrivate: isPrivate,
    targetPeerId: targetPeerId || null,
    isDataChannel: true,
    senderPeerId: self._user.sid
  }, self._user.sid, self.getPeerInfo(), true);
};

/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   Currently, the Android and iOS SDKs do not support this type of data transfer.
 * &lt;/blockquote&gt;
 * Function that starts an uploading string data transfer from User to Peers.
 * @method sendURLData
 * @param {String} data The data string to transfer to Peer.
 *   &lt;small&gt;Parameter signature follows &lt;a href=&quot;#method_sendBlobData&quot;&gt;
 *   &lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt; except &lt;code&gt;data&lt;/code&gt; parameter.&lt;/small&gt;
 * @trigger &lt;small&gt;Event sequence follows &lt;a href=&quot;#method_sendBlobData&quot;&gt;
 * &lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @example
 * &amp;lt;body&amp;gt;
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(0)&quot;&amp;gt; 1s timeout (Default)
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(120)&quot;&amp;gt; 2s timeout
 *  &amp;lt;input type=&quot;radio&quot; name=&quot;timeout&quot; onchange=&quot;setTransferTimeout(300)&quot;&amp;gt; 5s timeout
 *  &amp;lt;hr&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;showImage(this.Files[0], this.getAttribute(&#x27;data&#x27;))&quot; data=&quot;peerId&quot;&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;showImageGroup(this.Files[0], this.getAttribute(&#x27;data&#x27;).split(&#x27;,&#x27;)))&quot; data=&quot;peerIdA,peerIdB&quot;&amp;gt;
 *  &amp;lt;input type=&quot;file&quot; onchange=&quot;showImageAll(this.Files[0])&quot; data=&quot;&quot;&amp;gt;
 *  &amp;lt;image id=&quot;target-1&quot; src=&quot;&quot;&amp;gt;
 *  &amp;lt;image id=&quot;target-2&quot; src=&quot;&quot;&amp;gt;
 *  &amp;lt;image id=&quot;target-3&quot; src=&quot;&quot;&amp;gt;
 *  &amp;lt;script&amp;gt;
 *    var transferTimeout = 0;
 *
 *    function setTransferTimeout (timeout) {
 *      transferTimeout = timeout;
 *    }
 *
 *    function retrieveImageDataURL(file, cb) {
 *      var fr = new FileReader();
 *      fr.onload = function () {
 *        cb(fr.result);
 *      };
 *      fr.readAsDataURL(files[0]);
 *    }
 *
 *    // Example 1: Send image data URL to a Peer
 *    function showImage (file, peerId) {
 *      var cb = function (error, success) {
 *        if (error) return;
 *        console.info(&quot;Image has been transferred to &#x27;&quot; + peerId + &quot;&#x27; successfully&quot;);
 *      };
 *      retrieveImageDataURL(file, function (str) {
 *        if (transferTimeout &gt; 0) {
 *          skylinkDemo.sendURLData(str, peerId, transferTimeout, cb);
 *        } else {
 *          skylinkDemo.sendURLData(str, peerId, cb);
 *        }
 *        document.getElementById(&quot;target-1&quot;).src = str;
 *      });
 *    }
 *
 *    // Example 2: Send image data URL to a list of Peers
 *    function showImageGroup (file, peerIds) {
 *      var cb = function (error, success) {
 *        var listOfPeers = error ? error.listOfPeers : success.listOfPeers;
 *        var listOfPeersErrors = error ? error.transferErrors : {};
 *        for (var i = 0; i &lt; listOfPeers.length; i++) {
 *          if (listOfPeersErrors[listOfPeers[i]]) {
 *            console.error(&quot;Failed image transfer to &#x27;&quot; + listOfPeers[i] + &quot;&#x27;&quot;);
 *          } else {
 *            console.info(&quot;Image has been transferred to &#x27;&quot; + listOfPeers[i] + &quot;&#x27; successfully&quot;);
 *          }
 *        }
 *      };
 *      retrieveImageDataURL(file, function (str) {
 *        if (transferTimeout &gt; 0) {
 *          skylinkDemo.sendURLData(str, peerIds, transferTimeout, cb);
 *        } else {
 *          skylinkDemo.sendURLData(str, peerIds, cb);
 *        }
 *        document.getElementById(&quot;target-2&quot;).src = str;
 *      });
 *    }
 *
 *    // Example 2: Send image data URL to a list of Peers
 *    function uploadFileAll (file) {
 *      var cb = function (error, success) {
 *        var listOfPeers = error ? error.listOfPeers : success.listOfPeers;
 *        var listOfPeersErrors = error ? error.transferErrors : {};
 *        for (var i = 0; i &lt; listOfPeers.length; i++) {
 *          if (listOfPeersErrors[listOfPeers[i]]) {
 *            console.error(&quot;Failed image transfer to &#x27;&quot; + listOfPeers[i] + &quot;&#x27;&quot;);
 *          } else {
 *            console.info(&quot;Image has been transferred to &#x27;&quot; + listOfPeers[i] + &quot;&#x27; successfully&quot;);
 *          }
 *        }
 *      };
 *      retrieveImageDataURL(file, function (str) {
 *        if (transferTimeout &gt; 0) {
 *          skylinkDemo.sendURLData(str, transferTimeout, cb);
 *        } else {
 *          skylinkDemo.sendURLData(str, cb);
 *        }
 *        document.getElementById(&quot;target-3&quot;).src = str;
 *      });
 *    }
 * &amp;lt;/script&amp;gt;
 * &amp;lt;/body&amp;gt;
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype.sendURLData = function(data, timeout, targetPeerId, callback) {
  var listOfPeers = Object.keys(this._peerConnections);
  var isPrivate = false;
  var dataInfo = {};
  var transferId = this._user.sid + this.DATA_TRANSFER_TYPE.UPLOAD +
    (((new Date()).toISOString().replace(/-/g, &#x27;&#x27;).replace(/:/g, &#x27;&#x27;))).replace(&#x27;.&#x27;, &#x27;&#x27;);
  // for error case
  var errorMsg, errorPayload, i, peerId; // for jshint
  var singleError = null;
  var transferErrors = {};
  var stateError = null;
  var singlePeerId = null;

  //Shift parameters
  // timeout
  if (typeof timeout === &#x27;function&#x27;) {
    callback = timeout;

  } else if (typeof timeout === &#x27;string&#x27;) {
    listOfPeers = [timeout];
    isPrivate = true;

  } else if (Array.isArray(timeout)) {
    listOfPeers = timeout;
    isPrivate = true;
  }

  // targetPeerId
  if (typeof targetPeerId === &#x27;function&#x27;){
    callback = targetPeerId;

  // data, timeout, target [array], callback
  } else if(Array.isArray(targetPeerId)) {
    listOfPeers = targetPeerId;
    isPrivate = true;

  // data, timeout, target [string], callback
  } else if (typeof targetPeerId === &#x27;string&#x27;) {
    listOfPeers = [targetPeerId];
    isPrivate = true;
  }

  //state: String, Deprecated. But for consistency purposes. Null if not a single peer
  //error: Object, Deprecated. But for consistency purposes. Null if not a single peer
  //transferId: String,
  //peerId: String, Deprecated. But for consistency purposes. Null if not a single peer
  //listOfPeers: Array, NEW!!
  //isPrivate: isPrivate, NEW!!
  //transferErrors: JSON, NEW!! - Array of errors
  //transferInfo: JSON The same payload as dataTransferState transferInfo payload

  // check if it&#x27;s blob data
  if (typeof data !== &#x27;string&#x27;) {
    errorMsg = &#x27;Provided data is not a dataURL&#x27;;

    if (listOfPeers.length === 0) {
      transferErrors.self = errorMsg;

    } else {
      for (i = 0; i &lt; listOfPeers.length; i++) {
        peerId = listOfPeers[i];
        transferErrors[peerId] = errorMsg;
      }

      // Deprecated but for consistency purposes. Null if not a single peer.
      if (listOfPeers.length === 1 &amp;&amp; isPrivate) {
        stateError = self.DATA_TRANSFER_STATE.ERROR;
        singleError = errorMsg;
        singlePeerId = listOfPeers[0];
      }
    }

    errorPayload = {
      state: stateError,
      error: singleError,
      transferId: transferId,
      peerId: singlePeerId,
      listOfPeers: listOfPeers,
      transferErrors: transferErrors,
      transferInfo: dataInfo,
      isPrivate: isPrivate
    };

    log.error(errorMsg, errorPayload);

    if (typeof callback === &#x27;function&#x27;){
      log.log([null, &#x27;RTCDataChannel&#x27;, null, &#x27;Error occurred. Firing callback &#x27; +
        &#x27;with error -&gt; &#x27;],errorPayload);
      callback(errorPayload, null);
    }
    return;
  }

  // populate data
  dataInfo.name = data.name || transferId;
  dataInfo.size = data.size || data.length;
  dataInfo.timeout = typeof timeout === &#x27;number&#x27; ? timeout : 60;
  dataInfo.transferId = transferId;
  dataInfo.dataType = &#x27;dataURL&#x27;;
  dataInfo.isPrivate = isPrivate;

  // check if datachannel is enabled first or not
  if (!this._enableDataChannel) {
    errorMsg = &#x27;Unable to send any dataURL. Datachannel is disabled&#x27;;

    if (listOfPeers.length === 0) {
      transferErrors.self = errorMsg;

    } else {
      for (i = 0; i &lt; listOfPeers.length; i++) {
        peerId = listOfPeers[i];
        transferErrors[peerId] = errorMsg;
      }

      // Deprecated but for consistency purposes. Null if not a single peer.
      if (listOfPeers.length === 1 &amp;&amp; isPrivate) {
        stateError = self.DATA_TRANSFER_STATE.ERROR;
        singleError = errorMsg;
        singlePeerId = listOfPeers[0];
      }
    }

    errorPayload = {
      state: stateError,
      error: singleError,
      transferId: transferId,
      peerId: singlePeerId,
      listOfPeers: listOfPeers,
      transferErrors: transferErrors,
      transferInfo: dataInfo,
      isPrivate: isPrivate
    };

    log.error(errorMsg, errorPayload);

    if (typeof callback === &#x27;function&#x27;){
      log.log([null, &#x27;RTCDataChannel&#x27;, null, &#x27;Error occurred. Firing callback &#x27; +
        &#x27;with error -&gt; &#x27;], errorPayload);
      callback(errorPayload, null);
    }
    return;
  }

  this._startDataTransfer(data, dataInfo, listOfPeers, callback);
};

/**
 * Function that sets the data transfer &quot;wait-for-response&quot; timeout.
 * When there is not response after timeout, the data transfer will be terminated.
 * @method _setDataChannelTimeout
 * @private
 * @for Skylink
 * @since 0.5.0
 */
Skylink.prototype._setDataChannelTimeout = function(peerId, timeout, isSender, channelName) {
  var self = this;
  if (!self._dataTransfersTimeout[channelName]) {
    self._dataTransfersTimeout[channelName] = null;
  }
  var type = (isSender) ? self.DATA_TRANSFER_TYPE.UPLOAD :
    self.DATA_TRANSFER_TYPE.DOWNLOAD;

  self._dataTransfersTimeout[channelName] = setTimeout(function() {
    var name;
    if (self._dataTransfersTimeout[channelName][type]) {
      if (isSender) {
        name = self._uploadDataSessions[channelName].name;
        delete self._uploadDataTransfers[channelName];
        delete self._uploadDataSessions[channelName];
      } else {
        name = self._downloadDataSessions[channelName].name;
        delete self._downloadDataTransfers[channelName];
        delete self._downloadDataSessions[channelName];
      }

      self._sendDataChannelMessage(peerId, {
        type: self._DC_PROTOCOL_TYPE.ERROR,
        sender: self._user.sid,
        name: name,
        content: &#x27;Connection Timeout. Longer than &#x27; + timeout +
          &#x27; seconds. Connection is abolished.&#x27;,
        isUploadError: isSender
      }, channelName);
      // TODO: Find a way to add channel name so it&#x27;s more specific
      log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Failed transfering data:&#x27;],
        &#x27;Transfer &#x27; + ((isSender) ? &#x27;for&#x27;: &#x27;from&#x27;) + &#x27; &#x27; + peerId +
        &#x27; failed. Connection timeout&#x27;);
      self._clearDataChannelTimeout(peerId, isSender, channelName);
    }
  }, 1000 * timeout);
};

/**
 * Function that stops and clears the data transfer &quot;wait-for-response&quot; timeout.
 * @method _clearDataChannelTimeout
 * @private
 * @for Skylink
 * @since 0.5.0
 */
Skylink.prototype._clearDataChannelTimeout = function(peerId, isSender, channelName) {
  if (this._dataTransfersTimeout[channelName]) {
    clearTimeout(this._dataTransfersTimeout[channelName]);
    delete this._dataTransfersTimeout[channelName];
    log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Clear datachannel timeout&#x27;]);
  } else {
    log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Unable to find timeouts. &#x27; +
      &#x27;Not clearing the datachannel timeouts&#x27;]);
  }
};

/**
 * Function that starts a data transfer to Peer.
 * This will open a new data type of Datachannel connection with Peer if
 *   simultaneous data transfers is supported by Peer.
 * @method _sendBlobDataToPeer
 * @private
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype._sendBlobDataToPeer = function(data, dataInfo, targetPeerId) {
  var self = this;
  //If there is MCU then directs all messages to MCU
  var targetChannel = targetPeerId;//(self._hasMCU) ? &#x27;MCU&#x27; : targetPeerId;
  var targetPeerList = [];

  var binarySize = parseInt((dataInfo.size * (4 / 3)).toFixed(), 10);
  var binaryChunkSize = 0;
  var chunkSize = 0;
  var i;
  var hasSend = false;

  // move list of peers to targetPeerList
  if (self._hasMCU) {
    if (Array.isArray(targetPeerList)) {
      targetPeerList = targetPeerId;
    } else {
      targetPeerList = [targetPeerId];
    }
    targetPeerId = &#x27;MCU&#x27;;
  }

  if (dataInfo.dataType !== &#x27;blob&#x27;) {
    // output: 1616
    binaryChunkSize = self._CHUNK_DATAURL_SIZE;
    chunkSize = self._CHUNK_DATAURL_SIZE;
    binarySize = dataInfo.size;
  } else if (window.webrtcDetectedBrowser === &#x27;firefox&#x27;) {
    // output: 16384
    binaryChunkSize = self._MOZ_CHUNK_FILE_SIZE * (4 / 3);
    chunkSize = self._MOZ_CHUNK_FILE_SIZE;
  } else {
    // output: 65536
    binaryChunkSize = parseInt((self._CHUNK_FILE_SIZE * (4 / 3)).toFixed(), 10);
    chunkSize = self._CHUNK_FILE_SIZE;
  }

  var throwTransferErrorFn = function (message) {
    // MCU targetPeerId case - list of peers
    if (self._hasMCU) {
      for (i = 0; i &lt; targetPeerList.length; i++) {
        var peerId = targetPeerList[i];
        self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.ERROR,
          dataInfo.transferId, peerId, {
            name: dataInfo.name,
            size: dataInfo.size,
            percentage: 0,
            data: null,
            dataType: dataInfo.dataType,
            senderPeerId: self._user.sid,
            timeout: dataInfo.timeout,
            isPrivate: dataInfo.isPrivate
          },{
            message: message,
            transferType: self.DATA_TRANSFER_TYPE.UPLOAD
        });
      }
    } else {
      self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.ERROR,
        dataInfo.transferId, targetPeerId, {
          name: dataInfo.name,
          size: dataInfo.size,
          percentage: 0,
          data: null,
          dataType: dataInfo.dataType,
          senderPeerId: self._user.sid,
          timeout: dataInfo.timeout,
          isPrivate: dataInfo.isPrivate
        },{
          message: message,
          transferType: self.DATA_TRANSFER_TYPE.UPLOAD
      });
    }
  };

  var startTransferFn = function (targetId, channel) {
    if (!hasSend) {
      hasSend = true;
      var payload = {
        type: self._DC_PROTOCOL_TYPE.WRQ,
        sender: self._user.sid,
        agent: window.webrtcDetectedBrowser,
        version: window.webrtcDetectedVersion,
        name: dataInfo.name,
        size: binarySize,
        dataType: dataInfo.dataType,
        chunkSize: binaryChunkSize,
        timeout: dataInfo.timeout,
        target: self._hasMCU ? targetPeerList : targetPeerId,
        isPrivate: dataInfo.isPrivate
      };

      if (self._hasMCU) {
        // if has MCU and is public, do not send individually
        self._sendDataChannelMessage(&#x27;MCU&#x27;, payload, channel);
        try {
          var mainChannel = self._dataChannels.MCU.main.label;
          self._setDataChannelTimeout(&#x27;MCU&#x27;, dataInfo.timeout, true, mainChannel);
        } catch (error) {
          log.error([&#x27;MCU&#x27;, &#x27;RTCDataChannel&#x27;, &#x27;MCU&#x27;, &#x27;Failed setting datachannel &#x27; +
            &#x27;timeout for MCU&#x27;], error);
        }
      } else {
        // if has MCU and is public, do not send individually
        self._sendDataChannelMessage(targetId, payload, channel);
        self._setDataChannelTimeout(targetId, dataInfo.timeout, true, channel);
      }

    }
  };

  log.log([targetPeerId, &#x27;RTCDataChannel&#x27;, targetChannel, &#x27;Chunk size of data:&#x27;], {
    chunkSize: chunkSize,
    binaryChunkSize: binaryChunkSize,
    transferId: dataInfo.transferId,
    dataType: dataInfo.dataType
  });


  var supportMulti = false;
  var peerAgent = (self._peerInformations[targetPeerId] || {}).agent || {};

  if (!peerAgent &amp;&amp; !peerAgent.name) {
    log.error([targetPeerId, &#x27;RTCDataChannel&#x27;, targetChannel, &#x27;Aborting transfer to peer &#x27; +
      &#x27;as peer agent information for peer does not exists&#x27;], dataInfo);
    throwTransferErrorFn(&#x27;Peer agent information for peer does not exists&#x27;);
    return;
  }

  if (self._INTEROP_MULTI_TRANSFERS.indexOf(peerAgent.name) === -1) {

    targetChannel = targetPeerId + &#x27;-&#x27; + dataInfo.transferId;
    supportMulti = true;

    if (!(self._dataChannels[targetPeerId] || {}).main) {
      log.error([targetPeerId, &#x27;RTCDataChannel&#x27;, targetChannel,
        &#x27;Main datachannel does not exists&#x27;], dataInfo);
      throwTransferErrorFn(&#x27;Main datachannel does not exists&#x27;);
      return;

    } else if (self._dataChannels[targetPeerId].main.readyState !==
      self.DATA_CHANNEL_STATE.OPEN) {
      log.error([targetPeerId, &#x27;RTCDataChannel&#x27;, targetChannel,
        &#x27;Main datachannel is not opened&#x27;], {
          transferId: dataInfo.transferId,
          readyState: self._dataChannels[targetPeerId].main.readyState
      });
      throwTransferErrorFn(&#x27;Main datachannel is not opened&#x27;);
      return;
    }

    self._dataChannels[targetPeerId][targetChannel] =
      self._createDataChannel(targetPeerId, self.DATA_CHANNEL_TYPE.DATA, null, targetChannel);

  } else {
    var ongoingTransfer = null;

    if (self._uploadDataSessions[targetChannel]) {
      ongoingTransfer = self.DATA_TRANSFER_TYPE.UPLOAD;
    } else if (self._downloadDataSessions[targetChannel]) {
      ongoingTransfer = self.DATA_TRANSFER_TYPE.DOWNLOAD;
    }

    if (ongoingTransfer) {
      log.error([targetPeerId, &#x27;RTCDataChannel&#x27;, targetChannel, &#x27;User have ongoing &#x27; +
        ongoingTransfer + &#x27; transfer session with peer. Unable to send data&#x27;], dataInfo);
      throwTransferErrorFn(&#x27;Another &#x27; + ongoingTransfer +
        &#x27; transfer is ongoing. Unable to send data.&#x27;);
      return;
    }
  }

  if (dataInfo.dataType === &#x27;blob&#x27;) {
    self._uploadDataTransfers[targetChannel] = self._chunkBlobData(data, chunkSize);
  } else {
    self._uploadDataTransfers[targetChannel] = self._chunkDataURL(data, chunkSize);
  }

  self._uploadDataSessions[targetChannel] = {
    name: dataInfo.name,
    size: binarySize,
    isUpload: true,
    senderPeerId: self._user.sid,
    transferId: dataInfo.transferId,
    percentage: 0,
    timeout: dataInfo.timeout,
    chunkSize: chunkSize,
    dataType: dataInfo.dataType,
    isPrivate: dataInfo.isPrivate
  };

  if (supportMulti) {
    self._condition(&#x27;dataChannelState&#x27;, function () {
      startTransferFn(targetPeerId, targetChannel);
    }, function () {
      return self._dataChannels[targetPeerId][targetChannel].readyState ===
        self.DATA_CHANNEL_STATE.OPEN;
    }, function (state) {
      return state === self.DATA_CHANNEL_STATE.OPEN;
    });
  } else {
    startTransferFn(targetChannel, targetChannel);
  }

  return targetChannel;
};

/**
 * Function that handles the data received from Datachannel and
 *   routes to the relevant data transfer protocol handler.
 * @method _dataChannelProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._dataChannelProtocolHandler = function(dataString, peerId, channelName, channelType) {
  // PROTOCOL ESTABLISHMENT

  if (!(this._peerInformations[peerId] || {}).agent) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Peer informations is missing during protocol &#x27; +
      &#x27;handling. Dropping packet&#x27;], dataString);
    return;
  }

  /*var useChannel = channelName;
  var peerAgent = this._peerInformations[peerId].agent.name;

  if (channelType === this.DATA_CHANNEL_TYPE.MESSAGING ||
    this._INTEROP_MULTI_TRANSFERS[peerAgent] &gt; -1) {
    useChannel = peerId;
  }*/

  if (typeof dataString === &#x27;string&#x27;) {
    var data = {};
    try {
      data = JSON.parse(dataString);
    } catch (error) {
      log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Received from peer -&gt;&#x27;], {
        type: &#x27;DATA&#x27;,
        data: dataString
      });
      this._DATAProtocolHandler(peerId, dataString,
        this.DATA_TRANSFER_DATA_TYPE.BINARY_STRING, channelName);
      return;
    }
    log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Received from peer -&gt;&#x27;], {
      type: data.type,
      data: data
    });
    switch (data.type) {
    case this._DC_PROTOCOL_TYPE.WRQ:
      this._WRQProtocolHandler(peerId, data, channelName);
      break;
    case this._DC_PROTOCOL_TYPE.ACK:
      this._ACKProtocolHandler(peerId, data, channelName);
      break;
    case this._DC_PROTOCOL_TYPE.ERROR:
      this._ERRORProtocolHandler(peerId, data, channelName);
      break;
    case this._DC_PROTOCOL_TYPE.CANCEL:
      this._CANCELProtocolHandler(peerId, data, channelName);
      break;
    case this._DC_PROTOCOL_TYPE.MESSAGE: // Not considered a protocol actually?
      this._MESSAGEProtocolHandler(peerId, data, channelName);
      break;
    default:
      log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Unsupported message -&gt;&#x27;], {
        type: data.type,
        data: data
      });
    }
  }
};

/**
 * Function that handles the &quot;WRQ&quot; data transfer protocol.
 * @method _WRQProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._WRQProtocolHandler = function(peerId, data, channelName) {
  var transferId = channelName + this._TRANSFER_DELIMITER + (new Date()).getTime();

  log.log([peerId, &#x27;RTCDataChannel&#x27;, channelName,
    &#x27;Received file request from peer:&#x27;], data);

  var name = data.name;
  var binarySize = data.size;
  var expectedSize = data.chunkSize;
  var timeout = data.timeout;

  this._downloadDataSessions[channelName] = {
    transferId: transferId,
    name: name,
    isUpload: false,
    senderPeerId: peerId,
    size: binarySize,
    percentage: 0,
    dataType: data.dataType,
    ackN: 0,
    receivedSize: 0,
    chunkSize: expectedSize,
    timeout: timeout,
    isPrivate: data.isPrivate
  };
  this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.UPLOAD_REQUEST,
    transferId, peerId, {
      name: name,
      size: binarySize,
      percentage: 0,
      data: null,
      dataType: data.dataType,
      senderPeerId: peerId,
      timeout: timeout,
      isPrivate: data.isPrivate
  });
  this._trigger(&#x27;incomingDataRequest&#x27;, transferId, peerId, {
    name: name,
    size: binarySize,
    percentage: 0,
    dataType: data.dataType,
    senderPeerId: peerId,
    timeout: timeout,
    isPrivate: data.isPrivate
  }, false);
};

/**
 * Function that handles the &quot;ACK&quot; data transfer protocol.
 * @method _ACKProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._ACKProtocolHandler = function(peerId, data, channelName) {
  var self = this;
  var ackN = data.ackN;
  var transferStatus = self._uploadDataSessions[channelName];

  if (!transferStatus) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Ignoring data received as &#x27; +
      &#x27;upload data transfers is empty&#x27;], {
        status: transferStatus,
        data: data
    });
    return;
  }

  if (!this._uploadDataTransfers[channelName]) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName,
      &#x27;Ignoring data received as upload data transfers array is missing&#x27;], {
        data: data
    });
    return;
  }

  //peerId = (peerId === &#x27;MCU&#x27;) ? data.sender : peerId;
  var chunksLength = self._uploadDataTransfers[channelName].length;
  var transferId = transferStatus.transferId;
  var timeout = transferStatus.timeout;

  self._clearDataChannelTimeout(peerId, true, channelName);
  log.log([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;ACK stage (&#x27; +
    transferStatus.transferId + &#x27;) -&gt;&#x27;], ackN + &#x27; / &#x27; + chunksLength);

  if (ackN &gt; -1) {
    // Still uploading
    if (ackN &lt; chunksLength) {
      var sendDataFn = function (base64BinaryString) {
        var percentage = parseFloat((((ackN + 1) / chunksLength) * 100).toFixed(2), 10);

        if (!self._uploadDataSessions[channelName]) {
          log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName,
            &#x27;Failed uploading as data session is empty&#x27;], {
              status: transferStatus,
              data: data
          });
          return;
        }

        self._uploadDataSessions[channelName].percentage = percentage;

        self._sendDataChannelMessage(peerId, base64BinaryString, channelName);
        self._setDataChannelTimeout(peerId, timeout, true, channelName);

        // to prevent from firing upload = 100;
        if (percentage !== 100) {
          self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.UPLOADING,
            transferId, peerId, {
              name: transferStatus.name,
              size: transferStatus.size,
              percentage: percentage,
              data: null,
              dataType: transferStatus.dataType,
              senderPeerId: transferStatus.senderPeerId,
              timeout: transferStatus.timeout,
              isPrivate: transferStatus.isPrivate
          });
        }
      };

      if (transferStatus.dataType === &#x27;blob&#x27;) {
        self._blobToBase64(self._uploadDataTransfers[channelName][ackN], sendDataFn);
      } else {
        sendDataFn(self._uploadDataTransfers[channelName][ackN]);
      }
    } else if (ackN === chunksLength) {
	    log.log([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Upload completed (&#x27; +
        transferStatus.transferId + &#x27;)&#x27;], transferStatus);

      self._trigger(&#x27;dataTransferState&#x27;,
        self.DATA_TRANSFER_STATE.UPLOAD_COMPLETED, transferId, peerId, {
          name: transferStatus.name,
          size: transferStatus.size,
          percentage: 100,
          data: null,
          dataType: transferStatus.dataType,
          senderPeerId: transferStatus.senderPeerId,
          timeout: transferStatus.timeout,
          isPrivate: transferStatus.isPrivate
      });

      var blob = null;

      if (transferStatus.dataType === &#x27;blob&#x27;) {
        blob = new Blob(self._uploadDataTransfers[channelName]);
      } else {
        blob = self._assembleDataURL(self._uploadDataTransfers[channelName]);
      }

      self._trigger(&#x27;incomingData&#x27;, blob, transferId, peerId, {
        name: transferStatus.name,
        size: transferStatus.size,
        percentage: 100,
        dataType: transferStatus.dataType,
        senderPeerId: transferStatus.senderPeerId,
        timeout: transferStatus.timeout,
        isPrivate: transferStatus.isPrivate
      }, true);
      delete self._uploadDataTransfers[channelName];
      delete self._uploadDataSessions[channelName];

      // close datachannel after transfer
      if (self._dataChannels[peerId] &amp;&amp; self._dataChannels[peerId][channelName]) {
        log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Closing datachannel for upload transfer&#x27;]);
        self._closeDataChannel(peerId, channelName);
      }
    }
  } else {
    log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Upload rejected (&#x27; +
      transferStatus.transferId + &#x27;)&#x27;], transferStatus);

    self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.REJECTED,
      transferId, peerId, {
        name: transferStatus.name, //self._uploadDataSessions[channelName].name,
        size: transferStatus.size, //self._uploadDataSessions[channelName].size,
        percentage: 0,
        data: null,
        dataType: transferStatus.dataType,
        senderPeerId: transferStatus.senderPeerId,
        timeout: transferStatus.timeout,
        isPrivate: transferStatus.isPrivate
    });
    delete self._uploadDataTransfers[channelName];
    delete self._uploadDataSessions[channelName];

    // close datachannel if rejected
    if (self._dataChannels[peerId] &amp;&amp; self._dataChannels[peerId][channelName]) {
      log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Closing datachannel for upload transfer&#x27;]);
      self._closeDataChannel(peerId, channelName);
    }
  }
};

/**
 * Function that handles the &quot;MESSAGE&quot; data transfer protocol.
 * @method _MESSAGEProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._MESSAGEProtocolHandler = function(peerId, data, channelName) {
  var targetMid = data.sender;
  log.log([targetMid, &#x27;RTCDataChannel&#x27;, channelName,
    &#x27;Received P2P message from peer:&#x27;], data);
  this._trigger(&#x27;incomingMessage&#x27;, {
    content: data.data,
    isPrivate: data.isPrivate,
    isDataChannel: true,
    targetPeerId: this._user.sid,
    senderPeerId: targetMid
  }, targetMid, this.getPeerInfo(targetMid), false);
};

/**
 * Function that handles the &quot;ERROR&quot; data transfer protocol.
 * @method _ERRORProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._ERRORProtocolHandler = function(peerId, data, channelName) {
  var isUploader = data.isUploadError;
  var transferStatus = (isUploader) ? this._uploadDataSessions[channelName] :
    this._downloadDataSessions[channelName];

  if (!transferStatus) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Ignoring data received as &#x27; +
      (isUploader ? &#x27;upload&#x27; : &#x27;download&#x27;) + &#x27; data session is empty&#x27;], data);
    return;
  }

  var transferId = transferStatus.transferId;

  log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName,
    &#x27;Received an error from peer:&#x27;], data);
  this._clearDataChannelTimeout(peerId, isUploader, channelName);
  this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.ERROR,
    transferId, peerId, {
      name: transferStatus.name,
      size: transferStatus.size,
      percentage: transferStatus.percentage,
      data: null,
      dataType: transferStatus.dataType,
      senderPeerId: transferStatus.senderPeerId,
      timeout: transferStatus.timeout,
      isPrivate: transferStatus.isPrivate
    }, {
      message: data.content,
      transferType: ((isUploader) ? this.DATA_TRANSFER_TYPE.UPLOAD :
        this.DATA_TRANSFER_TYPE.DOWNLOAD)
  });
};

/**
 * Function that handles the &quot;CANCEL&quot; data transfer protocol.
 * @method _CANCELProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.0
 */
Skylink.prototype._CANCELProtocolHandler = function(peerId, data, channelName) {
  var isUpload = !!this._uploadDataSessions[channelName];
  var isDownload = !!this._downloadDataSessions[channelName];
  var transferStatus = (isUpload) ? this._uploadDataSessions[channelName] :
    this._downloadDataSessions[channelName];

  if (!transferStatus) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Ignoring data received as &#x27; +
      (isUpload ? &#x27;upload&#x27; : &#x27;download&#x27;) + &#x27; data session is empty&#x27;], data);
    return;
  }

  var transferId = transferStatus.transferId;

  log.log([peerId, &#x27;RTCDataChannel&#x27;, channelName,
    &#x27;Received file transfer cancel request:&#x27;], data);

  this._clearDataChannelTimeout(peerId, isUpload, channelName);

  try {
    if (isUpload) {
      delete this._uploadDataSessions[channelName];
      delete this._uploadDataTransfers[channelName];
    } else {
      delete this._downloadDataSessions[channelName];
      delete this._downloadDataTransfers[channelName];
    }

    this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.CANCEL,
      transferId, peerId, {
        name: transferStatus.name,
        size: transferStatus.size,
        data: null,
        dataType: transferStatus.dataType,
        percentage: transferStatus.percentage,
        senderPeerId: transferStatus.senderPeerId,
        timeout: transferStatus.timeout,
        isPrivate: transferStatus.isPrivate
      }, {
        message: data.content,
        transferType: ((isUpload) ? this.DATA_TRANSFER_TYPE.UPLOAD :
          this.DATA_TRANSFER_TYPE.DOWNLOAD)
    });

    log.log([peerId, &#x27;RTCDataChannel&#x27;, channelName,
      &#x27;Emptied file transfer session:&#x27;], data);

  } catch (error) {
    this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.ERROR,
      transferId, peerId, {
        name: transferStatus.name,
        size: transferStatus.size,
        data: null,
        dataType: transferStatus.dataType,
        percentage: transferStatus.percentage,
        senderPeerId: transferStatus.senderPeerId,
        timeout: transferStatus.timeout,
        isPrivate: transferStatus.isPrivate
      }, {
        message: &#x27;Failed cancelling data request from peer&#x27;,
        transferType: ((isUpload) ? this.DATA_TRANSFER_TYPE.UPLOAD :
          this.DATA_TRANSFER_TYPE.DOWNLOAD)
    });

    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName,
      &#x27;Failed emptying file transfer session:&#x27;], {
        data: data,
        error: error
    });
  }
};

/**
 * Function that handles the data transfer chunk received.
 * @method _DATAProtocolHandler
 * @private
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype._DATAProtocolHandler = function(peerId, dataString, dataType, channelName) {
  var chunk, error = &#x27;&#x27;;
  var transferStatus = this._downloadDataSessions[channelName];
  log.log([peerId, &#x27;RTCDataChannel&#x27;, channelName,
    &#x27;Received data chunk from peer -&gt;&#x27;], {
      dataType: dataType,
      data: dataString,
      type: &#x27;DATA&#x27;
  });

  if (!transferStatus) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName,
      &#x27;Ignoring data received as download data session is empty&#x27;], {
        dataType: dataType,
        data: dataString,
        type: &#x27;DATA&#x27;
    });
    return;
  }

  if (!this._downloadDataTransfers[channelName]) {
    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName,
      &#x27;Ignoring data received as download data transfers array is missing&#x27;], {
        dataType: dataType,
        data: dataString,
        type: &#x27;DATA&#x27;
    });
    return;
  }

  var transferId = transferStatus.transferId;
  var dataTransferType = transferStatus.dataType;
  var receivedSize = 0;

  this._clearDataChannelTimeout(peerId, false, channelName);

  if (dataType === this.DATA_TRANSFER_DATA_TYPE.BINARY_STRING) {
    if (dataTransferType === &#x27;blob&#x27;) {
      chunk = this._base64ToBlob(dataString);
      receivedSize = (chunk.size * (4 / 3));
    } else {
      chunk = dataString;
      receivedSize = dataString.length;
    }
  } else if (dataType === this.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER) {
    chunk = new Blob(dataString);
  } else if (dataType === this.DATA_TRANSFER_DATA_TYPE.BLOB) {
    chunk = dataString;
  } else {
    error = &#x27;Unhandled data exception: &#x27; + dataType;
    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Failed downloading data packets:&#x27;], {
      dataType: dataType,
      data: dataString,
      type: &#x27;DATA&#x27;,
      error: error
    });
    this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.ERROR,
      transferId, peerId, {
        name: transferStatus.name,
        size: transferStatus.size,
        percentage: transferStatus.percentage,
        data: null,
        dataType: dataTransferType,
        senderPeerId: transferStatus.senderPeerId,
        timeout: transferStatus.timeout,
        isPrivate: transferStatus.isPrivate
      }, {
        message: error,
        transferType: this.DATA_TRANSFER_TYPE.DOWNLOAD
    });
    return;
  }

  log.log([peerId, &#x27;RTCDataChannel&#x27;, channelName,
    &#x27;Received and expected data chunk size (&#x27; + receivedSize + &#x27; === &#x27; +
      transferStatus.chunkSize + &#x27;)&#x27;], {
        dataType: dataType,
        data: dataString,
        receivedSize: receivedSize,
        expectedSize: transferStatus.chunkSize,
        type: &#x27;DATA&#x27;
  });

  if (transferStatus.chunkSize &gt;= receivedSize) {
    this._downloadDataTransfers[channelName].push(chunk);
    transferStatus.ackN += 1;
    transferStatus.receivedSize += receivedSize;
    var totalReceivedSize = transferStatus.receivedSize;
    var percentage = parseFloat(((totalReceivedSize / transferStatus.size) * 100).toFixed(2), 10);

    this._sendDataChannelMessage(peerId, {
      type: this._DC_PROTOCOL_TYPE.ACK,
      sender: this._user.sid,
      ackN: transferStatus.ackN
    }, channelName);

    // update the percentage
    this._downloadDataSessions[channelName].percentage = percentage;

    if (transferStatus.chunkSize === receivedSize &amp;&amp; percentage &lt; 100) {
      log.log([peerId, &#x27;RTCDataChannel&#x27;, channelName,
        &#x27;Transfer in progress ACK n (&#x27; + transferStatus.ackN + &#x27;)&#x27;], {
          dataType: dataType,
          data: dataString,
          ackN: transferStatus.ackN,
          type: &#x27;DATA&#x27;
      });
      this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.DOWNLOADING,
        transferId, peerId, {
          name: transferStatus.name,
          size: transferStatus.size,
          percentage: percentage,
          data: null,
          dataType: dataTransferType,
          senderPeerId: transferStatus.senderPeerId,
          timeout: transferStatus.timeout,
          isPrivate: transferStatus.isPrivate
      });
      this._setDataChannelTimeout(peerId, transferStatus.timeout, false, channelName);

      if (!this._downloadDataSessions[channelName]) {
        log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName,
          &#x27;Failed downloading as data session is empty&#x27;], {
            dataType: dataType,
            data: dataString,
            type: &#x27;DATA&#x27;
        });
        return;
      }

      this._downloadDataSessions[channelName].info = transferStatus;

    } else {
      log.log([peerId, &#x27;RTCDataChannel&#x27;, channelName,
        &#x27;Download complete&#x27;], {
          dataType: dataType,
          data: dataString,
          type: &#x27;DATA&#x27;,
          transferInfo: transferStatus
      });

      var blob = null;

      if (dataTransferType === &#x27;blob&#x27;) {
        blob = new Blob(this._downloadDataTransfers[channelName]);
      } else {
        blob = this._assembleDataURL(this._downloadDataTransfers[channelName]);
      }
      this._trigger(&#x27;dataTransferState&#x27;, this.DATA_TRANSFER_STATE.DOWNLOAD_COMPLETED,
        transferId, peerId, {
          name: transferStatus.name,
          size: transferStatus.size,
          percentage: 100,
          data: blob,
          dataType: dataTransferType,
          senderPeerId: transferStatus.senderPeerId,
          timeout: transferStatus.timeout,
          isPrivate: transferStatus.isPrivate
      });

      this._trigger(&#x27;incomingData&#x27;, blob, transferId, peerId, {
        name: transferStatus.name,
        size: transferStatus.size,
        percentage: 100,
        dataType: dataTransferType,
        senderPeerId: transferStatus.senderPeerId,
        timeout: transferStatus.timeout,
        isPrivate: transferStatus.isPrivate
      }, false);

      delete this._downloadDataTransfers[channelName];
      delete this._downloadDataSessions[channelName];

      log.log([peerId, &#x27;RTCDataChannel&#x27;, channelName,
        &#x27;Converted to Blob as download&#x27;], {
          dataType: dataType,
          data: dataString,
          type: &#x27;DATA&#x27;,
          transferInfo: transferStatus
      });

      // close datachannel after transfer
      if (this._dataChannels[peerId] &amp;&amp; this._dataChannels[peerId][channelName]) {
        log.debug([peerId, &#x27;RTCDataChannel&#x27;, channelName, &#x27;Closing datachannel for download transfer&#x27;]);
        this._closeDataChannel(peerId, channelName);
      }
    }

  } else {
    error = &#x27;Packet not match - [Received]&#x27; + receivedSize +
      &#x27; / [Expected]&#x27; + transferStatus.chunkSize;

    this._trigger(&#x27;dataTransferState&#x27;,
      this.DATA_TRANSFER_STATE.ERROR, transferId, peerId, {
        name: transferStatus.name,
        size: transferStatus.size,
        percentage: transferStatus.percentage,
        data: null,
        dataType: dataTransferType,
        senderPeerId: transferStatus.senderPeerId,
        timeout: transferStatus.timeout,
        isPrivate: transferStatus.isPrivate
      }, {
        message: error,
        transferType: this.DATA_TRANSFER_TYPE.DOWNLOAD
    });

    log.error([peerId, &#x27;RTCDataChannel&#x27;, channelName,
      &#x27;Failed downloading data packets:&#x27;], {
        dataType: dataType,
        data: dataString,
        type: &#x27;DATA&#x27;,
        transferInfo: transferStatus,
        error: error
    });
  }
};

/**
 * Function that start the data transfer with the list of targeted Peer IDs provided.
 * At this stage, it will open a new Datachannel connection if simultaneous data transfers is
 *   supported by Peer, or it will using the messaging type Datachannel connection.
 * Note that 1 data transfer can occur at a time in 1 Datachannel connection.
 * @method _startDataTransfer
 * @private
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype._startDataTransfer = function(data, dataInfo, listOfPeers, callback) {
  var self = this;
  var error = &#x27;&#x27;;
  var noOfPeersSent = 0;
  var transferId = dataInfo.transferId;
  var dataType = dataInfo.dataType;
  var isPrivate = dataInfo.isPrivate;
  var i;
  var peerId;

  // for callback
  var listOfPeersTransferState = {};
  var transferSuccess = true;
  var listOfPeersTransferErrors = {};
  var listOfPeersChannels = {};
  var successfulPeerTransfers = [];

  var triggerCallbackFn = function () {
    for (i = 0; i &lt; listOfPeers.length; i++) {
      var transferPeerId = listOfPeers[i];

      if (!listOfPeersTransferState[transferPeerId]) {
        // if error, make as false and break
        transferSuccess = false;
        break;
      }
    }

    if (transferSuccess) {
      log.log([null, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Firing success callback for data transfer&#x27;], dataInfo);
      // should we even support this? maybe keeping to not break older impl
      if (listOfPeers.length === 1 &amp;&amp; isPrivate) {
        callback(null,{
          state: self.DATA_TRANSFER_STATE.UPLOAD_COMPLETED,
          peerId: listOfPeers[0],
          listOfPeers: listOfPeers,
          transferId: transferId,
          isPrivate: isPrivate, // added new flag to indicate privacy
          transferInfo: dataInfo
        });
      } else {
        callback(null,{
          state: null,
          peerId: null,
          transferId: transferId,
          listOfPeers: listOfPeers,
          isPrivate: isPrivate, // added new flag to indicate privacy
          transferInfo: dataInfo
        });
      }
    } else {
      log.log([null, &#x27;RTCDataChannel&#x27;, transferId, &#x27;Firing failure callback for data transfer&#x27;], dataInfo);

      // should we even support this? maybe keeping to not break older impl
      if (listOfPeers.length === 1 &amp;&amp; isPrivate) {
        callback({
          state: self.DATA_TRANSFER_STATE.ERROR,
          error: listOfPeersTransferErrors[listOfPeers[0]],
          peerId: listOfPeers[0],
          transferId: transferId,
          transferErrors: listOfPeersTransferErrors,
          transferInfo: dataInfo,
          isPrivate: isPrivate, // added new flag to indicate privacy
          listOfPeers: listOfPeers
        }, null);
      } else {
        callback({
          state: null,
          peerId: null,
          error: null,
          transferId: transferId,
          listOfPeers: listOfPeers,
          isPrivate: isPrivate, // added new flag to indicate privacy
          transferInfo: dataInfo,
          transferErrors: listOfPeersTransferErrors
        }, null);
      }
    }
  };

  for (i = 0; i &lt; listOfPeers.length; i++) {
    peerId = listOfPeers[i];

    if (peerId === &#x27;MCU&#x27;) {
      continue;
    }

    if (self._dataChannels[peerId] &amp;&amp; self._dataChannels[peerId].main) {
      log.log([peerId, &#x27;RTCDataChannel&#x27;, null, &#x27;Sending blob data -&gt;&#x27;], dataInfo);

      self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.UPLOAD_STARTED,
        transferId, peerId, {
          name: dataInfo.name,
          size: dataInfo.size,
          percentage: 0,
          data: data,
          dataType: dataType,
          senderPeerId: self._user.sid,
          timeout: dataInfo.timeout,
          isPrivate: isPrivate
      });

      self._trigger(&#x27;incomingDataRequest&#x27;, transferId, peerId, {
        name: dataInfo.name,
        size: dataInfo.size,
        percentage: 0,
        dataType: dataType,
        senderPeerId: self._user.sid,
        timeout: dataInfo.timeout,
        isPrivate: isPrivate
      }, true);

      if (!self._hasMCU) {
        listOfPeersChannels[peerId] =
          self._sendBlobDataToPeer(data, dataInfo, peerId);
      } else {
        listOfPeersChannels[peerId] = self._dataChannels[peerId].main.label;
      }

      noOfPeersSent++;

    } else {
      error = &#x27;Datachannel does not exist. Unable to start data transfer with peer&#x27;;
      log.error([peerId, &#x27;RTCDataChannel&#x27;, null, error]);
      listOfPeersTransferErrors[peerId] = error;
    }
  }

  // if has MCU
  if (self._hasMCU) {
    self._sendBlobDataToPeer(data, dataInfo, listOfPeers, isPrivate, transferId);
  }

  if (noOfPeersSent === 0) {
    error = &#x27;Failed sending data as there is no available datachannels to send data&#x27;;

    for (i = 0; i &lt; listOfPeers.length; i++) {
      peerId = listOfPeers[i];

      self._trigger(&#x27;dataTransferState&#x27;, self.DATA_TRANSFER_STATE.ERROR,
        transferId, peerId, {
          name: dataInfo.name,
          size: dataInfo.size,
          data: null,
          dataType: dataType,
          percentage: 0,
          senderPeerId: self._user.sid,
          timeout: dataInfo.timeout,
          isPrivate: isPrivate
        }, {
          message: error,
          transferType: self.DATA_TRANSFER_TYPE.UPLOAD
      });

      listOfPeersTransferErrors[peerId] = error;
    }

    log.error([null, &#x27;RTCDataChannel&#x27;, null, error]);
    self._uploadDataTransfers = [];
    self._uploadDataSessions = [];

    transferSuccess = false;

    if (typeof callback === &#x27;function&#x27;) {
      triggerCallbackFn();
    }
    return;
  }

  if (typeof callback === &#x27;function&#x27;) {
    var dataChannelStateFn = function(state, transferringPeerId, errorObj, channelName, channelType){
      // check if error or closed halfway, if so abort
      if (state === self.DATA_CHANNEL_STATE.ERROR &amp;&amp;
        state === self.DATA_CHANNEL_STATE.CLOSED &amp;&amp;
        listOfPeersChannels[peerId] === channelName) {
        // if peer has already been inside, ignore
        if (successfulPeerTransfers.indexOf(transferringPeerId) === -1) {
          listOfPeersTransferState[transferringPeerId] = false;
          listOfPeersTransferErrors[transferringPeerId] = errorObj;

          log.error([transferringPeerId, &#x27;RTCDataChannel&#x27;, null,
            &#x27;Data channel state has met a failure state for peer (datachannel) -&gt;&#x27;], {
              state: state,
              error: errorObj
          });
        }
      }

      if (Object.keys(listOfPeersTransferState).length === listOfPeers.length) {
        self.off(&#x27;dataTransferState&#x27;, dataTransferStateFn);
        self.off(&#x27;dataChannelState&#x27;, dataChannelStateFn);

        log.log([null, &#x27;RTCDataChannel&#x27;, transferId,
          &#x27;Transfer states have been gathered completely in dataChannelState&#x27;], state);

        triggerCallbackFn();
      }
    };

    var dataTransferStateFn = function(state, stateTransferId, transferringPeerId, transferInfo, errorObj){
      // check if transfer is related to this transfer
      if (stateTransferId === transferId) {
        // check if state upload has completed
        if (state === self.DATA_TRANSFER_STATE.UPLOAD_COMPLETED) {

          log.debug([transferringPeerId, &#x27;RTCDataChannel&#x27;, stateTransferId,
            &#x27;Data transfer state has met a success state for peer -&gt;&#x27;], state);

          // if peer has already been inside, ignore
          if (successfulPeerTransfers.indexOf(transferringPeerId) === -1) {
            listOfPeersTransferState[transferringPeerId] = true;
          }
        } else if(state === self.DATA_TRANSFER_STATE.REJECTED ||
          state === self.DATA_TRANSFER_STATE.CANCEL ||
          state === self.DATA_TRANSFER_STATE.ERROR) {

          if (state === self.DATA_TRANSFER_STATE.REJECTED) {
            errorObj = new Error(&#x27;Peer has rejected data transfer request&#x27;);
          }

          log.error([transferringPeerId, &#x27;RTCDataChannel&#x27;, stateTransferId,
            &#x27;Data transfer state has met a failure state for peer -&gt;&#x27;], {
              state: state,
              error: errorObj
          });

          // if peer has already been inside, ignore
          if (successfulPeerTransfers.indexOf(transferringPeerId) === -1) {
            listOfPeersTransferState[transferringPeerId] = false;
            listOfPeersTransferErrors[transferringPeerId] = errorObj;
          }
        }
      }

      if (Object.keys(listOfPeersTransferState).length === listOfPeers.length) {
        self.off(&#x27;dataTransferState&#x27;, dataTransferStateFn);
        self.off(&#x27;dataChannelState&#x27;, dataChannelStateFn);

        log.log([null, &#x27;RTCDataChannel&#x27;, stateTransferId,
          &#x27;Transfer states have been gathered completely in dataTransferState&#x27;], state);

        triggerCallbackFn();
      }
    };
    self.on(&#x27;dataTransferState&#x27;, dataTransferStateFn);
    self.on(&#x27;dataChannelState&#x27;, dataChannelStateFn);
  }
};

    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
