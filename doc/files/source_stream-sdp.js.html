<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Temasys Documentation - SkylinkJS 0.6.39 - Web SDK</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- font and icon -->
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <!-- styling -->
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap-theme.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- scripts -->
    <script src="../assets/vendor/js/jquery.min.js"></script>
    <script src="../assets/vendor/js/bootstrap.min.js"></script>
    <script src="../assets/js/script.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" /><small>Version: 0.6.39</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Getting Started Examples <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="https://temasys.io/getting-started-with-webrtc-and-skylinkjs/">Setting up a Video Call</a></li>
      <li><a href="https://temasys.io/screensharing-with-skylinkjs/">Setting up Screensharing</a></li>
      <li><a href="https://temasys.io/building-a-simple-peer-to-peer-webrtc-chat/">Setting up a Chatroom</a></li>
    </ul>
  </li>
  
    <li><a href="../classes/Skylink.html">Documentation</a></li>
  
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
    </ul>
  </li>-->
  <li><a class="btn btn-info btn-navbar" href="https://console.temasys.io/">Developer Console</a></li>
  <li><a class="btn btn-info btn-navbar" href="http://support.temasys.io/">Support</a></li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
          
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content content-main">
                      <h1 class="file-heading">File: source/stream-sdp.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Function that modifies the session description to configure settings for OPUS audio codec.
 * @method _setSDPCodecParams
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._setSDPCodecParams = function(targetMid, sessionDescription) {
  var self = this;

  var parseFn = function (type, codecName, samplingRate, settings) {
    var mLine = sessionDescription.sdp.match(new RegExp(&#x27;m=&#x27; + type + &#x27;\ .*\r\n&#x27;, &#x27;gi&#x27;));
    // Find the m= line
    if (Array.isArray(mLine) &amp;&amp; mLine.length &gt; 0) {
      var codecsList = sessionDescription.sdp.match(new RegExp(&#x27;a=rtpmap:.*\ &#x27; + codecName + &#x27;\/&#x27; +
        (samplingRate ? samplingRate + (type === &#x27;audio&#x27; ? &#x27;[\/]*.*&#x27; : &#x27;.*&#x27;) : &#x27;.*&#x27;) + &#x27;\r\n&#x27;, &#x27;gi&#x27;));
      // Get the list of codecs related to it
      if (Array.isArray(codecsList) &amp;&amp; codecsList.length &gt; 0) {
        for (var i = 0; i &lt; codecsList.length; i++) {
          var payload = (codecsList[i].split(&#x27;a=rtpmap:&#x27;)[1] || &#x27;&#x27;).split(&#x27; &#x27;)[0];
          if (!payload) {
            continue;
          }
          var fmtpLine = sessionDescription.sdp.match(new RegExp(&#x27;a=fmtp:&#x27; + payload + &#x27;\ .*\r\n&#x27;, &#x27;gi&#x27;));
          var updatedFmtpLine = &#x27;a=fmtp:&#x27; + payload + &#x27; &#x27;;
          var addedKeys = [];
          // Check if a=fmtp: line exists
          if (Array.isArray(fmtpLine) &amp;&amp; fmtpLine.length &gt; 0) {
            var fmtpParts = (fmtpLine[0].split(&#x27;a=fmtp:&#x27; + payload + &#x27; &#x27;)[1] || &#x27;&#x27;).replace(
              / /g, &#x27;&#x27;).replace(/\r\n/g, &#x27;&#x27;).split(&#x27;;&#x27;);
            for (var j = 0; j &lt; fmtpParts.length; j++) {
              if (!fmtpParts[j]) {
                continue;
              }
              var keyAndValue = fmtpParts[j].split(&#x27;=&#x27;);
              if (settings.hasOwnProperty(keyAndValue[0])) {
                // Dont append parameter key+value if boolean and false
                updatedFmtpLine += typeof settings[keyAndValue[0]] === &#x27;boolean&#x27; ? (settings[keyAndValue[0]] ?
                  keyAndValue[0] + &#x27;=1;&#x27; : &#x27;&#x27;) : keyAndValue[0] + &#x27;=&#x27; + settings[keyAndValue[0]] + &#x27;;&#x27;;
              } else {
                updatedFmtpLine += fmtpParts[j] + &#x27;;&#x27;;
              }
              addedKeys.push(keyAndValue[0]);
            }
            sessionDescription.sdp = sessionDescription.sdp.replace(fmtpLine[0], &#x27;&#x27;);
          }
          for (var key in settings) {
            if (settings.hasOwnProperty(key) &amp;&amp; addedKeys.indexOf(key) === -1) {
              // Dont append parameter key+value if boolean and false
              updatedFmtpLine += typeof settings[key] === &#x27;boolean&#x27; ? (settings[key] ? key + &#x27;=1;&#x27; : &#x27;&#x27;) :
                key + &#x27;=&#x27; + settings[key] + &#x27;;&#x27;;
              addedKeys.push(key);
            }
          }
          if (updatedFmtpLine !== &#x27;a=fmtp:&#x27; + payload + &#x27; &#x27;) {
            sessionDescription.sdp = sessionDescription.sdp.replace(codecsList[i], codecsList[i] + updatedFmtpLine + &#x27;\r\n&#x27;);
          }
        }
      }
    }
  };

  // Set audio codecs -&gt; OPUS
  // RFC: https://tools.ietf.org/html/draft-ietf-payload-rtp-opus-11
  parseFn(&#x27;audio&#x27;, self.AUDIO_CODEC.OPUS, 48000, (function () {
    var opusOptions = {};
    var audioSettings = self._streams.screenshare ? self._streams.screenshare.settings.audio :
      (self._streams.userMedia ? self._streams.userMedia.settings.audio : {});
    audioSettings = audioSettings &amp;&amp; typeof audioSettings === &#x27;object&#x27; ? audioSettings : {};
    if (typeof self._initOptions.codecParams.audio.opus.stereo === &#x27;boolean&#x27;) {
      opusOptions.stereo = self._initOptions.codecParams.audio.opus.stereo;
    } else if (typeof audioSettings.stereo === &#x27;boolean&#x27;) {
      opusOptions.stereo = audioSettings.stereo;
    }
    if (typeof self._initOptions.codecParams.audio.opus[&#x27;sprop-stereo&#x27;] === &#x27;boolean&#x27;) {
      opusOptions[&#x27;sprop-stereo&#x27;] = self._initOptions.codecParams.audio.opus[&#x27;sprop-stereo&#x27;];
    } else if (typeof audioSettings.stereo === &#x27;boolean&#x27;) {
      opusOptions[&#x27;sprop-stereo&#x27;] = audioSettings.stereo;
    }
    if (typeof self._initOptions.codecParams.audio.opus.usedtx === &#x27;boolean&#x27;) {
      opusOptions.usedtx = self._initOptions.codecParams.audio.opus.usedtx;
    } else if (typeof audioSettings.usedtx === &#x27;boolean&#x27;) {
      opusOptions.usedtx = audioSettings.usedtx;
    }
    if (typeof self._initOptions.codecParams.audio.opus.useinbandfec === &#x27;boolean&#x27;) {
      opusOptions.useinbandfec = self._initOptions.codecParams.audio.opus.useinbandfec;
    } else if (typeof audioSettings.useinbandfec === &#x27;boolean&#x27;) {
      opusOptions.useinbandfec = audioSettings.useinbandfec;
    }
    if (typeof self._initOptions.codecParams.audio.opus.maxplaybackrate === &#x27;number&#x27;) {
      opusOptions.maxplaybackrate = self._initOptions.codecParams.audio.opus.maxplaybackrate;
    } else if (typeof audioSettings.maxplaybackrate === &#x27;number&#x27;) {
      opusOptions.maxplaybackrate = audioSettings.maxplaybackrate;
    }
    if (typeof self._initOptions.codecParams.audio.opus.minptime === &#x27;number&#x27;) {
      opusOptions.minptime = self._initOptions.codecParams.audio.opus.minptime;
    } else if (typeof audioSettings.minptime === &#x27;number&#x27;) {
      opusOptions.minptime = audioSettings.minptime;
    }
    // Possible future params: sprop-maxcapturerate, maxaveragebitrate, sprop-stereo, cbr
    // NOT recommended: maxptime, ptime, rate, minptime
    return opusOptions;
  })());

  // RFC: https://tools.ietf.org/html/rfc4733
  // Future: Set telephone-event: 100 0-15,66,70

  // RFC: https://tools.ietf.org/html/draft-ietf-payload-vp8-17
  // Set video codecs -&gt; VP8
  parseFn(&#x27;video&#x27;, self.VIDEO_CODEC.VP8, null, (function () {
    var vp8Options = {};
    // NOT recommended: max-fr, max-fs (all are codec decoder capabilities)
    if (typeof self._initOptions.codecParams.video.vp8.maxFr === &#x27;number&#x27;) {
      vp8Options[&#x27;max-fr&#x27;] = self._initOptions.codecParams.video.vp8.maxFr;
    }
    if (typeof self._initOptions.codecParams.video.vp8.maxFs === &#x27;number&#x27;) {
      vp8Options[&#x27;max-fs&#x27;] = self._initOptions.codecParams.video.vp8.maxFs;
    }
    return vp8Options;
  })());

  // RFC: https://tools.ietf.org/html/draft-ietf-payload-vp9-02
  // Set video codecs -&gt; VP9
  parseFn(&#x27;video&#x27;, self.VIDEO_CODEC.VP9, null, (function () {
    var vp9Options = {};
    // NOT recommended: max-fr, max-fs (all are codec decoder capabilities)
    if (typeof self._initOptions.codecParams.video.vp9.maxFr === &#x27;number&#x27;) {
      vp9Options[&#x27;max-fr&#x27;] = self._initOptions.codecParams.video.vp9.maxFr;
    }
    if (typeof self._initOptions.codecParams.video.vp9.maxFs === &#x27;number&#x27;) {
      vp9Options[&#x27;max-fs&#x27;] = self._initOptions.codecParams.video.vp9.maxFs;
    }
    return vp9Options;
  })());

  // RFC: https://tools.ietf.org/html/rfc6184
  // Set the video codecs -&gt; H264
  parseFn(&#x27;video&#x27;, self.VIDEO_CODEC.H264, null, (function () {
    var h264Options = {};
    if (typeof self._initOptions.codecParams.video.h264.levelAsymmetryAllowed === &#x27;string&#x27;) {
      h264Options[&#x27;profile-level-id&#x27;] = self._initOptions.codecParams.video.h264.profileLevelId;
    }
    if (typeof self._initOptions.codecParams.video.h264.levelAsymmetryAllowed === &#x27;boolean&#x27;) {
      h264Options[&#x27;level-asymmetry-allowed&#x27;] = self._initOptions.codecParams.video.h264.levelAsymmetryAllowed;
    }
    if (typeof self._initOptions.codecParams.video.h264.packetizationMode === &#x27;boolean&#x27;) {
      h264Options[&#x27;packetization-mode&#x27;] = self._initOptions.codecParams.video.h264.packetizationMode;
    }
    // Possible future params (remove if they are decoder/encoder capabilities or info):
    //   max-recv-level, max-mbps, max-smbps, max-fs, max-cpb, max-dpb, max-br,
    //   max-mbps, max-smbps, max-fs, max-cpb, max-dpb, max-br, redundant-pic-cap, sprop-parameter-sets,
    //   sprop-level-parameter-sets, use-level-src-parameter-sets, in-band-parameter-sets,
    //   sprop-interleaving-depth, sprop-deint-buf-req, deint-buf-cap, sprop-init-buf-time,
    //   sprop-max-don-diff, max-rcmd-nalu-size, sar-understood, sar-supported
    //   NOT recommended: profile-level-id (WebRTC uses &quot;42e00a&quot; for the moment)
    //   https://bugs.chromium.org/p/chromium/issues/detail?id=645599
    return h264Options;
  })());

  return sessionDescription.sdp;
};

/**
 * Function that modifies the session description to limit the maximum sending bandwidth.
 * Setting this may not necessarily work in Firefox.
 * @method _setSDPBitrate
 * @private
 * @for Skylink
 * @since 0.5.10
 */
Skylink.prototype._setSDPBitrate = function(targetMid, sessionDescription) {
  var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);
  var parseFn = function (type, bw) {
    var mLineType = type;
    var mLineIndex = -1;
    var cLineIndex = -1;

    if (type === &#x27;data&#x27;) {
      mLineType = &#x27;application&#x27;;
    }

    for (var i = 0; i &lt; sdpLines.length; i++) {
      if (sdpLines[i].indexOf(&#x27;m=&#x27; + mLineType) === 0) {
        mLineIndex = i;
      } else if (mLineIndex &gt; 0) {
        if (sdpLines[i].indexOf(&#x27;m=&#x27;) === 0) {
          break;
        }

        if (sdpLines[i].indexOf(&#x27;c=&#x27;) === 0) {
          cLineIndex = i;
        // Remove previous b:AS settings
        } else if (sdpLines[i].indexOf(&#x27;b=AS:&#x27;) === 0 || sdpLines[i].indexOf(&#x27;b:TIAS:&#x27;) === 0) {
          sdpLines.splice(i, 1);
          i--;
        }
      }
    }

    if (!(typeof bw === &#x27;number&#x27; &amp;&amp; bw &gt; 0)) {
      log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Not limiting &quot;&#x27; + type + &#x27;&quot; bandwidth&#x27;]);
      return;
    }

    if (cLineIndex === -1) {
      log.error([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Failed setting &quot;&#x27; +
        type + &#x27;&quot; bandwidth as c-line is missing.&#x27;]);
      return;
    }

    // Follow RFC 4566, that the b-line should follow after c-line.
    log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Limiting maximum sending &quot;&#x27; + type + &#x27;&quot; bandwidth -&gt;&#x27;], bw);
    sdpLines.splice(cLineIndex + 1, 0, window.webrtcDetectedBrowser === &#x27;firefox&#x27; ? &#x27;b=TIAS:&#x27; + (bw * 1000 *
    (window.webrtcDetectedVersion &gt; 52 &amp;&amp; window.webrtcDetectedVersion &lt; 55 ? 1000 : 1)).toFixed(0) : &#x27;b=AS:&#x27; + bw);
  };

  var bASAudioBw = this._streamsBandwidthSettings.bAS.audio;
  var bASVideoBw = this._streamsBandwidthSettings.bAS.video;
  var bASDataBw = this._streamsBandwidthSettings.bAS.data;
  var googleXMinBw = this._streamsBandwidthSettings.googleX.min;
  var googleXMaxBw = this._streamsBandwidthSettings.googleX.max;

  if (this._peerCustomConfigs[targetMid]) {
    if (this._peerCustomConfigs[targetMid].bandwidth &amp;&amp;
      typeof this._peerCustomConfigs[targetMid].bandwidth === &#x27;object&#x27;) {
      if (typeof this._peerCustomConfigs[targetMid].bandwidth.audio === &#x27;number&#x27;) {
        bASAudioBw = this._peerCustomConfigs[targetMid].bandwidth.audio;
      }
      if (typeof this._peerCustomConfigs[targetMid].bandwidth.video === &#x27;number&#x27;) {
        bASVideoBw = this._peerCustomConfigs[targetMid].bandwidth.video;
      }
      if (typeof this._peerCustomConfigs[targetMid].bandwidth.data === &#x27;number&#x27;) {
        bASDataBw = this._peerCustomConfigs[targetMid].bandwidth.data;
      }
    }
    if (this._peerCustomConfigs[targetMid].googleXBandwidth &amp;&amp;
      typeof this._peerCustomConfigs[targetMid].googleXBandwidth === &#x27;object&#x27;) {
      if (typeof this._peerCustomConfigs[targetMid].googleXBandwidth.min === &#x27;number&#x27;) {
        googleXMinBw = this._peerCustomConfigs[targetMid].googleXBandwidth.min;
      }
      if (typeof this._peerCustomConfigs[targetMid].googleXBandwidth.max === &#x27;number&#x27;) {
        googleXMaxBw = this._peerCustomConfigs[targetMid].googleXBandwidth.max;
      }
    }
  }

  parseFn(&#x27;audio&#x27;, bASAudioBw);
  parseFn(&#x27;video&#x27;, bASVideoBw);
  parseFn(&#x27;data&#x27;, bASDataBw);

  // Sets the experimental google bandwidth
  if ((typeof googleXMinBw === &#x27;number&#x27;) || (typeof googleXMaxBw === &#x27;number&#x27;)) {
    var codec = null;
    var codecRtpMapLineIndex = -1;
    var codecFmtpLineIndex = -1;

    for (var j = 0; j &lt; sdpLines.length; j++) {
      if (sdpLines[j].indexOf(&#x27;m=video&#x27;) === 0) {
        codec = sdpLines[j].split(&#x27; &#x27;)[3];
      } else if (codec) {
        if (sdpLines[j].indexOf(&#x27;m=&#x27;) === 0) {
          break;
        }

        if (sdpLines[j].indexOf(&#x27;a=rtpmap:&#x27; + codec + &#x27; &#x27;) === 0) {
          codecRtpMapLineIndex = j;
        } else if (sdpLines[j].indexOf(&#x27;a=fmtp:&#x27; + codec + &#x27; &#x27;) === 0) {
          sdpLines[j] = sdpLines[j].replace(/x-google-(min|max)-bitrate=[0-9]*[;]*/gi, &#x27;&#x27;);
          codecFmtpLineIndex = j;
          break;
        }
      }
    }

    if (codecRtpMapLineIndex &gt; -1) {
      var xGoogleParams = &#x27;&#x27;;

      if (typeof googleXMinBw === &#x27;number&#x27;) {
        xGoogleParams += &#x27;x-google-min-bitrate=&#x27; + googleXMinBw + &#x27;;&#x27;;
      }

      if (typeof googleXMaxBw === &#x27;number&#x27;) {
        xGoogleParams += &#x27;x-google-max-bitrate=&#x27; + googleXMaxBw + &#x27;;&#x27;;
      }

      log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Limiting x-google-bitrate -&gt;&#x27;], xGoogleParams);

      if (codecFmtpLineIndex &gt; -1) {
        sdpLines[codecFmtpLineIndex] += (sdpLines[codecFmtpLineIndex].split(&#x27; &#x27;)[1] ? &#x27;;&#x27; : &#x27;&#x27;) + xGoogleParams;
      } else {
        sdpLines.splice(codecRtpMapLineIndex + 1, 0, &#x27;a=fmtp:&#x27; + codec + &#x27; &#x27; + xGoogleParams);
      }
    }
  }

  return sdpLines.join(&#x27;\r\n&#x27;);
};

/**
 * Function that modifies the session description to set the preferred audio/video codec.
 * @method _setSDPCodec
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._setSDPCodec = function(targetMid, sessionDescription, overrideSettings) {
  var self = this;
  var parseFn = function (type, codecSettings) {
    var codec = typeof codecSettings === &#x27;object&#x27; ? codecSettings.codec : codecSettings;
    var samplingRate = typeof codecSettings === &#x27;object&#x27; ? codecSettings.samplingRate : null;
    var channels = typeof codecSettings === &#x27;object&#x27; ? codecSettings.channels : null;

    if (codec === self[type === &#x27;audio&#x27; ? &#x27;AUDIO_CODEC&#x27; : &#x27;VIDEO_CODEC&#x27;].AUTO) {
      log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
        &#x27;Not preferring any codec for &quot;&#x27; + type + &#x27;&quot; streaming. Using browser selection.&#x27;]);
      return;
    }

    var mLine = sessionDescription.sdp.match(new RegExp(&#x27;m=&#x27; + type + &#x27; .*\r\n&#x27;, &#x27;gi&#x27;));

    if (!(Array.isArray(mLine) &amp;&amp; mLine.length &gt; 0)) {
      log.error([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
        &#x27;Not preferring any codec for &quot;&#x27; + type + &#x27;&quot; streaming as m= line is not found.&#x27;]);
      return;
    }

    var setLineFn = function (codecsList, isSROk, isChnlsOk) {
      if (Array.isArray(codecsList) &amp;&amp; codecsList.length &gt; 0) {
        if (!isSROk) {
          samplingRate = null;
        }
        if (!isChnlsOk) {
          channels = null;
        }
        log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Preferring &quot;&#x27; +
          codec + &#x27;&quot; (samplingRate: &#x27; + (samplingRate || &#x27;n/a&#x27;) + &#x27;, channels: &#x27; +
          (channels || &#x27;n/a&#x27;) + &#x27;) for &quot;&#x27; + type + &#x27;&quot; streaming.&#x27;]);

        var line = mLine[0];
        var lineParts = line.replace(&#x27;\r\n&#x27;, &#x27;&#x27;).split(&#x27; &#x27;);
        // Set the m=x x UDP/xxx
        line = lineParts[0] + &#x27; &#x27; + lineParts[1] + &#x27; &#x27; + lineParts[2] + &#x27; &#x27;;
        // Remove them to leave the codecs only
        lineParts.splice(0, 3);
        // Loop for the codecs list to append first
        for (var i = 0; i &lt; codecsList.length; i++) {
          var parts = (codecsList[i].split(&#x27;a=rtpmap:&#x27;)[1] || &#x27;&#x27;).split(&#x27; &#x27;);
          if (parts.length &lt; 2) {
            continue;
          }
          line += parts[0] + &#x27; &#x27;;
        }
        // Loop for later fallback codecs to append
        for (var j = 0; j &lt; lineParts.length; j++) {
          if (line.indexOf(&#x27; &#x27; + lineParts[j]) &gt; 0) {
            lineParts.splice(j, 1);
            j--;
          } else if (sessionDescription.sdp.match(new RegExp(&#x27;a=rtpmap:&#x27; + lineParts[j] +
            &#x27;\ &#x27; + codec + &#x27;/.*\r\n&#x27;, &#x27;gi&#x27;))) {
            line += lineParts[j] + &#x27; &#x27;;
            lineParts.splice(j, 1);
            j--;
          }
        }
        // Append the rest of the codecs
        line += lineParts.join(&#x27; &#x27;) + &#x27;\r\n&#x27;;
        sessionDescription.sdp = sessionDescription.sdp.replace(mLine[0], line);
        return true;
      }
    };

    // If samplingRate &amp; channels
    if (samplingRate) {
      if (type === &#x27;audio&#x27; &amp;&amp; channels &amp;&amp; setLineFn(sessionDescription.sdp.match(new RegExp(&#x27;a=rtpmap:.*\ &#x27; +
        codec + &#x27;\/&#x27; + samplingRate + (channels === 1 ? &#x27;[\/1]*&#x27; : &#x27;\/&#x27; + channels) + &#x27;\r\n&#x27;, &#x27;gi&#x27;)), true, true)) {
        return;
      } else if (setLineFn(sessionDescription.sdp.match(new RegExp(&#x27;a=rtpmap:.*\ &#x27; + codec + &#x27;\/&#x27; +
        samplingRate + &#x27;[\/]*.*\r\n&#x27;, &#x27;gi&#x27;)), true)) {
        return;
      }
    }
    if (type === &#x27;audio&#x27; &amp;&amp; channels &amp;&amp; setLineFn(sessionDescription.sdp.match(new RegExp(&#x27;a=rtpmap:.*\ &#x27; +
      codec + &#x27;\/.*\/&#x27; + channels + &#x27;\r\n&#x27;, &#x27;gi&#x27;)), false, true)) {
      return;
    }

    setLineFn(sessionDescription.sdp.match(new RegExp(&#x27;a=rtpmap:.*\ &#x27; + codec + &#x27;\/.*\r\n&#x27;, &#x27;gi&#x27;)));
  };

  parseFn(&#x27;audio&#x27;, overrideSettings ? overrideSettings.audio : self._initOptions.audioCodec);
  parseFn(&#x27;video&#x27;, overrideSettings ? overrideSettings.video : self._initOptions.videoCodec);

  return sessionDescription.sdp;
};

/**
 * Function that modifies the session description to remove the previous experimental H264
 * codec that is apparently breaking connections.
 * NOTE: We should perhaps not remove it since H264 is supported?
 * @method _removeSDPFirefoxH264Pref
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._removeSDPFirefoxH264Pref = function(targetMid, sessionDescription) {
  log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
    &#x27;Removing Firefox experimental H264 flag to ensure interopability reliability&#x27;]);

  return sessionDescription.sdp.replace(/a=fmtp:0 profile-level-id=0x42e00c;packetization-mode=1\r\n/g, &#x27;&#x27;);
};

/**
 * Function that modifies the session description to remove the urn:3gpp:video-orientation
 * @method _removeSDPVideoRotation
 * @private
 * @for Skylink
 * @since 0.6.38
 */
Skylink.prototype._removeSDPVideoRotation = function(targetMid, sessionDescription) {
  log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
    &#x27;Removing chrome urn:3gpp:video-orientation&#x27;]);

  return sessionDescription.sdp.replace(/a=extmap:\d+ urn:3gpp:video-orientation(:\d)?\r\n/g, &#x27;&#x27;);
};

/**
 * Function that modifies the session description to remove apt/rtx lines that does exists.
 * @method _removeSDPUnknownAptRtx
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._removeSDPUnknownAptRtx = function (targetMid, sessionDescription) {
  var codecsPayload = []; // m=audio 9 UDP/TLS/RTP/SAVPF [Start from index 3] 102 9 0 8 97 13 118 101
  var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);
  var mediaLines = sessionDescription.sdp.split(&#x27;m=&#x27;);

  // Remove unmapped rtx lines
  var formatRtx = function (str) {
    (str.match(/a=rtpmap:.*\ rtx\/.*\r\n/gi) || []).forEach(function (line) {
      var payload = (line.split(&#x27;a=rtpmap:&#x27;)[1] || &#x27;&#x27;).split(&#x27; &#x27;)[0] || &#x27;&#x27;;
      var fmtpLine = (str.match(new RegExp(&#x27;a=fmtp:&#x27; + payload + &#x27;\ .*\r\n&#x27;, &#x27;gi&#x27;)) || [])[0];

      if (!fmtpLine) {
        str = str.replace(new RegExp(line, &#x27;g&#x27;), &#x27;&#x27;);
        return;
      }

      var codecPayload = (fmtpLine.split(&#x27; apt=&#x27;)[1] || &#x27;&#x27;).replace(/\r\n/gi, &#x27;&#x27;);
      var rtmpLine = str.match(new RegExp(&#x27;a=rtpmap:&#x27; + codecPayload + &#x27;\ .*\r\n&#x27;, &#x27;gi&#x27;));

      if (!rtmpLine) {
        str = str.replace(new RegExp(line, &#x27;g&#x27;), &#x27;&#x27;);
        str = str.replace(new RegExp(fmtpLine, &#x27;g&#x27;), &#x27;&#x27;);
      }
    });

    return str;
  };

  // Remove unmapped fmtp and rtcp-fb lines
  var formatFmtpRtcpFb = function (str) {
    (str.match(/a=(fmtp|rtcp-fb):.*\ rtx\/.*\r\n/gi) || []).forEach(function (line) {
      var payload = (line.split(&#x27;a=&#x27; + (line.indexOf(&#x27;rtcp&#x27;) &gt; 0 ? &#x27;rtcp-fb&#x27; : &#x27;fmtp&#x27;))[1] || &#x27;&#x27;).split(&#x27; &#x27;)[0] || &#x27;&#x27;;
      var rtmpLine = str.match(new RegExp(&#x27;a=rtpmap:&#x27; + payload + &#x27;\ .*\r\n&#x27;, &#x27;gi&#x27;));

      if (!rtmpLine) {
        str = str.replace(new RegExp(line, &#x27;g&#x27;), &#x27;&#x27;);
      }
    });

    return str;
  };

  // Remove rtx or apt= lines that prevent connections for browsers without VP8 or VP9 support
  // See: https://bugs.chromium.org/p/webrtc/issues/detail?id=3962
  for (var m = 0; m &lt; mediaLines.length; m++) {
    mediaLines[m] = formatRtx(mediaLines[m]);
    mediaLines[m] = formatFmtpRtcpFb(mediaLines[m]);
  }

  return mediaLines.join(&#x27;m=&#x27;);
};

/**
 * Function that modifies the session description to remove codecs.
 * @method _removeSDPCodecs
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._removeSDPCodecs = function (targetMid, sessionDescription) {
  var audioSettings = this.getPeerInfo().settings.audio;

  var parseFn = function (type, codec) {
    var payloadList = sessionDescription.sdp.match(new RegExp(&#x27;a=rtpmap:(\\d*)\\ &#x27; + codec + &#x27;.*&#x27;, &#x27;gi&#x27;));

    if (!(Array.isArray(payloadList) &amp;&amp; payloadList.length &gt; 0)) {
      log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
        &#x27;Not removing &quot;&#x27; + codec + &#x27;&quot; as it does not exists.&#x27;]);
      return;
    }

    for (var i = 0; i &lt; payloadList.length; i++) {
      var payload = payloadList[i].split(&#x27; &#x27;)[0].split(&#x27;:&#x27;)[1];

      log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
        &#x27;Removing &quot;&#x27; + codec + &#x27;&quot; payload -&gt;&#x27;], payload);

      sessionDescription.sdp = sessionDescription.sdp.replace(
        new RegExp(&#x27;a=rtpmap:&#x27; + payload + &#x27;\\ .*\\r\\n&#x27;, &#x27;g&#x27;), &#x27;&#x27;);
      sessionDescription.sdp = sessionDescription.sdp.replace(
        new RegExp(&#x27;a=fmtp:&#x27; + payload + &#x27;\\ .*\\r\\n&#x27;, &#x27;g&#x27;), &#x27;&#x27;);
      sessionDescription.sdp = sessionDescription.sdp.replace(
        new RegExp(&#x27;a=rtpmap:\\d+ rtx\\/\\d+\\r\\na=fmtp:\\d+ apt=&#x27; + payload + &#x27;\\r\\n&#x27;, &#x27;g&#x27;), &#x27;&#x27;);

      // Remove the m-line codec
      var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);

      for (var j = 0; j &lt; sdpLines.length; j++) {
        if (sdpLines[j].indexOf(&#x27;m=&#x27; + type) === 0) {
          var parts = sdpLines[j].split(&#x27; &#x27;);

          if (parts.indexOf(payload) &gt;= 3) {
            parts.splice(parts.indexOf(payload), 1);
          }

          sdpLines[j] = parts.join(&#x27; &#x27;);
          break;
        }
      }

      sessionDescription.sdp = sdpLines.join(&#x27;\r\n&#x27;);
    }
  };

  if (this._initOptions.disableVideoFecCodecs) {
    if (this._hasMCU) {
      log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
        &#x27;Not removing &quot;ulpfec&quot; or &quot;red&quot; codecs as connected to MCU to prevent connectivity issues.&#x27;]);
    } else {
      parseFn(&#x27;video&#x27;, &#x27;red&#x27;);
      parseFn(&#x27;video&#x27;, &#x27;ulpfec&#x27;);
    }
  }

  if (this._initOptions.disableComfortNoiseCodec &amp;&amp; audioSettings &amp;&amp; typeof audioSettings === &#x27;object&#x27; &amp;&amp; audioSettings.stereo) {
    parseFn(&#x27;audio&#x27;, &#x27;CN&#x27;);
  }

  if (window.webrtcDetectedBrowser === &#x27;edge&#x27; &amp;&amp;
    (((this._peerInformations[targetMid] || {}).agent || {}).name || &#x27;unknown&#x27;).name !== &#x27;edge&#x27;) {
    sessionDescription.sdp = sessionDescription.sdp.replace(/a=rtcp-fb:.*\ x-message\ .*\r\n/gi, &#x27;&#x27;);
  }

  return sessionDescription.sdp;
};

/**
 * Function that modifies the session description to remove REMB packets fb.
 * @method _removeSDPREMBPackets
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._removeSDPREMBPackets = function (targetMid, sessionDescription) {
  if (!this._initOptions.disableREMB) {
    return sessionDescription.sdp;
  }

  log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Removing REMB packets.&#x27;]);
  return sessionDescription.sdp.replace(/a=rtcp-fb:\d+ goog-remb\r\n/g, &#x27;&#x27;);
};

/**
 * Function that modifies the session description to remove transport-cc packets fb.
 * @method _removeSDPTransportCCPackets
 * @private
 * @for Skylink
 * @since 0.6.38
 */

Skylink.prototype._removeSDPTransportCCPackets = function (targetMid, sessionDescription) {
  log.info([targetMid, &#x27;RTCSessionDescription&#x27;, sessionDescription.type, &#x27;Removing transport-cc packets.&#x27;]);
  return sessionDescription.sdp.replace(/a=rtcp-fb:\d+ transport-cc\r\n/g, &#x27;&#x27;);
};
/**
 * Function that retrieves the session description selected codec.
 * @method _getSDPSelectedCodec
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._getSDPSelectedCodec = function (targetMid, sessionDescription, type, beSilentOnLogs) {
  var codecInfo = {
    name: null,
    implementation: null,
    clockRate: null,
    channels: null,
    payloadType: null,
    params: null
  };

  if (!(sessionDescription &amp;&amp; sessionDescription.sdp)) {
    return codecInfo;
  }

  sessionDescription.sdp.split(&#x27;m=&#x27;).forEach(function (mediaItem, index) {
    if (index === 0 || mediaItem.indexOf(type + &#x27; &#x27;) !== 0) {
      return;
    }

    var codecs = (mediaItem.split(&#x27;\r\n&#x27;)[0] || &#x27;&#x27;).split(&#x27; &#x27;);
    // Remove audio[0] 65266[1] UDP/TLS/RTP/SAVPF[2]
    codecs.splice(0, 3);

    for (var i = 0; i &lt; codecs.length; i++) {
      var match = mediaItem.match(new RegExp(&#x27;a=rtpmap:&#x27; + codecs[i] + &#x27;.*\r\n&#x27;, &#x27;gi&#x27;));

      if (!match) {
        continue;
      }

      // Format: codec/clockRate/channels
      var parts = ((match[0] || &#x27;&#x27;).replace(/\r\n/g, &#x27;&#x27;).split(&#x27; &#x27;)[1] || &#x27;&#x27;).split(&#x27;/&#x27;);

      // Ignore rtcp codecs, dtmf or comfort noise
      if ([&#x27;red&#x27;, &#x27;ulpfec&#x27;, &#x27;telephone-event&#x27;, &#x27;cn&#x27;, &#x27;rtx&#x27;].indexOf(parts[0].toLowerCase()) &gt; -1) {
        continue;
      }

      codecInfo.name = parts[0];
      codecInfo.clockRate = parseInt(parts[1], 10) || 0;
      codecInfo.channels = parseInt(parts[2] || &#x27;1&#x27;, 10) || 1;
      codecInfo.payloadType = parseInt(codecs[i], 10);
      codecInfo.params = &#x27;&#x27;;

      // Get the list of codec parameters
      var params = mediaItem.match(new RegExp(&#x27;a=fmtp:&#x27; + codecs[i] + &#x27;.*\r\n&#x27;, &#x27;gi&#x27;)) || [];
      params.forEach(function (paramItem) {
        codecInfo.params += paramItem.replace(new RegExp(&#x27;a=fmtp:&#x27; + codecs[i], &#x27;gi&#x27;), &#x27;&#x27;).replace(/\ /g, &#x27;&#x27;).replace(/\r\n/g, &#x27;&#x27;);
      });
      break;
    }
  });

  if (!beSilentOnLogs) {
    log.debug([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
      &#x27;Parsing session description &quot;&#x27; + type + &#x27;&quot; codecs -&gt;&#x27;], codecInfo);
  }

  return codecInfo;
};

/**
 * Function that modifies the session description to remove non-relay ICE candidates.
 * @method _removeSDPFilteredCandidates
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._removeSDPFilteredCandidates = function (targetMid, sessionDescription) {
  // Handle Firefox MCU Peer ICE candidates
  if (targetMid === &#x27;MCU&#x27; &amp;&amp; sessionDescription.type === this.HANDSHAKE_PROGRESS.ANSWER &amp;&amp;
    window.webrtcDetectedBrowser === &#x27;firefox&#x27;) {
    sessionDescription.sdp = sessionDescription.sdp.replace(/ generation 0/g, &#x27;&#x27;);
    sessionDescription.sdp = sessionDescription.sdp.replace(/ udp /g, &#x27; UDP &#x27;);
  }

  if (this._initOptions.forceTURN &amp;&amp; this._hasMCU) {
    log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Not filtering ICE candidates as &#x27; +
      &#x27;TURN connections are enforced as MCU is present (and act as a TURN itself) so filtering of ICE candidate &#x27; +
      &#x27;flags are not honoured&#x27;]);
    return sessionDescription.sdp;
  }

  if (this._initOptions.filterCandidatesType.host) {
    log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Removing &quot;host&quot; ICE candidates.&#x27;]);
    sessionDescription.sdp = sessionDescription.sdp.replace(/a=candidate:.*host.*\r\n/g, &#x27;&#x27;);
  }

  if (this._initOptions.filterCandidatesType.srflx) {
    log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Removing &quot;srflx&quot; ICE candidates.&#x27;]);
    sessionDescription.sdp = sessionDescription.sdp.replace(/a=candidate:.*srflx.*\r\n/g, &#x27;&#x27;);
  }

  if (this._initOptions.filterCandidatesType.relay) {
    log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Removing &quot;relay&quot; ICE candidates.&#x27;]);
    sessionDescription.sdp = sessionDescription.sdp.replace(/a=candidate:.*relay.*\r\n/g, &#x27;&#x27;);
  }

  // sessionDescription.sdp = sessionDescription.sdp.replace(/a=candidate:(?!.*relay.*).*\r\n/g, &#x27;&#x27;);

  return sessionDescription.sdp;
};

/**
 * Function that retrieves the current list of support codecs.
 * @method _getCodecsSupport
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._getCodecsSupport = function (callback) {
  var self = this;

  if (self._currentCodecSupport) {
    callback(null);
    return;
  }

  self._currentCodecSupport = { audio: {}, video: {} };

  // Safari 11 REQUIRES a stream first before connection works, hence let&#x27;s spoof it for now
  if (AdapterJS.webrtcDetectedType === &#x27;AppleWebKit&#x27;) {
    self._currentCodecSupport.audio = {
      opus: [&#x27;48000/2&#x27;]
    };
    self._currentCodecSupport.video = {
      h264: [&#x27;48000&#x27;]
    };
    return callback(null);
  }

  try {
    if (window.webrtcDetectedBrowser === &#x27;edge&#x27;) {
      var codecs = RTCRtpSender.getCapabilities().codecs;

      for (var i = 0; i &lt; codecs.length; i++) {
        if ([&#x27;audio&#x27;,&#x27;video&#x27;].indexOf(codecs[i].kind) &gt; -1 &amp;&amp; codecs[i].name) {
          var codec = codecs[i].name.toLowerCase();
          self._currentCodecSupport[codecs[i].kind][codec] = codecs[i].clockRate +
            (codecs[i].numChannels &gt; 1 ? &#x27;/&#x27; + codecs[i].numChannels : &#x27;&#x27;);
        }
      }
      // Ignore .fecMechanisms for now
      callback(null);

    } else {
      var pc = new RTCPeerConnection(null);
      var offerConstraints = AdapterJS.webrtcDetectedType !== &#x27;plugin&#x27; ? {
        offerToReceiveAudio: true,
        offerToReceiveVideo: true
      } : {
        mandatory: {
          OfferToReceiveVideo: true,
          OfferToReceiveAudio: true
        }
      };

      // Prevent errors and proceed with create offer still...
      try {
        var channel = pc.createDataChannel(&#x27;test&#x27;);
        self._binaryChunkType = channel.binaryType || self._binaryChunkType;
        self._binaryChunkType = self._binaryChunkType.toLowerCase().indexOf(&#x27;array&#x27;) &gt; -1 ?
          self.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER : self._binaryChunkType;
        // Set the value according to the property
        for (var prop in self.DATA_TRANSFER_DATA_TYPE) {
          if (self.DATA_TRANSFER_DATA_TYPE.hasOwnProperty(prop) &amp;&amp;
            self._binaryChunkType.toLowerCase() === self.DATA_TRANSFER_DATA_TYPE[prop].toLowerCase()) {
            self._binaryChunkType = self.DATA_TRANSFER_DATA_TYPE[prop];
            break;
          }
        }
      } catch (e) {}

      pc.createOffer(function (offer) {
        self._currentCodecSupport = self._getSDPCodecsSupport(null, offer);
        callback(null);

      }, function (error) {
        callback(error);
      }, offerConstraints);
    }
  } catch (error) {
    callback(error);
  }
};

/**
 * Function that modifies the session description to handle the connection settings.
 * This is experimental and never recommended to end-users.
 * @method _handleSDPConnectionSettings
 * @private
 * @for Skylink
 * @since 0.6.16
 */
Skylink.prototype._handleSDPConnectionSettings = function (targetMid, sessionDescription, direction) {
  var self = this;

  if (!self._sdpSessions[targetMid]) {
    return sessionDescription.sdp;
  }

  var sessionDescriptionStr = sessionDescription.sdp;

  // Handle a=end-of-candidates signaling for non-trickle ICE before setting remote session description
  if (direction === &#x27;remote&#x27; &amp;&amp; !self.getPeerInfo(targetMid).config.enableIceTrickle) {
    sessionDescriptionStr = sessionDescriptionStr.replace(/a=end-of-candidates\r\n/g, &#x27;&#x27;);
  }

  var sdpLines = sessionDescriptionStr.split(&#x27;\r\n&#x27;);
  var peerAgent = ((self._peerInformations[targetMid] || {}).agent || {}).name || &#x27;&#x27;;
  var peerVersion = ((self._peerInformations[targetMid] || {}).agent || {}).version || 0;
  var mediaType = &#x27;&#x27;;
  var bundleLineIndex = -1;
  var bundleLineMids = [];
  var mLineIndex = -1;
  var settings = clone(self._sdpSettings);

  if (targetMid === &#x27;MCU&#x27;) {
    settings.connection.audio = true;
    settings.connection.video = true;
    settings.connection.data = true;
  }

  // Patches for MCU sending empty video stream despite audio+video is not sending at all
  // Apply as a=inactive when supported
  if (self._hasMCU) {
    var peerStreamSettings = clone(self.getPeerInfo(targetMid)).settings || {};
    settings.direction.audio.receive = targetMid === &#x27;MCU&#x27; ? false : !!peerStreamSettings.audio;
    settings.direction.audio.send = targetMid === &#x27;MCU&#x27; ? true : false;
    settings.direction.video.receive = targetMid === &#x27;MCU&#x27; ? false : !!peerStreamSettings.video;
    settings.direction.video.send = targetMid === &#x27;MCU&#x27; ? true : false;
  }

  if (direction === &#x27;remote&#x27;) {
    var offerCodecs = self._getSDPCommonSupports(targetMid, sessionDescription);

    if (!offerCodecs.audio) {
      settings.connection.audio = false;
    }

    if (!offerCodecs.video) {
      settings.connection.video = false;
    }
  }

  // ANSWERER: Reject only the m= lines. Returned rejected m= lines as well.
  // OFFERER: Remove m= lines

  self._sdpSessions[targetMid][direction].mLines = [];
  self._sdpSessions[targetMid][direction].bundleLine = &#x27;&#x27;;
  self._sdpSessions[targetMid][direction].connection = {
    audio: null,
    video: null,
    data: null
  };

  for (var i = 0; i &lt; sdpLines.length; i++) {
    // Cache the a=group:BUNDLE line used for remote answer from Edge later
    if (sdpLines[i].indexOf(&#x27;a=group:BUNDLE&#x27;) === 0) {
      self._sdpSessions[targetMid][direction].bundleLine = sdpLines[i];
      bundleLineIndex = i;

    // Check if there&#x27;s a need to reject m= line
    } else if (sdpLines[i].indexOf(&#x27;m=&#x27;) === 0) {
      mediaType = (sdpLines[i].split(&#x27;m=&#x27;)[1] || &#x27;&#x27;).split(&#x27; &#x27;)[0] || &#x27;&#x27;;
      mediaType = mediaType === &#x27;application&#x27; ? &#x27;data&#x27; : mediaType;
      mLineIndex++;

      self._sdpSessions[targetMid][direction].mLines[mLineIndex] = sdpLines[i];

      // Check if there is missing unsupported video codecs support and reject it regardles of MCU Peer or not
      if (!settings.connection[mediaType]) {
        log.log([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
          &#x27;Removing rejected m=&#x27; + mediaType + &#x27; line -&gt;&#x27;], sdpLines[i]);

        // Check if answerer and we do not have the power to remove the m line if index is 0
        // Set as a=inactive because we do not have that power to reject it somehow..
        // first m= line cannot be rejected for BUNDLE
        if (self._peerConnectionConfig.bundlePolicy === self.BUNDLE_POLICY.MAX_BUNDLE &amp;&amp;
          bundleLineIndex &gt; -1 &amp;&amp; mLineIndex === 0 &amp;&amp; (direction === &#x27;remote&#x27; ?
          sessionDescription.type === this.HANDSHAKE_PROGRESS.OFFER :
          sessionDescription.type === this.HANDSHAKE_PROGRESS.ANSWER)) {
          log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
            &#x27;Not removing rejected m=&#x27; + mediaType + &#x27; line -&gt;&#x27;], sdpLines[i]);
          settings.connection[mediaType] = true;
          if ([&#x27;audio&#x27;, &#x27;video&#x27;].indexOf(mediaType) &gt; -1) {
            settings.direction[mediaType].send = false;
            settings.direction[mediaType].receive = false;
          }
          continue;
        }

        if (window.webrtcDetectedBrowser === &#x27;edge&#x27;) {
          sdpLines.splice(i, 1);
          i--;
          continue;
        } else if (direction === &#x27;remote&#x27; || sessionDescription.type === this.HANDSHAKE_PROGRESS.ANSWER) {
          var parts = sdpLines[i].split(&#x27; &#x27;);
          parts[1] = 0;
          sdpLines[i] = parts.join(&#x27; &#x27;);
          continue;
        }
      }
    }

    if (direction === &#x27;remote&#x27; &amp;&amp; sdpLines[i].indexOf(&#x27;a=candidate:&#x27;) === 0 &amp;&amp;
      !self.getPeerInfo(targetMid).config.enableIceTrickle) {
      if (sdpLines[i + 1] ? !(sdpLines[i + 1].indexOf(&#x27;a=candidate:&#x27;) === 0 ||
        sdpLines[i + 1].indexOf(&#x27;a=end-of-candidates&#x27;) === 0) : true) {
        log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
          &#x27;Appending end-of-candidates signal for non-trickle ICE connection.&#x27;]);
        sdpLines.splice(i + 1, 0, &#x27;a=end-of-candidates&#x27;);
        i++;
      }
    }

    if (mediaType) {
      // Remove lines if we are rejecting the media and ensure unless (rejectVideoMedia is true), MCU has to enable those m= lines
      if (!settings.connection[mediaType]) {
        sdpLines.splice(i, 1);
        i--;

      // Store the mids session description
      } else if (sdpLines[i].indexOf(&#x27;a=mid:&#x27;) === 0) {
        bundleLineMids.push(sdpLines[i].split(&#x27;a=mid:&#x27;)[1] || &#x27;&#x27;);

      // Configure direction a=sendonly etc for local sessiondescription
      }  else if (mediaType &amp;&amp; [&#x27;a=sendrecv&#x27;, &#x27;a=sendonly&#x27;, &#x27;a=recvonly&#x27;].indexOf(sdpLines[i]) &gt; -1) {
        if ([&#x27;audio&#x27;, &#x27;video&#x27;].indexOf(mediaType) === -1) {
          self._sdpSessions[targetMid][direction].connection.data = sdpLines[i];
          continue;
        }

        if (direction === &#x27;local&#x27;) {
          if (settings.direction[mediaType].send &amp;&amp; !settings.direction[mediaType].receive) {
            sdpLines[i] = sdpLines[i].indexOf(&#x27;send&#x27;) &gt; -1 ? &#x27;a=sendonly&#x27; : &#x27;a=inactive&#x27;;
          } else if (!settings.direction[mediaType].send &amp;&amp; settings.direction[mediaType].receive) {
            sdpLines[i] = sdpLines[i].indexOf(&#x27;recv&#x27;) &gt; -1 ? &#x27;a=recvonly&#x27; : &#x27;a=inactive&#x27;;
          } else if (!settings.direction[mediaType].send &amp;&amp; !settings.direction[mediaType].receive) {
          // MCU currently does not support a=inactive flag.. what do we do here?
            sdpLines[i] = &#x27;a=inactive&#x27;;
          }

          // Handle Chrome bundle bug. - See: https://bugs.chromium.org/p/webrtc/issues/detail?id=6280
          if (!self._hasMCU &amp;&amp; window.webrtcDetectedBrowser !== &#x27;firefox&#x27; &amp;&amp; peerAgent === &#x27;firefox&#x27; &amp;&amp;
            sessionDescription.type === self.HANDSHAKE_PROGRESS.OFFER &amp;&amp; sdpLines[i] === &#x27;a=recvonly&#x27;) {
            log.warn([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Overriding any original settings &#x27; +
              &#x27;to receive only to send and receive to resolve chrome BUNDLE errors.&#x27;]);
            sdpLines[i] = &#x27;a=sendrecv&#x27;;
            settings.direction[mediaType].send = true;
            settings.direction[mediaType].receive = true;
          }
        // Patch for incorrect responses
        } else if (sessionDescription.type === self.HANDSHAKE_PROGRESS.ANSWER) {
          var localOfferRes = self._sdpSessions[targetMid].local.connection[mediaType];
          // Parse a=sendonly response
          if (localOfferRes === &#x27;a=sendonly&#x27;) {
            sdpLines[i] = [&#x27;a=inactive&#x27;, &#x27;a=recvonly&#x27;].indexOf(sdpLines[i]) === -1 ?
              (sdpLines[i] === &#x27;a=sendonly&#x27; ? &#x27;a=inactive&#x27; : &#x27;a=recvonly&#x27;) : sdpLines[i];
          // Parse a=recvonly
          } else if (localOfferRes === &#x27;a=recvonly&#x27;) {
            sdpLines[i] = [&#x27;a=inactive&#x27;, &#x27;a=sendonly&#x27;].indexOf(sdpLines[i]) === -1 ?
              (sdpLines[i] === &#x27;a=recvonly&#x27; ? &#x27;a=inactive&#x27; : &#x27;a=sendonly&#x27;) : sdpLines[i];
          // Parse a=sendrecv
          } else if (localOfferRes === &#x27;a=inactive&#x27;) {
            sdpLines[i] = &#x27;a=inactive&#x27;;
          }
        }
        self._sdpSessions[targetMid][direction].connection[mediaType] = sdpLines[i];
      }
    }

    // Remove weird empty characters for Edge case.. :(
    if (!(sdpLines[i] || &#x27;&#x27;).replace(/\n|\r|\s|\ /gi, &#x27;&#x27;)) {
      sdpLines.splice(i, 1);
      i--;
    }
  }

  // Fix chrome &quot;offerToReceiveAudio&quot; local offer not removing audio BUNDLE
  if (bundleLineIndex &gt; -1) {
    if (self._peerConnectionConfig.bundlePolicy === self.BUNDLE_POLICY.MAX_BUNDLE) {
      sdpLines[bundleLineIndex] = &#x27;a=group:BUNDLE &#x27; + bundleLineMids.join(&#x27; &#x27;);
    // Remove a=group:BUNDLE line
    } else if (self._peerConnectionConfig.bundlePolicy === self.BUNDLE_POLICY.NONE) {
      sdpLines.splice(bundleLineIndex, 1);
    }
  }

  // Append empty space below
  if (window.webrtcDetectedBrowser !== &#x27;edge&#x27;) {
    if (!sdpLines[sdpLines.length - 1].replace(/\n|\r|\s/gi, &#x27;&#x27;)) {
      sdpLines[sdpLines.length - 1] = &#x27;&#x27;;
    } else {
      sdpLines.push(&#x27;&#x27;);
    }
  }

  log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Handling connection lines and direction -&gt;&#x27;], settings);

  return sdpLines.join(&#x27;\r\n&#x27;);
};

/**
 * Function that parses and retrieves the session description fingerprint.
 * @method _getSDPFingerprint
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._getSDPFingerprint = function (targetMid, sessionDescription, beSilentOnLogs) {
  var fingerprint = {
    fingerprint: null,
    fingerprintAlgorithm: null,
    derBase64: null
  };

  if (!(sessionDescription &amp;&amp; sessionDescription.sdp)) {
    return fingerprint;
  }

  var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);

  for (var i = 0; i &lt; sdpLines.length; i++) {
    if (sdpLines[i].indexOf(&#x27;a=fingerprint&#x27;) === 0) {
      var parts = sdpLines[i].replace(&#x27;a=fingerprint:&#x27;, &#x27;&#x27;).split(&#x27; &#x27;);
      fingerprint.fingerprint = parts[1];
      fingerprint.fingerprintAlgorithm = parts[0];
      break;
    }
  }

  if (!beSilentOnLogs) {
    log.debug([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
      &#x27;Parsing session description fingerprint -&gt;&#x27;], fingerprint);
  }

  return fingerprint;
};

/**
 * Function that modifies the session description to append the MediaStream and MediaStreamTrack IDs that seems
 * to be missing from Firefox answer session description to Chrome connection causing freezes in re-negotiation.
 * @method _renderSDPOutput
 * @private
 * @for Skylink
 * @since 0.6.25
 */
Skylink.prototype._renderSDPOutput = function (targetMid, sessionDescription) {
  var self = this;
  var localStream = null;
  var localStreamId = null;

  if (!(sessionDescription &amp;&amp; sessionDescription.sdp)) {
    return;
  }

  if (!self._peerConnections[targetMid]) {
    return sessionDescription.sdp;
  }

  if (self._peerConnections[targetMid].localStream) {
    localStream = self._peerConnections[targetMid].localStream;
    localStreamId = self._peerConnections[targetMid].localStreamId || self._peerConnections[targetMid].localStream.id;
  }

  // For non-trickle ICE, remove the a=end-of-candidates line first to append it properly later
  var sdpLines = (!self._initOptions.enableIceTrickle ? sessionDescription.sdp.replace(/a=end-of-candidates\r\n/g, &#x27;&#x27;) : sessionDescription.sdp).split(&#x27;\r\n&#x27;);
  var agent = ((self._peerInformations[targetMid] || {}).agent || {}).name || &#x27;&#x27;;

  // Parse and replace with the correct msid to prevent unwanted streams.
  // Making it simple without replacing with the track IDs or labels, neither setting prefixing &quot;mslabel&quot; and &quot;label&quot; as required labels.
  if (localStream) {
    var ssrcId = null;
    var mediaType = &#x27;&#x27;;

    for (var i = 0; i &lt; sdpLines.length; i++) {
      if (sdpLines[i].indexOf(&#x27;m=&#x27;) === 0) {
        mediaType = (sdpLines[i].split(&#x27;m=&#x27;)[1] || &#x27;&#x27;).split(&#x27; &#x27;)[0] || &#x27;&#x27;;
        mediaType = [&#x27;audio&#x27;, &#x27;video&#x27;].indexOf(mediaType) === -1 ? &#x27;&#x27; : mediaType;

      } else if (mediaType) {
        if (sdpLines[i].indexOf(&#x27;a=msid:&#x27;) === 0) {
          var msidParts = sdpLines[i].split(&#x27; &#x27;);
          msidParts[0] = &#x27;a=msid:&#x27; + localStreamId;
          sdpLines[i] = msidParts.join(&#x27; &#x27;);

        } else if (sdpLines[i].indexOf(&#x27;a=ssrc:&#x27;) === 0) {
          var ssrcParts = null;

          // Replace for &quot;msid:&quot; and &quot;mslabel:&quot;
          if (sdpLines[i].indexOf(&#x27; msid:&#x27;) &gt; 0) {
            ssrcParts = sdpLines[i].split(&#x27; msid:&#x27;);
          } else if (sdpLines[i].indexOf(&#x27; mslabel:&#x27;) &gt; 0) {
            ssrcParts = sdpLines[i].split(&#x27; mslabel:&#x27;);
          }

          if (ssrcParts) {
            var ssrcMsidParts = (ssrcParts[1] || &#x27;&#x27;).split(&#x27; &#x27;);
            ssrcMsidParts[0] = localStreamId;
            ssrcParts[1] = ssrcMsidParts.join(&#x27; &#x27;);

            if (sdpLines[i].indexOf(&#x27; msid:&#x27;) &gt; 0) {
              sdpLines[i] = ssrcParts.join(&#x27; msid:&#x27;);
            } else if (sdpLines[i].indexOf(&#x27; mslabel:&#x27;) &gt; 0) {
              sdpLines[i] = ssrcParts.join(&#x27; mslabel:&#x27;);
            }
          }
        }
      }
    }
  }

  // For non-trickle ICE, append the signaling of end-of-candidates properly
  if (!self._initOptions.enableIceTrickle){
    log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
      &#x27;Appending end-of-candidates signal for non-trickle ICE connection.&#x27;]);

    for (var e = 0; e &lt; sdpLines.length; e++) {
      if (sdpLines[e].indexOf(&#x27;a=candidate:&#x27;) === 0) {
        if (sdpLines[e + 1] ? !(sdpLines[e + 1].indexOf(&#x27;a=candidate:&#x27;) === 0 ||
          sdpLines[e + 1].indexOf(&#x27;a=end-of-candidates&#x27;) === 0) : true) {
          sdpLines.splice(e + 1, 0, &#x27;a=end-of-candidates&#x27;);
          e++;
        }
      }
    }
  }

  // Replace the bundle policy to prevent complete removal of m= lines for some cases that do not accept missing m= lines except edge.
  if (sessionDescription.type === this.HANDSHAKE_PROGRESS.ANSWER &amp;&amp; this._sdpSessions[targetMid]) {
    var bundleLineIndex = -1;
    var mLineIndex = -1;

    for (var j = 0; j &lt; sdpLines.length; j++) {
      if (sdpLines[j].indexOf(&#x27;a=group:BUNDLE&#x27;) === 0 &amp;&amp; this._sdpSessions[targetMid].remote.bundleLine &amp;&amp;
        this._peerConnectionConfig.bundlePolicy === this.BUNDLE_POLICY.MAX_BUNDLE) {
        sdpLines[j] = this._sdpSessions[targetMid].remote.bundleLine;
      } else if (sdpLines[j].indexOf(&#x27;m=&#x27;) === 0) {
        mLineIndex++;
        var compareA = sdpLines[j].split(&#x27; &#x27;);
        var compareB = (this._sdpSessions[targetMid].remote.mLines[mLineIndex] || &#x27;&#x27;).split(&#x27; &#x27;);

        if (compareA[0] &amp;&amp; compareB[0] &amp;&amp; compareA[0] !== compareB[0]) {
          compareB[1] = 0;
          log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
            &#x27;Appending middle rejected m= line -&gt;&#x27;], compareB.join(&#x27; &#x27;));
          sdpLines.splice(j, 0, compareB.join(&#x27; &#x27;));
          j++;
          mLineIndex++;
        }
      }
    }

    while (this._sdpSessions[targetMid].remote.mLines[mLineIndex + 1]) {
      mLineIndex++;
      var appendIndex = sdpLines.length;
      if (!sdpLines[appendIndex - 1].replace(/\s/gi, &#x27;&#x27;)) {
        appendIndex -= 1;
      }
      var parts = (this._sdpSessions[targetMid].remote.mLines[mLineIndex] || &#x27;&#x27;).split(&#x27; &#x27;);
      parts[1] = 0;
      log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
        &#x27;Appending later rejected m= line -&gt;&#x27;], parts.join(&#x27; &#x27;));
      sdpLines.splice(appendIndex, 0, parts.join(&#x27; &#x27;));
    }
  }

  // Ensure for chrome case to have empty &quot;&quot; at last line or it will return invalid SDP errors
  if (window.webrtcDetectedBrowser === &#x27;edge&#x27; &amp;&amp; sessionDescription.type === this.HANDSHAKE_PROGRESS.OFFER &amp;&amp;
    !sdpLines[sdpLines.length - 1].replace(/\s/gi, &#x27;&#x27;)) {
    log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Removing last empty space for Edge browsers&#x27;]);
    sdpLines.splice(sdpLines.length - 1, 1);
  }

  /*
  var outputStr = sdpLines.join(&#x27;\r\n&#x27;);
  if (window.webrtcDetectedBrowser === &#x27;edge&#x27; &amp;&amp; this._streams.userMedia &amp;&amp; this._streams.userMedia.stream) {
    var correctStreamId = this._streams.userMedia.stream.id || this._streams.userMedia.stream.label;
    outputStr = outputStr.replace(new RegExp(&#x27;a=msid:.*\ &#x27;, &#x27;gi&#x27;), &#x27;a=msid:&#x27; + correctStreamId + &#x27; &#x27;);
    outputStr = outputStr.replace(new RegExp(&#x27;\ msid:.*\ &#x27;, &#x27;gi&#x27;), &#x27; msid:&#x27; + correctStreamId + &#x27; &#x27;);
  }*/

  log.info([targetMid, &#x27;RTCSessionDescription&#x27;, sessionDescription.type, &#x27;Formatted output -&gt;&#x27;], sdpLines.join(&#x27;\r\n&#x27;));

  return sdpLines.join(&#x27;\r\n&#x27;);
};

/**
 * Function that parses the session description to get the MediaStream IDs.
 * NOTE: It might not completely accurate if the setRemoteDescription() fails..
 * @method _parseSDPMediaStreamIDs
 * @private
 * @for Skylink
 * @since 0.6.25
 */
Skylink.prototype._parseSDPMediaStreamIDs = function (targetMid, sessionDescription) {
  if (!this._peerConnections[targetMid]) {
    return;
  }

  if (!(sessionDescription &amp;&amp; sessionDescription.sdp)) {
    this._peerConnections[targetMid].remoteStreamId = null;
    return;
  }

  var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);
  var currentStreamId = null;

  for (var i = 0; i &lt; sdpLines.length; i++) {
    // a=msid:{31145dc5-b3e2-da4c-a341-315ef3ebac6b} {e0cac7dd-64a0-7447-b719-7d5bf042ca05}
    if (sdpLines[i].indexOf(&#x27;a=msid:&#x27;) === 0) {
      currentStreamId = (sdpLines[i].split(&#x27;a=msid:&#x27;)[1] || &#x27;&#x27;).split(&#x27; &#x27;)[0];
      break;
    // a=ssrc:691169016 msid:c58721ed-b7db-4e7c-ac37-47432a7a2d6f 2e27a4b8-bc74-4118-b3d4-0f1c4ed4869b
    } else if (sdpLines[i].indexOf(&#x27;a=ssrc:&#x27;) === 0 &amp;&amp; sdpLines[i].indexOf(&#x27; msid:&#x27;) &gt; 0) {
      currentStreamId = (sdpLines[i].split(&#x27; msid:&#x27;)[1] || &#x27;&#x27;).split(&#x27; &#x27;)[0];
      break;
    }
  }

  // No stream set
  if (!currentStreamId) {
    log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;No remote stream is sent.&#x27;]);
    this._peerConnections[targetMid].remoteStreamId = null;
  // New stream set
  } else if (currentStreamId !== this._peerConnections[targetMid].remoteStreamId) {
    log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;New remote stream is sent -&gt;&#x27;], currentStreamId);
    this._peerConnections[targetMid].remoteStreamId = currentStreamId;
  // Same stream set
  } else {
    log.info([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type, &#x27;Same remote stream is sent -&gt;&#x27;], currentStreamId);
  }
};

/**
 * Function that parses and retrieves the session description ICE candidates.
 * @method _getSDPICECandidates
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._getSDPICECandidates = function (targetMid, sessionDescription, beSilentOnLogs) {
  var candidates = {
    host: [],
    srflx: [],
    relay: []
  };

  if (!(sessionDescription &amp;&amp; sessionDescription.sdp)) {
    return candidates;
  }

  sessionDescription.sdp.split(&#x27;m=&#x27;).forEach(function (mediaItem, index) {
    // Ignore the v=0 lines etc..
    if (index === 0) {
      return;
    }

    // Remove a=mid: and \r\n
    var sdpMid = ((mediaItem.match(/a=mid:.*\r\n/gi) || [])[0] || &#x27;&#x27;).replace(/a=mid:/gi, &#x27;&#x27;).replace(/\r\n/, &#x27;&#x27;);
    var sdpMLineIndex = index - 1;

    (mediaItem.match(/a=candidate:.*\r\n/gi) || []).forEach(function (item) {
      // Remove \r\n for candidate type being set at the end of candidate DOM string.
      var canType = (item.split(&#x27; &#x27;)[7] || &#x27;host&#x27;).replace(/\r\n/g, &#x27;&#x27;);
      candidates[canType] = candidates[canType] || [];
      candidates[canType].push(new RTCIceCandidate({
        sdpMid: sdpMid,
        sdpMLineIndex: sdpMLineIndex,
        // Remove initial &quot;a=&quot; in a=candidate
        candidate: (item.split(&#x27;a=&#x27;)[1] || &#x27;&#x27;).replace(/\r\n/g, &#x27;&#x27;)
      }));
    });
  });

  if (!beSilentOnLogs) {
    log.debug([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
      &#x27;Parsing session description ICE candidates -&gt;&#x27;], candidates);
  }

  return candidates;
};

/**
 * Function that gets each media line SSRCs.
 * @method _getSDPMediaSSRC
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._getSDPMediaSSRC = function (targetMid, sessionDescription, beSilentOnLogs) {
  var ssrcs = {
    audio: 0,
    video: 0
  };

  if (!(sessionDescription &amp;&amp; sessionDescription.sdp)) {
    return ssrcs;
  }

  sessionDescription.sdp.split(&#x27;m=&#x27;).forEach(function (mediaItem, index) {
    // Ignore the v=0 lines etc..
    if (index === 0) {
      return;
    }

    var mediaType = (mediaItem.split(&#x27; &#x27;)[0] || &#x27;&#x27;);
    var ssrcLine = (mediaItem.match(/a=ssrc:.*\r\n/) || [])[0];

    if (typeof ssrcs[mediaType] !== &#x27;number&#x27;) {
      return;
    }

    if (ssrcLine) {
      ssrcs[mediaType] = parseInt((ssrcLine.split(&#x27;a=ssrc:&#x27;)[1] || &#x27;&#x27;).split(&#x27; &#x27;)[0], 10) || 0;
    }
  });

  if (!beSilentOnLogs) {
    log.debug([targetMid, &#x27;RTCSessionDesription&#x27;, sessionDescription.type,
      &#x27;Parsing session description media SSRCs -&gt;&#x27;], ssrcs);
  }

  return ssrcs;
};

/**
 * Function that parses the current list of supported codecs from session description.
 * @method _getSDPCodecsSupport
 * @private
 * @for Skylink
 * @since 0.6.18
 */
Skylink.prototype._getSDPCodecsSupport = function (targetMid, sessionDescription) {
  var self = this;
  var codecs = {
    audio: {},
    video: {}
  };

  if (!(sessionDescription &amp;&amp; sessionDescription.sdp)) {
    return codecs;
  }

  var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);
  var mediaType = &#x27;&#x27;;

  for (var i = 0; i &lt; sdpLines.length; i++) {
    if (sdpLines[i].indexOf(&#x27;m=&#x27;) === 0) {
      mediaType = (sdpLines[i].split(&#x27;m=&#x27;)[1] || &#x27;&#x27;).split(&#x27; &#x27;)[0];
      continue;
    }

    if (sdpLines[i].indexOf(&#x27;a=rtpmap:&#x27;) === 0) {
      var parts = (sdpLines[i].split(&#x27; &#x27;)[1] || &#x27;&#x27;).split(&#x27;/&#x27;);
      var codec = (parts[0] || &#x27;&#x27;).toLowerCase();
      var info = parts[1] + (parts[2] ? &#x27;/&#x27; + parts[2] : &#x27;&#x27;);

      if ([&#x27;ulpfec&#x27;, &#x27;red&#x27;, &#x27;telephone-event&#x27;, &#x27;cn&#x27;, &#x27;rtx&#x27;].indexOf(codec) &gt; -1) {
        continue;
      }

      codecs[mediaType][codec] = codecs[mediaType][codec] || [];

      if (codecs[mediaType][codec].indexOf(info) === -1) {
        codecs[mediaType][codec].push(info);
      }
    }
  }

  log.info([targetMid || null, &#x27;RTCSessionDescription&#x27;, sessionDescription.type, &#x27;Parsed codecs support -&gt;&#x27;], codecs);
  return codecs;
};

/**
 * Function that checks if there are any common codecs supported for remote end.
 * @method _getSDPCommonSupports
 * @private
 * @for Skylink
 * @since 0.6.25
 */
Skylink.prototype._getSDPCommonSupports = function (targetMid, sessionDescription) {
  var self = this;
  var offer = {
    audio: false,
    video: false
  };

  if (!targetMid || !(sessionDescription &amp;&amp; sessionDescription.sdp)) {
    offer.video = !!(self._currentCodecSupport.video.h264 || self._currentCodecSupport.video.vp8);
    offer.audio = !!self._currentCodecSupport.audio.opus;

    if (targetMid) {
      var peerAgent = ((self._peerInformations[targetMid] || {}).agent || {}).name || &#x27;&#x27;;

      if (AdapterJS.webrtcDetectedBrowser === peerAgent) {
        offer.video = Object.keys(self._currentCodecSupport.video).length &gt; 0;
        offer.audio = Object.keys(self._currentCodecSupport.audio).length &gt; 0;
      }
    }
    return offer;
  }

  var remoteCodecs = self._getSDPCodecsSupport(targetMid, sessionDescription);
  var localCodecs = self._currentCodecSupport;

  for (var ac in localCodecs.audio) {
    if (localCodecs.audio.hasOwnProperty(ac) &amp;&amp; localCodecs.audio[ac] &amp;&amp; remoteCodecs.audio[ac]) {
      offer.audio = true;
      break;
    }
  }

  for (var vc in localCodecs.video) {
    if (localCodecs.video.hasOwnProperty(vc) &amp;&amp; localCodecs.video[vc] &amp;&amp; remoteCodecs.video[vc]) {
      offer.video = true;
      break;
    }
  }

  return offer;
};

/**
 * Function adds SCTP port number for Firefox 63.0.3 and above if its missing in the answer from MCU
 * @method _setSCTPport
 * @private
 * @for Skylink
 * @since 0.6.35
 */
Skylink.prototype._setSCTPport = function (targetMid, sessionDescription) {
  var self = this;
  if (AdapterJS.webrtcDetectedBrowser === &#x27;firefox&#x27; &amp;&amp; AdapterJS.webrtcDetectedVersion &gt;= 63 &amp;&amp; self._hasMCU === true) {
    var sdpLines = sessionDescription.sdp.split(&#x27;\r\n&#x27;);
    var mLineType = &#x27;application&#x27;;
    var mLineIndex = -1;
    var sdpType = sessionDescription.type;

    for (var i = 0; i &lt; sdpLines.length; i++) {
      if (sdpLines[i].indexOf(&#x27;m=&#x27; + mLineType) === 0) {
        mLineIndex = i;
      } else if (mLineIndex &gt; 0) {
        if (sdpLines[i].indexOf(&#x27;m=&#x27;) === 0) {
          break;
        }

        // Saving m=application line when creating offer into instance variable
        if (sdpType === &#x27;offer&#x27;) {
          self._mline = sdpLines[mLineIndex];
          break;
        }

        // Replacing m=application line from instance variable
        if (sdpType === &#x27;answer&#x27;) {
          sdpLines[mLineIndex] = self._mline;
          sdpLines.splice(mLineIndex + 1, 0, &#x27;a=sctp-port:5000&#x27;);
          break;
        }
      }
    }

    return sdpLines.join(&#x27;\r\n&#x27;);
  }

  return sessionDescription.sdp;
};

    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
