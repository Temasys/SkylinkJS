<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>source/room-init.js - skylinkjs</title>
    <!-- font and icon -->
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <!-- styling -->
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap-theme.min.css">
    <link href="../assets/vendor/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- scripts -->
    <script src="../assets/vendor/js/jquery.min.js"></script>
    <script src="../assets/vendor/js/bootstrap.min.js"></script>
    <script src="../assets/js/script.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" />JS<small>Version: 0.6.1</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
    </ul>
  </li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
  <li><a href="https://temasys.github.io">Getting Started</a></li>
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
          
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content content-main">
                      <h1 class="file-heading">File: source/room-init.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * The list of Skylink platform room initialization ready state that indicates
 *   if the required connection information has been retrieved successfully from
 *   the platform server to start a connection.
 * @attribute READY_STATE_CHANGE
 * @type JSON
 * @param {Number} INIT Retrieval Step 1. The ready state is at it&#x27;s beginning.
 *   When {{#crossLink &quot;Skylink/init:method&quot;}}init(){{/crossLink}} is invoked, or
 *   when {{#crossLink &quot;Skylink/joinRoom:attr&quot;}}joinRoom(){{/crossLink}} is invoked
 *   with a provided room, it will start proceeding to Step 2.
 * @param {Number} LOADING Retrieval Step 2. Skylink starts retrieving the
 *   connection information from the platform server.
 * @param {Number} COMPLETED Retrieval Step 3. The connection information
 *   has been retrieved successfully.
 * @param {Number} ERROR Retrieval failure Step. An exception occured while retrieving
 *   the connection information. This could also be due to missing dependencies or the
 *   lack of WebRTC support.
 * @readOnly
 * @component Room
 * @for Skylink
 * @since 0.1.0
 */
Skylink.prototype.READY_STATE_CHANGE = {
  INIT: 0,
  LOADING: 1,
  COMPLETED: 2,
  ERROR: -1
};

/**
 * The list of Skylink platform room initialization ready state errors when
 *   the error state is triggered by
 *   {{#crossLink &quot;Skylink/readyStateChange:event&quot;}}readyStateChange{{/crossLink}}
     The list of ready state change errors.
 * - These are the error states from the error object error code.
 * - &lt;b&gt;ROOM_LOCKED&lt;/b&gt; is deprecated in 0.5.2. Please use
 *   {{#crossLink &quot;Skylink/:attr&quot;}}leaveRoom(){{/crossLink}}
 * - The states that would occur are:
 * @attribute READY_STATE_CHANGE_ERROR
 * @type JSON
 * @param {Number} API_INVALID Provided Application Key does not exists (invalid).
 * @param {Number} API_DOMAIN_NOT_MATCH Application accessing from backend IP address
 *   is not valid for provided Application Key.
 * @param {Number} API_CORS_DOMAIN_NOT_MATCH Application accessing from the CORS domain
 *   is not valid for provided Application Key.
 * @param {Number} API_CREDENTIALS_INVALID Credentials provided is not valid for
 *   provided Application Key.
 * @param {Number} API_CREDENTIALS_NOT_MATCH Credentials does not match as expected
 *   generated credentials for provided Application Key.
 * @param {Number} API_INVALID_PARENT_KEY Provided alias Application Key has an
 *   error because parent Application Key does not exists.
 * @param {Number} API_NO_MEETING_RECORD_FOUND For persistent room feature configured
 *   Application Key. There is no meeting currently that is open or available to join
 *   for self at the current time in the selected room.
 * @param {Number} NO_SOCKET_IO Socket.io dependency is not loaded.
 * @param {Number} NO_XMLHTTPREQUEST_SUPPORT XMLHttpRequest is not supported
 *   in current browser.
 * @param {Number} NO_WEBRTC_SUPPORT WebRTC is not supported in
 *   current browser.
 * @param {Number} NO_PATH Error thrown when {{#crossLink &quot;Skylink/joinRoom:method&quot;}}joinRoom(){{/crossLink}}
 *   is invoked before {{#crossLink &quot;Skylink/init:method&quot;}}init(){{/crossLink}}.
 * @param {Number} INVALID_XMLHTTPREQUEST_STATUS XMLHttpRequest does not return a
 *   HTTP status code of &lt;code&gt;200&lt;/code&gt;, which is a HTTP failure.
 * @param {Number} ADAPTER_NO_LOADED AdapterJS dependency is not loaded.
 * @param {Number} XML_HTTP_REQUEST_ERROR XMLHttpRequest failure on the network level when attempting to
 *   connect to the platform server to retrieve selected room connection information.
 * @readOnly
 * @component Room
 * @for Skylink
 * @since 0.4.0
 */
Skylink.prototype.READY_STATE_CHANGE_ERROR = {
  API_INVALID: 4001,
  API_DOMAIN_NOT_MATCH: 4002,
  API_CORS_DOMAIN_NOT_MATCH: 4003,
  API_CREDENTIALS_INVALID: 4004,
  API_CREDENTIALS_NOT_MATCH: 4005,
  API_INVALID_PARENT_KEY: 4006,
  API_NOT_ENOUGH_CREDIT: 4007,
  API_NOT_ENOUGH_PREPAID_CREDIT: 4008,
  API_FAILED_FINDING_PREPAID_CREDIT: 4009,
  API_NO_MEETING_RECORD_FOUND: 4010,
  ROOM_LOCKED: 5001,
  XML_HTTP_REQUEST_ERROR: -1,
  NO_SOCKET_IO: 1,
  NO_XMLHTTPREQUEST_SUPPORT: 2,
  NO_WEBRTC_SUPPORT: 3,
  NO_PATH: 4,
  INVALID_XMLHTTPREQUEST_STATUS: 5,
  SCRIPT_ERROR: 6,
  ADAPTER_NO_LOADED: 7
};

/**
 * The list of available regional servers.
 * - This is for developers to set the nearest region server
 *   for Skylink to connect to for faster connectivity.
 * - The available regional servers are:
 * @attribute REGIONAL_SERVER
 * @type JSON
 * @param {String} APAC1 Asia pacific server 1.
 * @param {String} US1 server 1.
 * @readOnly
 * @component Room
 * @for Skylink
 * @since 0.5.0
 */
Skylink.prototype.REGIONAL_SERVER = {
  APAC1: &#x27;sg&#x27;,
  US1: &#x27;us2&#x27;
};

/**
 * The flag to enforce an SSL platform signaling and platform server connection.
 * If self domain accessing protocol is &lt;code&gt;https:&lt;/code&gt;, SSL connections
 *   would be automatically used. This flag is mostly used for self domain accessing protocol
 *   that is &lt;code&gt;http:&lt;/code&gt; and enforcing the SSL connections for
 *   platform signaling and platform server connection.
 * @attribute _forceSSL
 * @type Boolean
 * @default false
 * @required
 * @private
 * @component Room
 * @for Skylink
 * @since 0.5.4
 */
Skylink.prototype._forceSSL = false;

/**
 * The flag to enforce an SSL TURN server connection.
 * If self domain accessing protocol is &lt;code&gt;https:&lt;/code&gt;, SSL connections
 *   would be automatically used. This flag is mostly used for self domain accessing protocol
 *   that is &lt;code&gt;http:&lt;/code&gt; and enforcing the SSL connections for
 *   TURN server connection.
 * @attribute _forceTURNSSL
 * @type Boolean
 * @default false
 * @required
 * @private
 * @component Room
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype._forceTURNSSL = false;

/**
 * The flag to enforce TURN server connection for quicker connectivity.
 * @attribute _forceTURN
 * @type Boolean
 * @default false
 * @required
 * @private
 * @component Room
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype._forceTURN = false;

/**
 * The constructed REST path that Skylink makes a &lt;code&gt;HTTP /GET&lt;/code&gt; from
 *   to retrieve the connection information required.
 * @attribute _path
 * @type String
 * @required
 * @private
 * @component Room
 * @for Skylink
 * @since 0.1.0
 */
Skylink.prototype._path = null;

/**
 * The regional server that Skylink connects to.
 * @attribute _serverRegion
 * @type String
 * @private
 * @component Room
 * @for Skylink
 * @since 0.5.0
 */
Skylink.prototype._serverRegion = null;

/**
 * The platform server URL that Skylink can construct the REST path with to make
 *   a &lt;code&gt;HTTP /GET&lt;/code&gt; to retrieve the connection information required.
 * If the value is not the default value, it&#x27;s mostly for debugging purposes.
 * It&#x27;s not advisable to allow developers to set the custom server URL unless
 *   they are aware of what they are doing, as this is a debugging feature.
 * @attribute _roomServer
 * @type String
 * @default &quot;//api.temasys.com.sg&quot;
 * @private
 * @component Room
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._roomServer = &#x27;//api.temasys.com.sg&#x27;;

/**
 * Stores the Application Key that is configured in the
 *   {{#crossLink &quot;Skylink/init:method&quot;}}init(){{/crossLink}}.
 * @attribute _appKey
 * @type String
 * @private
 * @component Room
 * @for Skylink
 * @since 0.3.0
 */
Skylink.prototype._appKey = null;

/**
 * Stores the default room that is configured in the
 *   {{#crossLink &quot;Skylink/init:method&quot;}}init(){{/crossLink}}.
 * If no room is provided in {{#crossLink &quot;Skylink/joinRoom:method&quot;}}joinRoom(){{/crossLink}},
 *   this is the room that self would join to by default.
 * If the value is not provided in {{#crossLink &quot;Skylink/init:method&quot;}}init(){{/crossLink}},
 *   by default, the value is the Application Key that is configured
 *   in {{#crossLink &quot;Skylink/init:method&quot;}}init(){{/crossLink}}.
 * @attribute _defaultRoom
 * @type String
 * @default Skylink._appKey
 * @private
 * @component Room
 * @for Skylink
 * @since 0.3.0
 */
Skylink.prototype._defaultRoom = null;

/**
 * Stores the new persistent room meeting start datetime stamp in
 *   [(ISO 8601 format)](https://en.wikipedia.org/wiki/ISO_8601).
 * This will start a new meeting based on the starting datetime stamp
 *   in the room that was selected to join.
 * The start date time of the room will not affect non persistent room connection.
 * The persistent room feature is configurable in the Application Key
 *   in the developer console.
 * @attribute _roomStart
 * @type String
 * @private
 * @optional
 * @component Room
 * @for Skylink
 * @since 0.3.0
 */
Skylink.prototype._roomStart = null;

/**
 * Stores the new persistent room meeting duration (in hours)
 *   that the current new meeting duration should be in the room
 *   that was selected to join.
 * The duration will not affect non persistent room connection.
 * The persistent room feature is configurable in the Application Key
 *   in the developer console.
 * @attribute _roomDuration
 * @type Number
 * @private
 * @optional
 * @component Room
 * @for Skylink
 * @since 0.3.0
 */
Skylink.prototype._roomDuration = null;

/**
 * Stores the room credentials for Application Key.
 * This is required for rooms connecting without CORS verification
 *   or starting a new persistent room meeting.
 * To generate the credentials:
 * - Concatenate a string that consists of the room name
 *   the room meeting duration (in hours) and the start date timestamp (in ISO 8601 format).
 *   Format &lt;code&gt;room + duration + startDateTimeStamp&lt;/code&gt;.
 * - Hash the concatenated string with the Application Key token using
 *   [SHA-1](https://en.wikipedia.org/wiki/SHA-1).
 *   You may use the [CryptoJS.HmacSHA1](https://code.google.com/p/crypto-js/#HMAC) function to do so.
 *   Example &lt;code&gt;var hash = CryptoJS.HmacSHA1(concatenatedString, token);&lt;/code&gt;.
 * - Convert the hash to a [Base64](https://en.wikipedia.org/wiki/Base64) encoded string. You may use the
 *   [CryptoJS.enc.Base64](https://code.google.com/p/crypto-js/#The_Cipher_Output) function
 *   to do so. Example &lt;code&gt;var base64String = hash.toString(CryptoJS.enc.Base64); &lt;/code&gt;.
 * - Encode the Base64 encoded string to a URI component using UTF-8 encoding with
 *   [encodeURIComponent()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent).
 *   Example &lt;code&gt;var credentials = encodeURIComponent(base64String);&lt;/code&gt;
 * and the duration.
 * @attribute _roomCredentials
 * @type String
 * @private
 * @optional
 * @component Room
 * @for Skylink
 * @since 0.3.0
 */
Skylink.prototype._roomCredentials = null;

/**
 * Stores the current Skylink room connection retrieval ready state.
 * [Rel: Skylink.READY_STATE_CHANGE]
 * @attribute _readyState
 * @type Number
 * @private
 * @required
 * @component Room
 * @for Skylink
 * @since 0.1.0
 */
Skylink.prototype._readyState = 0;

/**
 * Stores the Skylink server connection key for the selected room.
 * @attribute _key
 * @type String
 * @private
 * @component Room
 * @for Skylink
 * @since 0.1.0
 */
Skylink.prototype._key = null;

/**
 * Stores the Skylink server Application Key owner string for the selected room.
 * @attribute _appKeyOwner
 * @type String
 * @private
 * @component Room
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._appKeyOwner = null;

/**
 * Stores the room connection information that is passed for starting
 *   the selected room connection. Some of these information are also
 *   used and required to send for every messages sent to the platform
 *   signaling connection for targeting the correct room and
 *   self identification in the room.
 * @attribute _room
 * @type JSON
 * @param {String} id The room ID for identification to the platform signaling connection.
 * @param {String} token The generated room token given by the platform server for starting
 *    the platform signaling connection.
 * @param {String} startDateTime The start datetime stamp (in The startDateTime in
 *    [(ISO 8601 format)](https://en.wikipedia.org/wiki/ISO_8601) that the call has started
 *    sent by the platform server as an indication for the starting datetime of
 *    the platform signaling connection to self.
 * @param {String} duration The duration of the room meeting (in hours). This duration will
 *    not affect non persistent room.
 * @param {JSON} connection Connection The RTCPeerConnection constraints and configuration.
 * @param {JSON} connection.peerConstraints &lt;i&gt;Deprecated&lt;/i&gt;. The RTCPeerConnection
 *    constraints that is passed in this format &lt;code&gt;new RTCPeerConnection(config, constraints);&lt;/code&gt;.
 *    This feature is not documented in W3C Specification draft and not advisable to use.
 * @param {JSON} connection.peerConfig The RTCPeerConnection
 *    [RTCConfiguration](http://w3c.github.io/webrtc-pc/#idl-def-RTCConfiguration).
 * @param {JSON} connection.offerConstraints &lt;i&gt;Deprecated&lt;/i&gt;. The RTCPeerConnection
 *    [RTCOfferOptions](http://w3c.github.io/webrtc-pc/#idl-def-RTCOfferOptions) used in
 *    &lt;code&gt;RTCPeerConnection.createOffer(successCb, failureCb, options);&lt;/code&gt;.
 * @param {JSON} connection.sdpConstraints &lt;i&gt;Not in use&lt;/i&gt;. The RTCPeerConnection
 *    [RTCAnswerOptions](http://w3c.github.io/webrtc-pc/#idl-def-RTCAnswerOptions) to be used
 *    in &lt;code&gt;RTCPeerConnection.createAnswer(successCb, failureCb, options);&lt;/code&gt;.
 *    This is currently not in use due to not all browsers supporting this feature yet.
 * @param {JSON} connection.mediaConstraints &lt;i&gt;Deprecated&lt;/i&gt;. The getUserMedia()
 *    [MediaStreamConstraints](https://w3c.github.io/mediacapture-main/getusermedia.html#idl-def-MediaStreamConstraints)
 *    in &lt;code&gt;getUserMedia(constraints, successCb, failureCb);&lt;/code&gt;.
 * @required
 * @private
 * @component Room
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._room = null;

/**
 * Starts a &lt;code&gt;HTTP /GET&lt;/code&gt; REST call to the platform server to
 *   retrieve the required connection information.
 * @method _requestServerInfo
 * @param {String} method The HTTP method. The value should be provided as
 *   &lt;code&gt;&quot;GET&quot;&lt;/code&gt;.
 * @param {String} url The HTTP URI to invoke the REST call to. The
 *   value should be {{#crossLink &quot;Skylink/_path:attribute&quot;}}_path{{/crossLink}}.
 * @param {Function} callback The callback fired The callback fired after the
 *   &lt;code&gt;HTTP /GET&lt;/code&gt; REST call has a response from the platform server.
 * @param {Number} callback.status The HTTP status code of the HTTP response
 *   given by the platform server.
 * @param {JSON} callback.response The HTTP response data after the platform server
 *   has responded with the HTTP request.
 * @param {Boolean} callback.response.success The response from the platform server
 *   if Application Key connection retrieval is successful and validated or not.
 * @param {String} callback.response.pc_constraints For success state. The RTCPeerConnection
 *   constraints that would be configured in
 *   {{#crossLink &quot;Skylink/_room:attribute&quot;}}_room.peerConstraints{{/crossLink}} in
 *   {{#crossLink &quot;Skylink/_parseInfo:method&quot;}}_parseInfo(){{/crossLink}}.
 *   The data is in JSON stringified string and requires converting the JSON string
 *      to an JSON object to use the object.
 * @param {String} callback.response.media_constraints For success state. The getUserMedia()
 *   MediaStreamConstraints that would be configured in
 *   {{#crossLink &quot;Skylink/_room:attribute&quot;}}_room.mediaConstraints{{/crossLink}} in
 *   {{#crossLink &quot;Skylink/_parseInfo:method&quot;}}_parseInfo(){{/crossLink}}.
 *   The data is in JSON stringified string and requires converting the JSON string
 *     to an JSON object to use the object.
 * @param {String} callback.response.offer_constraints For success state. The RTCPeerConnection
 *   RTCOfferOptions that would be configured in
 *   {{#crossLink &quot;Skylink/_room:attribute&quot;}}_room.offerConstraints{{/crossLink}} in
 *   {{#crossLink &quot;Skylink/_parseInfo:method&quot;}}_parseInfo(){{/crossLink}}.
 *   The data is in JSON stringified string and requires converting the JSON string
 *      to an JSON object to use the object.
 * @param {String} callback.response.bandwidth For success state. The self
 *   streaming bandwidth settings. Setting the bandwidth flags may not
 *   force set the bandwidth for each connection stream channels as it depends
 *   on how the browser handles the bandwidth bitrate. Values are configured
 *   in &lt;var&gt;kb/s&lt;/var&gt;.
 * @param {String} callback.response.bandwidth.audio The default
 *   audio stream channel for self Stream object bandwidth
 *   that audio streaming should use in &lt;var&gt;kb/s&lt;/var&gt;.
 * @param {String} callback.response.bandwidth.video The default
 *   video stream channel for self Stream object bandwidth
 *   that video streaming should use in &lt;var&gt;kb/s&lt;/var&gt;.
 * @param {String} callback.response.bandwidth.data The default
 *   datachannel channel for the DataChannel connection bandwidth
 *   that datachannel connection per packet should be able use in &lt;var&gt;kb/s&lt;/var&gt;.
 * @param {String} callback.response.cid For success state. The Skylink server connection key for the
 *   selected room. This would be stored in {{#crossLink &quot;Skylink/_key:attribute&quot;}}_key{{/crossLink}}
 *   in {{#crossLink &quot;Skylink/_parseInfo:method&quot;}}_parseInfo(){{/crossLink}}.
 * @param {String} callback.response.apiOwner For success state. The Skylink server Application
 *   Key owner string for the selected room. This would be stored in
 *   {{#crossLink &quot;Skylink/_appKeyOwner:attribute&quot;}}_appKeyOwner{{/crossLink}}
 *   in {{#crossLink &quot;Skylink/_parseInfo:method&quot;}}_parseInfo(){{/crossLink}}.
 * @param {Array} callback.response.httpPortList For success state. The list of HTTP
 *   ports for reconnection retries. This would be stored in
 *   {{#crossLink &quot;Skylink/_socketPorts:attribute&quot;}}_socketPorts.http:{{/crossLink}}.
 * @param {Number} callback.response.httpPortList.(#index) The HTTP port that Skylink
 *   could reattempt to establish for a signaling connection with &lt;code&gt;http:&lt;/code&gt; protocol.
 * @param {Array} callback.response.httpsPortList For success state. The list of HTTPS
 *   ports for reconnection retries. This would be stored in
 *   {{#crossLink &quot;Skylink/_socketPorts:attribute&quot;}}_socketPorts.https:{{/crossLink}}.
 * @param {Number} callback.response.httpsPortList.(#index) The HTTPS port that Skylink
 *   could reattempt to establish for a signaling connection with &lt;code&gt;https:&lt;/code&gt; protocol or
 *   when {{#crossLink &quot;Skylink/_forceSSL:attribute&quot;}}_forceSSL{{/crossLink}} is enabled.
 * @param {String} callback.response.ipSigserver For success state. The platform signaling endpoint URI
 *   to open socket connection with. This would be stored in
 *   {{#crossLink &quot;Skylink/_signalingServer:attribute&quot;}}_signalingServer{{/crossLink}}.
 * @param {String} callback.response.roomCred For success state. The generated room token given
 *   by the platform server for starting the platform signaling connection. This would be stored in
 *   {{#crossLink &quot;Skylink/_room:attribute&quot;}}_room.token{{/crossLink}}.
 * @param {String} callback.response.room_key For success state. The room ID for identification
 *   to the platform signaling connection. This would be stored in
 *   {{#crossLink &quot;Skylink/_room:attribute&quot;}}_room.id{{/crossLink}}.
 * @param {String} callback.response.start For success state. The start datetime stamp (in The startDateTime in
 *   [(ISO 8601 format)](https://en.wikipedia.org/wiki/ISO_8601) that the call has started
 *   sent by the platform server as an indication for the starting datetime of
 *   the platform signaling connection to self. This would be stored in
 *   {{#crossLink &quot;Skylink/_room:attribute&quot;}}_room.startDateTime{{/crossLink}}.
 * @param {String} callback.response.timeStamp For success state. The self session timestamp.
 *   This would be stored in {{#crossLink &quot;Skylink/_user:attribute&quot;}}_user.timeStamp{{/crossLink}}
 * @param {String} callback.response.userCred For success state. The self session access token.
 *   This would be stored in {{#crossLink &quot;Skylink/_user:attribute&quot;}}_user.token{{/crossLink}}.
 * @param {String} callback.response.username For success state. The self session ID.
 *   This would be stored in {{#crossLink &quot;Skylink/_user:attribute&quot;}}_user.username{{/crossLink}}.
 * @param {String} callback.response.info For failure state. The error message thrown by
 *   the platform server.
 * @param {Number} callback.response.error For failure state. The error code of the error thrown by
 *   the platform server.
 * @param {JSON} params HTTP Params The HTTP data parameters that would be
 *    &lt;code&gt;application/json;charset=UTF-8&lt;/code&gt; encoded when sent to the
 *    platform server.
 * @private
 * @component Room
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._requestServerInfo = function(method, url, callback, params) {
  var self = this;
  // XDomainRequest is supported in IE8 - 9
  var useXDomainRequest = typeof window.XDomainRequest === &#x27;function&#x27; ||
    typeof window.XDomainRequest === &#x27;object&#x27;;

  self._socketUseXDR = useXDomainRequest;
  var xhr;

  // set force SSL option
  url = (self._forceSSL) ? &#x27;https:&#x27; + url : url;

  if (useXDomainRequest) {
    log.debug([null, &#x27;XMLHttpRequest&#x27;, method, &#x27;Using XDomainRequest. &#x27; +
      &#x27;XMLHttpRequest is now XDomainRequest&#x27;], {
      agent: window.webrtcDetectedBrowser,
      version: window.webrtcDetectedVersion
    });
    xhr = new XDomainRequest();
    xhr.setContentType = function (contentType) {
      xhr.contentType = contentType;
    };
  } else {
    log.debug([null, &#x27;XMLHttpRequest&#x27;, method, &#x27;Using XMLHttpRequest&#x27;], {
      agent: window.webrtcDetectedBrowser,
      version: window.webrtcDetectedVersion
    });
    xhr = new window.XMLHttpRequest();
    xhr.setContentType = function (contentType) {
      xhr.setRequestHeader(&#x27;Content-type&#x27;, contentType);
    };
  }

  xhr.onload = function () {
    var response = xhr.responseText || xhr.response;
    var status = xhr.status || 200;
    log.debug([null, &#x27;XMLHttpRequest&#x27;, method, &#x27;Received sessions parameters&#x27;],
      JSON.parse(response || &#x27;{}&#x27;));
    callback(status, JSON.parse(response || &#x27;{}&#x27;));
  };

  xhr.onerror = function (error) {
    log.error([null, &#x27;XMLHttpRequest&#x27;, method, &#x27;Failed retrieving information:&#x27;],
      { status: xhr.status });
    self._readyState = -1;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
      status: xhr.status || null,
      content: &#x27;Network error occurred. (Status: &#x27; + xhr.status + &#x27;)&#x27;,
      errorCode: self.READY_STATE_CHANGE_ERROR.XML_HTTP_REQUEST_ERROR
    }, self._selectedRoom);
  };

  xhr.onprogress = function () {
    log.debug([null, &#x27;XMLHttpRequest&#x27;, method,
      &#x27;Retrieving information and config from webserver. Url:&#x27;], url);
    log.debug([null, &#x27;XMLHttpRequest&#x27;, method, &#x27;Provided parameters:&#x27;], params);
  };

  xhr.open(method, url, true);
  if (params) {
    xhr.setContentType(&#x27;application/json;charset=UTF-8&#x27;);
    xhr.send(JSON.stringify(params));
  } else {
    xhr.send();
  }
};

/**
 * Parses the connection information retrieved from the platform server and
 *   stores them into the relevant attributes in
 *   {{#crossLink &quot;Skylink/_room:attribute&quot;}}_room{{/crossLink}} and
 *   {{#crossLink &quot;Skylink/_user:attribute&quot;}}_user{{/crossLink}}.
 * @method _parseInfo
 * @param {JSON} info The HTTP response data if the HTTP status
 *   code is &lt;code&gt;200&lt;/code&gt; (which means &lt;var&gt;HTTP OK&lt;/var&gt; code)
 * @param {String} info.pc_constraints The RTCPeerConnection constraints.
 *   The data is in JSON stringified string and requires converting the JSON string
 *      to an JSON object to use the object.
 * @param {String} info.media_constraints The getUserMedia() MediaStreamConstraints.
 *   The data is in JSON stringified string and requires converting the JSON string
 *      to an JSON object to use the object.
 * @param {String} info.offer_constraints The RTCPeerConnection RTCOfferOptions.
 *   The data is in JSON stringified string and requires converting the JSON string
 *      to an JSON object to use the object.
 * @param {String} info.bandwidth The self
 *   streaming bandwidth settings. Setting the bandwidth flags may not
 *   force set the bandwidth for each connection stream channels as it depends
 *   on how the browser handles the bandwidth bitrate. Values are configured
 *   in &lt;var&gt;kb/s&lt;/var&gt;.
 * @param {String} info.bandwidth.audio The default
 *   audio stream channel for self Stream object bandwidth
 *   that audio streaming should use in &lt;var&gt;kb/s&lt;/var&gt;.
 * @param {String} info.bandwidth.video The default
 *   video stream channel for self Stream object bandwidth
 *   that video streaming should use in &lt;var&gt;kb/s&lt;/var&gt;.
 * @param {String} info.bandwidth.data The default
 *   datachannel channel for the DataChannel connection bandwidth
 *   that datachannel connection per packet should be able use in &lt;var&gt;kb/s&lt;/var&gt;.
 * @param {String} info.cid The Skylink server connection key for starting the
 *   selected room connection.
 * @param {String} info.apiOwner The Skylink server Application Key owner string for the selected room.
 * @param {Array} info.httpPortList The list of HTTP
 *   ports for reconnection retries.
 * @param {Number} info.httpPortList.(#index) The HTTP port that Skylink
 *   could reattempt to establish for a signaling connection with &lt;code&gt;http:&lt;/code&gt; protocol.
 * @param {Array} info.httpsPortList The list of HTTPS
 *   ports for reconnection retries.
 * @param {Number} info.httpsPortList.(#index) The HTTPS port that Skylink
 *   could reattempt to establish for a signaling connection with &lt;code&gt;https:&lt;/code&gt; protocol or
 *   when {{#crossLink &quot;Skylink/_forceSSL:attribute&quot;}}_forceSSL{{/crossLink}} is enabled.
 * @param {String} info.ipSigserver The platform signaling endpoint URI
 *   to open socket connection with.
 * @param {String} info.roomCred The generated room token given
 *   by the platform server for starting the platform signaling connection.
 * @param {String} info.room_key For success state. The room ID for identification
 *   to the platform signaling connection.
 * @param {String} info.start The start datetime stamp (in The startDateTime in
 *   [(ISO 8601 format)](https://en.wikipedia.org/wiki/ISO_8601) that the call has started
 *   sent by the platform server as an indication for the starting datetime of
 *   the platform signaling connection to self.
 * @param {String} info.timeStamp The self session timestamp.
 * @param {String} info.userCred The self session access token.
 * @param {String} info.username The self session ID.
 * @trigger readyStateChange
 * @private
 * @required
 * @component Room
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._parseInfo = function(info) {
  log.log(&#x27;Parsing parameter from server&#x27;, info);
  if (!info.pc_constraints &amp;&amp; !info.offer_constraints) {
    this._trigger(&#x27;readyStateChange&#x27;, this.READY_STATE_CHANGE.ERROR, {
      status: 200,
      content: info.info,
      errorCode: info.error
    }, self._selectedRoom);
    return;
  }

  log.debug(&#x27;Peer connection constraints:&#x27;, info.pc_constraints);
  log.debug(&#x27;Offer constraints:&#x27;, info.offer_constraints);

  this._key = info.cid;
  this._appKeyOwner = info.apiOwner;

  this._signalingServer = info.ipSigserver;

  this._isPrivileged = info.isPrivileged;
  this._autoIntroduce = info.autoIntroduce;
  this._parentKey = info.room_key.substring(0,36);

  this._user = {
    uid: info.username,
    token: info.userCred,
    timeStamp: info.timeStamp,
    streams: [],
    info: {}
  };
  this._room = {
    id: info.room_key,
    token: info.roomCred,
    startDateTime: info.start,
    duration: info.len,
    connection: {
      peerConstraints: JSON.parse(info.pc_constraints),
      peerConfig: null,
      offerConstraints: JSON.parse(info.offer_constraints),
      sdpConstraints: {
        mandatory: {
          OfferToReceiveAudio: true,
          OfferToReceiveVideo: true
        }
      },
      mediaConstraints: JSON.parse(info.media_constraints)
    }
  };
  this._parseDefaultMediaStreamSettings(this._room.connection.mediaConstraints);

  // set the socket ports
  this._socketPorts = {
    &#x27;http:&#x27;: info.httpPortList,
    &#x27;https:&#x27;: info.httpsPortList
  };

  // use default bandwidth and media resolution provided by server
  //this._streamSettings.bandwidth = info.bandwidth;
  //this._streamSettings.video = info.video;
  this._readyState = 2;
  this._trigger(&#x27;readyStateChange&#x27;, this.READY_STATE_CHANGE.COMPLETED, null, this._selectedRoom);
  log.info(&#x27;Parsed parameters from webserver. &#x27; +
    &#x27;Ready for web-realtime communication&#x27;);

};

/**
 * Starts loading the required dependencies and then retrieve the required
 *   connection information from the platform server.
 * @method _loadInfo
 * @trigger readyStateChange
 * @private
 * @required
 * @component Room
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._loadInfo = function() {
  var self = this;

  // check if adapterjs has been loaded already first or not
  var adapter = (function () {
    try {
      return window.AdapterJS || AdapterJS;
    } catch (error) {
      return false;
    }
  })();

  if (!(!!adapter ? typeof adapter.webRTCReady === &#x27;function&#x27; : false)) {
    var noAdapterErrorMsg = &#x27;AdapterJS dependency is not loaded or incorrect AdapterJS dependency is used&#x27;;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
      status: null,
      content: noAdapterErrorMsg,
      errorCode: self.READY_STATE_CHANGE_ERROR.ADAPTER_NO_LOADED
    }, self._selectedRoom);
    return;
  }
  if (!window.io) {
    log.error(&#x27;Socket.io not loaded. Please load socket.io&#x27;);
    self._readyState = -1;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
      status: null,
      content: &#x27;Socket.io not found&#x27;,
      errorCode: self.READY_STATE_CHANGE_ERROR.NO_SOCKET_IO
    }, self._selectedRoom);
    return;
  }
  if (!window.XMLHttpRequest) {
    log.error(&#x27;XMLHttpRequest not supported. Please upgrade your browser&#x27;);
    self._readyState = -1;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
      status: null,
      content: &#x27;XMLHttpRequest not available&#x27;,
      errorCode: self.READY_STATE_CHANGE_ERROR.NO_XMLHTTPREQUEST_SUPPORT
    }, self._selectedRoom);
    return;
  }
  if (!window.RTCPeerConnection) {
    log.error(&#x27;WebRTC not supported. Please upgrade your browser&#x27;);
    self._readyState = -1;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
      status: null,
      content: &#x27;WebRTC not available&#x27;,
      errorCode: self.READY_STATE_CHANGE_ERROR.NO_WEBRTC_SUPPORT
    }, self._selectedRoom);
    return;
  }
  if (!self._path) {
    log.error(&#x27;Skylink is not initialised. Please call init() first&#x27;);
    self._readyState = -1;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
      status: null,
      content: &#x27;No API Path is found&#x27;,
      errorCode: self.READY_STATE_CHANGE_ERROR.NO_PATH
    }, self._selectedRoom);
    return;
  }
  adapter.webRTCReady(function () {
    self._readyState = 1;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.LOADING, null, self._selectedRoom);
    self._requestServerInfo(&#x27;GET&#x27;, self._path, function(status, response) {
      if (status !== 200) {
        // 403 - Room is locked
        // 401 - API Not authorized
        // 402 - run out of credits
        var errorMessage = &#x27;XMLHttpRequest status not OK\nStatus was: &#x27; + status;
        self._readyState = 0;
        self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
          status: status,
          content: (response) ? (response.info || errorMessage) : errorMessage,
          errorCode: response.error ||
            self.READY_STATE_CHANGE_ERROR.INVALID_XMLHTTPREQUEST_STATUS
        }, self._selectedRoom);
        return;
      }
      self._parseInfo(response);
    });
  });
};

/**
 * Starts loading the required connection information to start connection
 *   based on the selected room in {{#crossLink &quot;Skylink/joinRoom:method&quot;}}joinRoom(){{/crossLink}}.
 * @method _initSelectedRoom
 * @param {String} [room] The room to retrieve required connection information
 *   to start connection. If room is not provided, the room
 *   would default to the the &lt;code&gt;defaultRoom&lt;/code&gt; option set
 *   in {{#crossLink &quot;Skylink/init:method&quot;}}init() settings{{/crossLink}}.
 * @param {Function} callback The callback fired after required connection
 *   information has been retrieved successfully with the provided media
 *   settings or have met with an exception.
 * @param {Object} callback.error The error object received in the callback.
 *   If received as &lt;code&gt;null&lt;/code&gt;, it means that there is no errors.
 * @trigger readyStateChange
 * @private
 * @component Room
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype._initSelectedRoom = function(room, callback) {
  var self = this;
  if (typeof room === &#x27;function&#x27; || typeof room === &#x27;undefined&#x27;) {
    log.error(&#x27;Invalid room provided. Room:&#x27;, room);
    return;
  }
  var defaultRoom = self._defaultRoom;
  var initOptions = {
    roomServer: self._roomServer,
    defaultRoom: room || defaultRoom,
    appKey: self._appKey,
    region: self._serverRegion,
    enableDataChannel: self._enableDataChannel,
    enableIceTrickle: self._enableIceTrickle
  };
  if (self._roomCredentials) {
    initOptions.credentials = {
      credentials: self._roomCredentials,
      duration: self._roomDuration,
      startDateTime: self._roomStart
    };
  }
  self.init(initOptions, function (error, success) {
    self._defaultRoom = defaultRoom;
    if (error) {
      callback(error);
    } else {
      callback(null);
    }
  });
};

/**
 * Initialises and configures Skylink to begin any connection.
 * &lt;b&gt;NOTE&lt;/b&gt; that this is the first method that has to be called before
 *   using any other functionalities other than debugging features like
 *   {{#crossLink &quot;Skylink/setLogLevel:method&quot;}}setLogLevel(){{/crossLink}} and
 *   {{#crossLink &quot;Skylink/setDebugMode:method&quot;}}setDebugMode(){{/crossLink}} and
 *   after all event subscriptions like {{#crossLink &quot;Skylink/on:method&quot;}}on(){{/crossLink}}
 *   or {{#crossLink &quot;Skylink/once:method&quot;}}once(){{/crossLink}} has been made.
 * This is where the Application Key is configured and attached to Skylink for usage.
 * @method init
 * @param {String|JSON} options The configuration settings for Skylink.
 *   If provided options is a &lt;var&gt;typeof&lt;/var&gt; &lt;code&gt;string&lt;/code&gt;, it will
 *   be interpreted as the Application Key being provided.
 * @param {String} options.appKey Previously known as &lt;code&gt;apiKey&lt;/code&gt;.
 *   The Application Key that Skylink uses for initialising and connecting rooms.
 * @param {String} [options.defaultRoom=options.appKey] The default room that
 *   Skylink should connect to if there is no room provided in
 *   {{#crossLink &quot;Skylink/joinRoom:method&quot;}}joinRoom(){{/crossLink}}.
 *   If this value is not provided, the default room value would be
 *   the Application Key provided.
 * @param {String} [options.roomServer] The platform server URL that Skylink makes a
 *   &lt;code&gt;HTTP /GET&lt;/code&gt; to retrieve the connection information required.
 *   This is a debugging feature, and it&#x27;s not advisable to manipulate
 *     this value unless you are using a beta platform server.
 * @param {Boolean} [options.enableIceTrickle=true] &lt;i&gt;Debugging Feature&lt;/i&gt;.
 *    The flag that indicates if PeerConnections
 *    should enable trickling of ICE to connect the ICE connection. Configuring
 *    this value to &lt;code&gt;false&lt;/code&gt; may result in a slower connection but
 *    a more stable connection.
 * @param {Boolean} [options.enableDataChannel=true]  &lt;i&gt;Debugging feature&lt;/i&gt;.
 *   The flag that indicates if PeerConnections
 *   should have any DataChannel connections. Configuring this value to &lt;code&gt;false&lt;/code&gt;
 *   may result in failure to use features like
 *   {{#crossLink &quot;Skylink/sendBlobData:method&quot;}}sendBlobData(){{/crossLink}},
 *   {{#crossLink &quot;Skylink/sendP2PMessage:method&quot;}}sendP2PMessage(){{/crossLink}} and
 *   {{#crossLink &quot;Skylink/sendURLData:method&quot;}}sendURLData(){{/crossLink}} or any
 *   DataChannel connection related services.
 * @param {Boolean} [options.enableTURNServer=true] &lt;i&gt;Debugging feature&lt;/i&gt;.
 *   The flag that indicates if PeerConnections connection should use any TURN server connection.
 *   Tampering this flag may disable any successful Peer connection
 *   that is behind any firewalls, so set this value at your own risk.
 * @param {Boolean} [options.enableSTUNServer=true] &lt;i&gt;Debugging feature&lt;/i&gt;.
 *   The flag that indicates if PeerConnections connection should use any STUN server connection.
 *   Tampering this flag may cause issues to connections, so set this value at your own risk.
 * @param {Boolean} [options.forceTURN=false] The flag that indicates if PeerConnections connection
 *   should only use TURN server connection which enables a quicker connectivity.
 *   This configuration will override the settings for &lt;code&gt;enableTURNServer&lt;/code&gt;
 *   and &lt;code&gt;enableSTUNServer&lt;/code&gt; and set &lt;code&gt;enableTURNServer&lt;/code&gt; as &lt;code&gt;true&lt;/code&gt; and
 *   &lt;code&gt;enableSTUNServer&lt;/code&gt; as &lt;code&gt;false&lt;/code&gt; if the value is set to &lt;code&gt;true&lt;/code&gt;.
 * @param {Boolean} [options.usePublicSTUN=true] The flag that indicates if PeerConnections connection
 *   should enable usage of public STUN server connection connectivity.
 *   This configuration would not work if &lt;code&gt;enableSTUNServer&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;
 *   or &lt;code&gt;forceTURN&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.
 * @param {Boolean} [options.TURNServerTransport=Skylink.TURN_TRANSPORT.ANY] &lt;i&gt;Debugging feature&lt;/i&gt;.
 *   The TURN server transport to enable for TURN server connections.
 *   Tampering this flag may cause issues to connections, so set this value at your own risk.
 *   [Rel: Skylink.TURN_TRANSPORT]
 * @param {JSON} [options.credentials] The credentials configured for starting a new persistent
 *   room meeting or connecting with Application Keys that do not use CORS authentication.
 *   Setting the &lt;code&gt;startDateTime&lt;/code&gt; or the &lt;code&gt;duration&lt;/code&gt; will not affect
 *   the actual duration for non persistent rooms. This feature would only affect connections with
 *   Application Keys that is configured for persistent room feature.
 *   To enable persistent room or disable CORS, you may set it in the developer console.
 *   CORS may be disabled by setting the platform to &lt;code&gt;&quot;Other&quot;&lt;/code&gt;.
 * @param {String} options.credentials.startDateTime The room start datetime stamp in
 *   &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 format&lt;/a&gt;.
 *   This will start a new meeting based on the starting datetime stamp
 *   in the room that was selected to join for Application Key that is configured
 *   with persistent room feature. You may use
 *   &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString&quot;&gt;
 *   Date.toISOString()&lt;/a&gt; to retrieve ISO 8601 formatted date time stamp.
 *   The start date time of the room will not affect non persistent room connection.
 * @param {Number} options.credentials.duration The duration (in hours)
 *   that the room duration should be in. This will set the duration starting from
 *   the provided &lt;code&gt;startDateTime&lt;/code&gt; onwards and after the duration is over,
 *   the meeting is over and the room is closed for Application Key that is
 *   configured with persistent room feature.
 *   The duration will not affect non persistent room connection.The duration of the meeting in hours.&lt;br&gt;
 *   &lt;small&gt;E.g. &lt;code&gt;0.5&lt;/code&gt; for half an hour, &lt;code&gt;1.4&lt;/code&gt; for 1 hour and 24 minutes&lt;/small&gt;
 * @param {String} options.credentials.credentials The room credentials for Application Key.
 *   This is required for rooms connecting without CORS verification or starting a new persistent room meeting.&lt;br&gt;&lt;br&gt;
 *   &lt;u&gt;To generate the credentials:&lt;/u&gt;&lt;br&gt;
 *   &lt;ol&gt;
 *   &lt;li&gt;Concatenate a string that consists of the room name
 *     the room meeting duration (in hours) and the start date timestamp (in ISO 8601 format).&lt;br&gt;
 *     &lt;small&gt;Format &lt;code&gt;room + &quot;_&quot; + duration + &quot;_&quot; + startDateTimeStamp&lt;/code&gt;&lt;/small&gt;&lt;/li&gt;
 *   &lt;li&gt;Hash the concatenated string with the Application Key token using
 *     &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt;.
 *     You may use the &lt;a href=&quot;https://code.google.com/p/crypto-js/#HMAC&quot;&gt;CryptoJS.HmacSHA1&lt;/a&gt; function to do so.&lt;br&gt;
 *     &lt;small&gt;Example &lt;code&gt;var hash = CryptoJS.HmacSHA1(concatenatedString, token);&lt;/code&gt;&lt;/small&gt;&lt;/li&gt;
 *   &lt;li&gt;Convert the hash to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Base64&quot;&gt;Base64&lt;/a&gt; encoded string. You may use the
 *     &lt;a href=&quot;https://code.google.com/p/crypto-js/#The_Cipher_Output&quot;&gt;CryptoJS.enc.Base64&lt;/a&gt; function
 *     to do so.&lt;br&gt;&lt;small&gt;Example &lt;code&gt;var base64String = hash.toString(CryptoJS.enc.Base64); &lt;/code&gt;&lt;/small&gt;&lt;/li&gt;
 *   &lt;li&gt;Encode the Base64 encoded string to a URI component using UTF-8 encoding with
 *     &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent&quot;&gt;encodeURIComponent()&lt;/a&gt;.&lt;br&gt;
 *     &lt;small&gt;Example &lt;code&gt;var credentials = encodeURIComponent(base64String);&lt;/code&gt;&lt;/small&gt;&lt;/li&gt;
 *   &lt;/ol&gt;&lt;br&gt;
 * @param {Boolean} [options.audioFallback=false] The flag that indicates if there is a failure in
 *   {{#crossLink &quot;Skylink/getUserMedia:method&quot;}}getUserMedia(){{/crossLink}} in retrieving user media
 *   video stream, it should fallback to retrieve audio stream only. This would not work for
 *   {{#crossLink &quot;Skylink/joinRoom:method&quot;}}joinRoom(){{/crossLink}} except
 *   {{#crossLink &quot;Skylink/getUserMedia:method&quot;}}getUserMedia(){{/crossLink}}.
 * @param {Boolean} [options.forceSSL=false] The flag to enforce an SSL platform signaling and platform server connection.
 *   If self domain accessing protocol is &lt;code&gt;https:&lt;/code&gt;, SSL connections
 *   would be automatically used. This flag is mostly used for self domain accessing protocol
 *   that is &lt;code&gt;http:&lt;/code&gt; and enforcing the SSL connections for
 *   platform signaling and platform server connection.
 * @param {String} [options.audioCodec=Skylink.AUDIO_CODEC.AUTO] &lt;i&gt;Debugging Feature&lt;/i&gt;.
 *   The preferred audio codec that Peer connection
 *   streaming audio codec should use in the connection when available. If not available, the default
 *   codec would be the browser generated session description selected codec. [Rel: Skylink.AUDIO_CODEC]
 * @param {String} [options.videoCodec=Skylink.VIDEO_CODEC.AUTO] &lt;i&gt;Debugging Feature&lt;/i&gt;.
 *   The preferred video codec that Peer connection
 *   streaming video codec should use in the connection when available. If not available, the default
 *   codec would be the browser generated session description selected codec. [Rel: Skylink.VIDEO_CODEC]
 * @param {Number} [options.socketTimeout=20000] The timeout that the socket connection should throw a
 *   timeout exception when socket fails to receive a response from connection. Depending on
 *   the max retries left based on the availability of ports given by the platform server,
 *   the socket will reattempt to establish a socket connection with the signaling server.&lt;br&gt;
 *   The mininum timeout value is &lt;code&gt;5000&lt;/code&gt;.
 * @param {Boolean} [options.forceTURNSSL=false] The flag to enforce an SSL TURN server connection.
 *   If self domain accessing protocol is &lt;code&gt;https:&lt;/code&gt;, SSL connections
 *   would be automatically used. This flag is mostly used for self domain accessing protocol
 *   that is &lt;code&gt;http:&lt;/code&gt; and enforcing the SSL connections for
 *   TURN server connection.
 * @param {Function} [callback] The callback fired after Skylink has been
 *   initialised successfully or have met with an exception.
 *   The callback signature is &lt;code&gt;function (error, success)&lt;/code&gt;.
 * @param {JSON} callback.error The error object received in the callback.
 *   If received as &lt;code&gt;null&lt;/code&gt;, it means that there is no errors.
 * @param {Number} callback.error.errorCode The
 *   &lt;a href=&quot;#attr_READY_STATE_CHANGE_ERROR&quot;&gt;READY_STATE_CHANGE_ERROR&lt;/a&gt;
 *   if there is an &lt;a href=&quot;#event_readyStateChange&quot;&gt;readyStateChange&lt;/a&gt;
 *   event error that caused the failure for initialising Skylink.
 *   [Rel: Skylink.READY_STATE_CHANGE_ERROR]
 * @param {Object} callback.error.error The exception thrown that caused the failure
 *   for initialising Skylink.
 * @param {Number} callback.error.status The XMLHttpRequest status code received
 *   when exception is thrown that caused the failure for initialising Skylink.
 * @param {JSON} callback.success The success object received in the callback.
 *   If received as &lt;code&gt;null&lt;/code&gt;, it means that there are errors.
 * @param {String} callback.success.appKey Previously known as &lt;code&gt;apiKey&lt;/code&gt;.
 *   The Application Key that Skylink uses for initialising and connecting rooms.
 * @param {String} callback.success.defaultRoom The default room that
 *   Skylink should connect to if there is no room provided in
 *   &lt;a href=&quot;#method_joinRoom&quot;&gt;joinRoom()&lt;/a&gt;.
 * @param {String} callback.success.roomServer The platform server URL that Skylink makes a
 *   &lt;code&gt;HTTP /GET&lt;/code&gt; to retrieve the connection information required.
 * @param {Boolean} callback.success.enableIceTrickle The flag that indicates if PeerConnections
 *    should enable trickling of ICE to connect the ICE connection.
 * @param {Boolean} callback.success.enableDataChannel The flag that indicates if PeerConnections
 *   should have any DataChannel connections.
 * @param {Boolean} callback.success.enableTURNServer The flag that indicates if
 *   PeerConnections connection should use any TURN server connection.
 * @param {Boolean} callback.success.enableSTUNServer The flag that indicates if
 *   PeerConnections connection should use any STUN server connection.
 * @param {Boolean} callback.success.TURNServerTransport The TURN server transport
 *   to enable for TURN server connections.
 *   [Rel: Skylink.TURN_TRANSPORT]
 * @param {Boolean} callback.success.audioFallback The flag that indicates if there is a failure in
 *   &lt;a href=&quot;#method_getUserMedia&quot;&gt;getUserMedia()&lt;/a&gt; in retrieving user media
 *   video stream, it should fallback to retrieve audio stream only.
 * @param {Boolean} callback.success.forceSSL The flag to enforce an SSL platform signaling and platform server connection.
 *   If self domain accessing protocol is &lt;code&gt;https:&lt;/code&gt;, SSL connections
 *   would be automatically used.
 * @param {String} callback.success.audioCodec The preferred audio codec that Peer connection
 *   streaming audio codec should use in the connection when available. [Rel: Skylink.AUDIO_CODEC]
 * @param {String} callback.success.videoCodec The preferred video codec that Peer connection
 *   streaming video codec should use in the connection when available. [Rel: Skylink.VIDEO_CODEC]
 * @param {Number} callback.success.socketTimeout The timeout that the socket connection should throw a
 *   timeout exception when socket fails to receive a response from connection. Depending on
 *   the max retries left based on the availability of ports given by the platform server,
 *   the socket will reattempt to establish a socket connection with the signaling server.
 * @param {Boolean} callback.success.forceTURNSSL The flag to enforce an SSL TURN server connection.
 *   If self domain accessing protocol is &lt;code&gt;https:&lt;/code&gt;, SSL connections
 *   would be automatically used.
 * @param {Boolean} callback.success.forceTURN The flag that indicates if PeerConnections connection
 *   should only use TURN server connection which enables a quicker connectivity.
 *   This configuration will override the settings for &lt;code&gt;enableTURNServer&lt;/code&gt;
 *   and &lt;code&gt;enableSTUNServer&lt;/code&gt; and set &lt;code&gt;enableTURNServer&lt;/code&gt; as &lt;code&gt;true&lt;/code&gt; and
 *   &lt;code&gt;enableSTUNServer&lt;/code&gt; as &lt;code&gt;false&lt;/code&gt; if the value is set to &lt;code&gt;true&lt;/code&gt;.
 * @param {Boolean} callback.success.usePublicSTUN The flag that indicates if PeerConnections connection
 *   should enable usage of public STUN server connection connectivity.
 *   This configuration would not work if &lt;code&gt;enableSTUNServer&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;
 *   or &lt;code&gt;forceTURN&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.
 * @example
 *   // Note: Default room is appKey when no room
 *   // Example 1: To initalize without setting any default room.
 *   SkylinkDemo.init(&quot;YOUR_APP_KEY_HERE&quot;);
 *
 *   // Example 2: To initialize with appKey and defaultRoom
 *   SkylinkDemo.init({
 *     appKey: &quot;YOUR_APP_KEY_HERE&quot;,
 *     defaultRoom: &quot;mainHangout&quot;
 *   });
 *
 *   // Example 3: To initialize with credentials to set startDateTime and
 *   // duration of the room
 *   var hash = CryptoJS.HmacSHA1(roomname + &quot;_&quot; + duration + &quot;_&quot; +
 *     (new Date()).toISOString(), token);
 *   var credentials = encodeURIComponent(hash.toString(CryptoJS.enc.Base64));
 *   SkylinkDemo.init({
 *     appKey: &quot;YOUR_APP_KEY_HERE&quot;,
 *     defaultRoom: &quot;mainHangout&quot;
 *     credentials: {
 *        startDateTime: (new Date()).toISOString(),
 *        duration: 500,
 *        credentials: credentials
 *     }
 *   });
 *
 *   // Example 4: To initialize with callback
 *   SkylinkDemo.init(&quot;YOUR_APP_KEY_HERE&quot;, function(error,success){
 *     if (error){
 *       console.error(&quot;Init failed:&quot;, error);
 *     }
 *     else{
 *       console.info(&quot;Init succeed:&quot;, success);
 *     }
 *   });
 *
 * @trigger readyStateChange
 * @required
 * @component Room
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype.init = function(options, callback) {
  var self = this;

  if (typeof options === &#x27;function&#x27;){
    callback = options;
    options = undefined;
  }

  if (!options) {
    var error = &#x27;No API key provided&#x27;;
    log.error(error);
    if (typeof callback === &#x27;function&#x27;){
      callback(error,null);
    }
    return;
  }

  var appKey, room, defaultRoom, region;
  var startDateTime, duration, credentials;
  var roomServer = self._roomServer;
  // NOTE: Should we get all the default values from the variables
  // rather than setting it?
  var enableIceTrickle = true;
  var enableDataChannel = true;
  var enableSTUNServer = true;
  var enableTURNServer = true;
  var TURNTransport = self.TURN_TRANSPORT.ANY;
  var audioFallback = false;
  var forceSSL = false;
  var socketTimeout = 0;
  var forceTURNSSL = window.location.protocol === &#x27;https:&#x27;;
  var audioCodec = self.AUDIO_CODEC.AUTO;
  var videoCodec = self.VIDEO_CODEC.AUTO;
  var forceTURN = false;
  var usePublicSTUN = true;

  log.log(&#x27;Provided init options:&#x27;, options);

  if (typeof options === &#x27;string&#x27;) {
    // set all the default api key, default room and room
    appKey = options;
    defaultRoom = appKey;
    room = appKey;
  } else {
    // set the api key
    appKey = options.appKey || options.apiKey;
    // set the room server
    roomServer = options.roomServer || roomServer;
    // check room server if it ends with /. Remove the extra /
    roomServer = (roomServer.lastIndexOf(&#x27;/&#x27;) ===
      (roomServer.length - 1)) ? roomServer.substring(0,
      roomServer.length - 1) : roomServer;
    // set the region
    region = options.region || region;
    // set the default room
    defaultRoom = options.defaultRoom || appKey;
    // set the selected room
    room = defaultRoom;
    // set ice trickle option
    enableIceTrickle = (typeof options.enableIceTrickle === &#x27;boolean&#x27;) ?
      options.enableIceTrickle : enableIceTrickle;
    // set data channel option
    enableDataChannel = (typeof options.enableDataChannel === &#x27;boolean&#x27;) ?
      options.enableDataChannel : enableDataChannel;
    // set stun server option
    enableSTUNServer = (typeof options.enableSTUNServer === &#x27;boolean&#x27;) ?
      options.enableSTUNServer : enableSTUNServer;
    // set turn server option
    enableTURNServer = (typeof options.enableTURNServer === &#x27;boolean&#x27;) ?
      options.enableTURNServer : enableTURNServer;
    // set the force ssl always option
    forceSSL = (typeof options.forceSSL === &#x27;boolean&#x27;) ?
      options.forceSSL : forceSSL;
    // set the socket timeout option
    socketTimeout = (typeof options.socketTimeout === &#x27;number&#x27;) ?
      options.socketTimeout : socketTimeout;
    // set the socket timeout option to be above 5000
    socketTimeout = (socketTimeout &lt; 5000) ? 5000 : socketTimeout;
    // set the force turn ssl always option
    forceTURNSSL = (typeof options.forceTURNSSL === &#x27;boolean&#x27;) ?
      options.forceTURNSSL : forceTURNSSL;
    // set the preferred audio codec
    audioCodec = typeof options.audioCodec === &#x27;string&#x27; ?
      options.audioCodec : audioCodec;
    // set the preferred video codec
    videoCodec = typeof options.videoCodec === &#x27;string&#x27; ?
      options.videoCodec : videoCodec;
    // set the force turn server option
    forceTURN = (typeof options.forceTURN === &#x27;boolean&#x27;) ?
      options.forceTURN : forceTURN;
    // set the use public stun option
    usePublicSTUN = (typeof options.usePublicSTUN === &#x27;boolean&#x27;) ?
      options.usePublicSTUN : usePublicSTUN;

    // set turn transport option
    if (typeof options.TURNServerTransport === &#x27;string&#x27;) {
      // loop out for every transport option
      for (var type in self.TURN_TRANSPORT) {
        if (self.TURN_TRANSPORT.hasOwnProperty(type)) {
          // do a check if the transport option is valid
          if (self.TURN_TRANSPORT[type] === options.TURNServerTransport) {
            TURNTransport = options.TURNServerTransport;
            break;
          }
        }
      }
    }
    // set audio fallback option
    audioFallback = options.audioFallback || audioFallback;
    // Custom default meeting timing and duration
    // Fallback to default if no duration or startDateTime provided
    if (options.credentials) {
      // set start data time
      startDateTime = options.credentials.startDateTime ||
        (new Date()).toISOString();
      // set the duration
      duration = options.credentials.duration || 200;
      // set the credentials
      credentials = options.credentials.credentials;
    }

    // if force turn option is set to on
    if (forceTURN === true) {
      enableTURNServer = true;
      enableSTUNServer = false;
    }
  }
  // api key path options
  self._appKey = appKey;
  self._roomServer = roomServer;
  self._defaultRoom = defaultRoom;
  self._selectedRoom = room;
  self._serverRegion = region || null;
  self._path = roomServer + &#x27;/api/&#x27; + appKey + &#x27;/&#x27; + room;
  // set credentials if there is
  if (credentials) {
    self._roomStart = startDateTime;
    self._roomDuration = duration;
    self._roomCredentials = credentials;
    self._path += (credentials) ? (&#x27;/&#x27; + startDateTime + &#x27;/&#x27; +
      duration + &#x27;?&amp;cred=&#x27; + credentials) : &#x27;&#x27;;
  }

  self._path += ((credentials) ? &#x27;&amp;&#x27; : &#x27;?&#x27;) + &#x27;rand=&#x27; + (new Date()).toISOString();

  // check if there is a other query parameters or not
  if (region) {
    self._path += &#x27;&amp;rg=&#x27; + region;
  }
  // skylink functionality options
  self._enableIceTrickle = enableIceTrickle;
  self._enableDataChannel = enableDataChannel;
  self._enableSTUN = enableSTUNServer;
  self._enableTURN = enableTURNServer;
  self._TURNTransport = TURNTransport;
  self._audioFallback = audioFallback;
  self._forceSSL = forceSSL;
  self._socketTimeout = socketTimeout;
  self._forceTURNSSL = forceTURNSSL;
  self._selectedAudioCodec = audioCodec;
  self._selectedVideoCodec = videoCodec;
  self._forceTURN = forceTURN;
  self._usePublicSTUN = usePublicSTUN;

  log.log(&#x27;Init configuration:&#x27;, {
    serverUrl: self._path,
    readyState: self._readyState,
    appKey: self._appKey,
    roomServer: self._roomServer,
    defaultRoom: self._defaultRoom,
    selectedRoom: self._selectedRoom,
    serverRegion: self._serverRegion,
    enableDataChannel: self._enableDataChannel,
    enableIceTrickle: self._enableIceTrickle,
    enableTURNServer: self._enableTURN,
    enableSTUNServer: self._enableSTUN,
    TURNTransport: self._TURNTransport,
    audioFallback: self._audioFallback,
    forceSSL: self._forceSSL,
    socketTimeout: self._socketTimeout,
    forceTURNSSL: self._forceTURNSSL,
    audioCodec: self._selectedAudioCodec,
    videoCodec: self._selectedVideoCodec,
    forceTURN: self._forceTURN,
    usePublicSTUN: self._usePublicSTUN
  });
  // trigger the readystate
  self._readyState = 0;
  self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.INIT, null, self._selectedRoom);

  if (typeof callback === &#x27;function&#x27;){
    var hasTriggered = false;

    var readyStateChangeFn = function (readyState, error) {
      if (!hasTriggered) {
        if (readyState === self.READY_STATE_CHANGE.COMPLETED) {
          log.log([null, &#x27;Socket&#x27;, null, &#x27;Firing callback. &#x27; +
          &#x27;Ready state change has met provided state -&gt;&#x27;], readyState);
          hasTriggered = true;
          self.off(&#x27;readyStateChange&#x27;, readyStateChangeFn);
          callback(null,{
            serverUrl: self._path,
            readyState: self._readyState,
            appKey: self._appKey,
            roomServer: self._roomServer,
            defaultRoom: self._defaultRoom,
            selectedRoom: self._selectedRoom,
            serverRegion: self._serverRegion,
            enableDataChannel: self._enableDataChannel,
            enableIceTrickle: self._enableIceTrickle,
            enableTURNServer: self._enableTURN,
            enableSTUNServer: self._enableSTUN,
            TURNTransport: self._TURNTransport,
            audioFallback: self._audioFallback,
            forceSSL: self._forceSSL,
            socketTimeout: self._socketTimeout,
            forceTURNSSL: self._forceTURNSSL,
            audioCodec: self._selectedAudioCodec,
            videoCodec: self._selectedVideoCodec,
            forceTURN: self._forceTURN,
            usePublicSTUN: self._usePublicSTUN
          });
        } else if (readyState === self.READY_STATE_CHANGE.ERROR) {
          log.log([null, &#x27;Socket&#x27;, null, &#x27;Firing callback. &#x27; +
            &#x27;Ready state change has met provided state -&gt;&#x27;], readyState);
          log.debug([null, &#x27;Socket&#x27;, null, &#x27;Ready state met failure&#x27;], error);
          hasTriggered = true;
          self.off(&#x27;readyStateChange&#x27;, readyStateChangeFn);
          callback({
            error: new Error(error),
            errorCode: error.errorCode,
            status: error.status
          },null);
        }
      }
    };

    self.on(&#x27;readyStateChange&#x27;, readyStateChangeFn);
  }

  self._loadInfo();
};






    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
