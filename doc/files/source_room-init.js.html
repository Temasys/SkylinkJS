<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Temasys Documentation - SkylinkJS 0.9.0 - Web SDK</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- font and icon -->
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <!-- styling -->
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap-theme.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- scripts -->
    <script src="../assets/vendor/js/jquery.min.js"></script>
    <script src="../assets/vendor/js/bootstrap.min.js"></script>
    <script src="../assets/js/script.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" /><small>Version: 0.9.0</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Getting Started Examples <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="https://temasys.io/getting-started-with-webrtc-and-skylinkjs/">Setting up a Video Call</a></li>
      <li><a href="https://temasys.io/screensharing-with-skylinkjs/">Setting up Screensharing</a></li>
      <li><a href="https://temasys.io/building-a-simple-peer-to-peer-webrtc-chat/">Setting up a Chatroom</a></li>
    </ul>
  </li>
  
    <li><a href="../classes/Skylink.html">Documentation</a></li>
  
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
    </ul>
  </li>-->
  <li><a class="btn btn-info btn-navbar" href="https://console.temasys.io/">Developer Console</a></li>
  <li><a class="btn btn-info btn-navbar" href="http://support.temasys.io/">Support</a></li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
          
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content content-main">
                      <h1 class="file-heading">File: source/room-init.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Function that generates an &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;UUID&lt;/a&gt; (Unique ID).
 * @method generateUUID
 * @return {String} Returns a generated UUID (Unique ID).
 * @for Skylink
 * @since 0.5.9
 */
/* jshint ignore:start */
Skylink.prototype.generateUUID = function() {
  var d = new Date().getTime();
  var uuid = &#x27;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&#x27;.replace(/[xy]/g, function(c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c === &#x27;x&#x27; ? r : (r &amp;&amp; 0x7 | 0x8)).toString(16);
  });
  return uuid;
};
/* jshint ignore:end */

/**
 * Function that authenticates and initialises App Key used for Room connections.
 * @method init
 * @param {JSON|String} options The configuration options.
 * - When provided as a string, it&#x27;s configured as &lt;code&gt;options.appKey&lt;/code&gt;.
 * @param {String} options.appKey The App Key.
 *   &lt;small&gt;By default, &lt;code&gt;init()&lt;/code&gt; uses [HTTP CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)
 *   authentication. For credentials based authentication, see the &lt;code&gt;options.credentials&lt;/code&gt; configuration
 *   below. You can know more about the &lt;a href=&quot;http://support.temasys.io/support/solutions/articles/
 * 12000002712-authenticating-your-application-key-to-start-a-connection&quot;&gt;in the authentication methods article here&lt;/a&gt;
 *   for more details on the various authentication methods.&lt;/small&gt;
 *   &lt;small&gt;If you are using the Persistent Room feature for scheduled meetings, you will require to
 *   use the credential based authentication. See the &lt;a href=&quot;http://support.temasys.io/support
 * /solutions/articles/12000002811-using-the-persistent-room-feature-to-configure-meetings&quot;&gt;Persistent Room article here
 *   &lt;/a&gt; for more information.&lt;/small&gt;
 * @param {String} [options.defaultRoom] The default Room to connect to when no &lt;code&gt;room&lt;/code&gt; parameter
 *    is provided in  &lt;a href=&quot;#method_joinRoom&quot;&gt;&lt;code&gt;joinRoom()&lt;/code&gt; method&lt;/a&gt;.
 * - When not provided or is provided as an empty string, its value is &lt;code&gt;options.appKey&lt;/code&gt;.
 *   &lt;small&gt;Note that switching Rooms is not available when using &lt;code&gt;options.credentials&lt;/code&gt; based authentication.
 *   The Room that User will be connected to is the &lt;code&gt;defaultRoom&lt;/code&gt; provided.&lt;/small&gt;
 * @param {String} [options.roomServer] The Auth server for debugging purposes to use.
 *   &lt;small&gt;Note that this is a debugging feature and is only used when instructed for debugging purposes.&lt;/small&gt;
 * @param {Boolean} [options.enableIceTrickle=true] The flag if Peer connections should
 *   trickle ICE for faster connectivity.
 * @param {Boolean} [options.enableStatsGathering=true] Configure the anonymous performance and connectivity statistic collection function.
 *   Temasys collects encrypted, anonymous performance and connectivity statistics to allow us to improve performance for our customers and identify regional or ISP specific connectivity issues.
 *   This data does not contain any personal information or session content.
 *   To enable the configuration of this option, you need to &quot;Collect Quality Statistics&quot; option on the Temasys console Website under App key settings section. The default behavior for this option if not specifically configured is true.
 * @param {Boolean} [options.enableDataChannel=true] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that for Edge browsers, this value is overriden as &lt;code&gt;false&lt;/code&gt; due to its supports.
 *   &lt;/blockquote&gt; The flag if Datachannel connections should be enabled.
 *   &lt;small&gt;This is required to be enabled for &lt;a href=&quot;#method_sendBlobData&quot;&gt;&lt;code&gt;sendBlobData()&lt;/code&gt; method&lt;/a&gt;,
 *   &lt;a href=&quot;#method_sendURLData&quot;&gt;&lt;code&gt;sendURLData()&lt;/code&gt; method&lt;/a&gt; and
 *   &lt;a href=&quot;#method_sendP2PMessage&quot;&gt;&lt;code&gt;sendP2PMessage()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {Boolean} [options.enableTURNServer=true] The flag if TURN ICE servers should
 *   be used when constructing Peer connections to allow TURN connections when required and enabled for the App Key.
 * @param {Boolean} [options.enableSTUNServer=true] The flag if STUN ICE servers should
 *   be used when constructing Peer connections to allow TURN connections when required.
 * @param {Boolean} [options.forceTURN=false] The flag if Peer connections should enforce
 *   connections over the TURN server.
 *   &lt;small&gt;This overrides &lt;code&gt;options.enableTURNServer&lt;/code&gt; value to &lt;code&gt;true&lt;/code&gt; and
 *   &lt;code&gt;options.enableSTUNServer&lt;/code&gt; value to &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;options.filterCandidatesType.host&lt;/code&gt;
 *   value to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;options.filterCandidatesType.srflx&lt;/code&gt; value to &lt;code&gt;true&lt;/code&gt; and
 *   &lt;code&gt;options.filterCandidatesType.relay&lt;/code&gt; value to &lt;code&gt;false&lt;/code&gt;.&lt;/small&gt;
 *   &lt;small&gt;Note that currently for MCU enabled Peer connections, the &lt;code&gt;options.filterCandidatesType&lt;/code&gt;
 *   configuration is not honoured as Peers connected with MCU is similar as a forced TURN connection. The flags
 *   will act as if the value is &lt;code&gt;false&lt;/code&gt; and ICE candidates will never be filtered regardless of the
 *   &lt;code&gt;options.filterCandidatesType&lt;/code&gt; configuration.&lt;/small&gt;
 * @param {Boolean} [options.usePublicSTUN=false] The flag if publicly available STUN ICE servers should
 *   be used if &lt;code&gt;options.enableSTUNServer&lt;/code&gt; is enabled.
 * @param {Boolean} [options.TURNServerTransport] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that configuring the protocol may not necessarily result in the desired network transports protocol
 *   used in the actual TURN network traffic as it depends which protocol the browser selects and connects with.
 *   This simply configures the TURN ICE server urls &lt;code?transport=(protocol)&lt;/code&gt; query option when constructing
 *   the Peer connection. When all protocols are selected, the ICE servers urls are duplicated with all protocols.&lt;br&gt;
 *   Note that for Edge browsers, this value is overriden as &lt;code&gt;UDP&lt;/code&gt; due to its supports.
 *   &lt;/blockquote&gt; The option to configure the &lt;code&gt;?transport=&lt;/code&gt;
 *   query parameter in TURN ICE servers when constructing a Peer connections.
 * - When not provided, its value is &lt;code&gt;ANY&lt;/code&gt;.
 *   [Rel: Skylink.TURN_TRANSPORT]
 * @param {Boolean} [options.disableVideoFecCodecs=false] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this is an experimental flag and may cause disruptions in connections or connectivity issues when toggled,
 *   and to prevent connectivity issues, these codecs will not be removed for MCU enabled Peer connections.
 *   &lt;/blockquote&gt; The flag if video FEC (Forward Error Correction)
 *   codecs like ulpfec and red should be removed in sending session descriptions.
 *   &lt;small&gt;This can be useful for debugging purposes to prevent redundancy and overheads in RTP encoding.&lt;/small&gt;
 * @param {Boolean} [options.disableComfortNoiseCodec=false] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this is an experimental flag and may cause disruptions in connections or connectivity issues when toggled.
 *   &lt;/blockquote&gt; The flag if audio
 *   &lt;a href=&quot;https://en.wikipedia.org/wiki/Comfort_noise&quot;&gt;Comfort Noise (CN)&lt;/a&gt; codec should be removed
 *   in sending session descriptions.
 *   &lt;small&gt;This can be useful for debugging purposes to test preferred audio quality and feedback.&lt;/small&gt;
 * @param {Boolean} [options.disableREMB=false] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this is mainly used for debugging purposes and that it is an experimental flag, so
 *   it may cause disruptions in connections or connectivity issues when toggled. &lt;/blockquote&gt;
 *   The flag if video REMB feedback packets should be disabled in sending session descriptions.
 * @param {JSON} [options.credentials] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that we strongly recommend developers to return the &lt;code&gt;options.credentials.duration&lt;/code&gt;,
 *   &lt;code&gt;options.credentials.startDateTime&lt;/code&gt; and &lt;code&gt;options.defaultRoom&lt;/code&gt; and generate the
 *   &lt;code&gt;options.credentials.credentials&lt;/code&gt; from a web server as secret shouldn&#x27;t be exposed on client web app as
 *   it poses a security risk itself.&lt;/blockquote&gt;
 *   The credentials used for authenticating App Key with
 *   credentials to retrieve the Room session token used for connection in &lt;a href=&quot;#method_joinRoom&quot;&gt;
 *   &lt;code&gt;joinRoom()&lt;/code&gt; method&lt;/a&gt;.
 *   &lt;small&gt;Note that switching of Rooms is not allowed when using credentials based authentication, unless
 *   &lt;code&gt;init()&lt;/code&gt; is invoked again with a different set of credentials followed by invoking
 *   the &lt;a href=&quot;#method_joinRoom&quot;&gt;&lt;code&gt;joinRoom()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 * @param {String} options.credentials.startDateTime The credentials User session in Room starting DateTime
 *   in &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 format&lt;/a&gt;.
 * @param {Number} options.credentials.duration The credentials User session in Room duration in hours.
 * @param {String} options.credentials.credentials The generated credentials used to authenticate
 *   the provided App Key with its &lt;code&gt;&quot;secret&quot;&lt;/code&gt; property.
 *   &lt;blockquote class=&quot;details&quot;&gt;&lt;h5&gt;To generate the credentials:&lt;/h5&gt;&lt;ol&gt;
 *   &lt;li&gt;Concatenate a string that consists of the Room name you provide in the &lt;code&gt;options.defaultRoom&lt;/code&gt;,
 *   the &lt;code&gt;options.credentials.duration&lt;/code&gt; and the &lt;code&gt;options.credentials.startDateTime&lt;/code&gt;.
 *   &lt;small&gt;Example: &lt;code&gt;var concatStr = defaultRoom + &quot;_&quot; + duration + &quot;_&quot; + startDateTime;&lt;/code&gt;&lt;/small&gt;&lt;/li&gt;
 *   &lt;li&gt;Hash the concatenated string with the App Key &lt;code&gt;&quot;secret&quot;&lt;/code&gt; property using
 *   &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt;.
 *   &lt;small&gt;Example: &lt;code&gt;var hash = CryptoJS.HmacSHA1(concatStr, appKeySecret);&lt;/code&gt;&lt;/small&gt;
 *   &lt;small&gt;See the &lt;a href=&quot;https://code.google.com/p/crypto-js/#HMAC&quot;&gt;&lt;code&gt;CryptoJS.HmacSHA1&lt;/code&gt; library&lt;/a&gt;.&lt;/small&gt;&lt;/li&gt;
 *   &lt;li&gt;Encode the hashed string using &lt;a href=&quot;https://en.wikipedia.org/wiki/Base64&quot;&gt;base64&lt;/a&gt;
 *   &lt;small&gt;Example: &lt;code&gt;var b64Str = hash.toString(CryptoJS.enc.Base64);&lt;/code&gt;&lt;/small&gt;
 *   &lt;small&gt;See the &lt;a href=&quot;https://code.google.com/p/crypto-js/#The_Cipher_Output&quot;&gt;CryptoJS.enc.Base64&lt;/a&gt; library&lt;/a&gt;.&lt;/small&gt;&lt;/li&gt;
 *   &lt;li&gt;Encode the base64 encoded string to replace special characters using UTF-8 encoding.
 *   &lt;small&gt;Example: &lt;code&gt;var credentials = encodeURIComponent(base64String);&lt;/code&gt;&lt;/small&gt;
 *   &lt;small&gt;See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/
 * Global_Objects/encodeURIComponent&quot;&gt;encodeURIComponent() API&lt;/a&gt;.&lt;/small&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;
 * @param {Boolean} [options.audioFallback=false] The flag if &lt;a href=&quot;#method_getUserMedia&quot;&gt;
 *   &lt;code&gt;getUserMedia()&lt;/code&gt; method&lt;/a&gt; should fallback to retrieve only audio Stream when
 *   retrieving audio and video Stream fails.
 * @param {Boolean} [options.forceSSL=true] The flag if HTTPS connections should be enforced
 *   during request to Auth server and socket connections to Signaling server
 *   when accessing &lt;code&gt;window.location.protocol&lt;/code&gt; value is &lt;code&gt;&quot;http:&quot;&lt;/code&gt;.
 *   &lt;small&gt;By default, &lt;code&gt;&quot;https:&quot;&lt;/code&gt; protocol connections uses HTTPS connections.&lt;/small&gt;
 * @param {String|JSON} [options.audioCodec] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that if the audio codec is not supported, the SDK will not configure the local &lt;code&gt;&quot;offer&quot;&lt;/code&gt; or
 *   &lt;code&gt;&quot;answer&quot;&lt;/code&gt; session description to prefer the codec.&lt;br&gt;
 *   Note that for Edge browsers, this value is set as &lt;code&gt;OPUS&lt;/code&gt; due to its supports.&lt;/blockquote&gt;
 *   The option to configure the preferred audio codec to use to encode sending audio data when available for Peer connection.
 * - When not provided, its value is &lt;code&gt;AUTO&lt;/code&gt;.
 *   [Rel: Skylink.AUDIO_CODEC]
 * @param {String} options.audioCodec.codec The audio codec to prefer to encode sending audio data when available.
 *   &lt;small&gt;The value must not be &lt;code&gt;AUTO&lt;/code&gt;.&lt;/small&gt;
 *   [Rel: Skylink.AUDIO_CODEC]
 * @param {Number} [options.audioCodec.samplingRate] The audio codec sampling to prefer to encode sending audio data when available.
 * @param {Number} [options.audioCodec.channels] The audio codec channels to prefer to encode sending audio data when available.
 * @param {String|JSON} [options.videoCodec] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that if the video codec is not supported, the SDK will not configure the local &lt;code&gt;&quot;offer&quot;&lt;/code&gt; or
 *   &lt;code&gt;&quot;answer&quot;&lt;/code&gt; session description to prefer the codec.&lt;br&gt;
 *   Note that for Edge browsers, this value is set as &lt;code&gt;H264&lt;/code&gt; due to its supports.&lt;/blockquote&gt;
 *   The option to configure the preferred video codec to use to encode sending video data when available for Peer connection.
 * - When not provided, its value is &lt;code&gt;AUTO&lt;/code&gt;.
 *   [Rel: Skylink.VIDEO_CODEC]
 * @param {String} options.videoCodec.codec The video codec to prefer to encode sending audio data when available.
 *   &lt;small&gt;The value must not be &lt;code&gt;AUTO&lt;/code&gt;.&lt;/small&gt;
 *   [Rel: Skylink.VIDEO_CODEC]
 * @param {Number} [options.videoCodec.samplingRate] The video codec sampling to prefer to encode sending video data when available.
 * @param {Number} [options.socketTimeout=7000] The timeout for each attempts for socket connection
 *   with the Signaling server to indicate that connection has timed out and has failed to establish.
 *   &lt;small&gt;Note that the mininum timeout value is &lt;code&gt;5000&lt;/code&gt;. If less, this value will be &lt;code&gt;5000&lt;/code&gt;.&lt;/small&gt;
 *   &lt;small&gt;Note that it is recommended to use &lt;code&gt;7000&lt;/code&gt; as the lowest timeout value if Peers are connecting
 *   using Polling transports to prevent connection errors.&lt;/small&gt;
 * @param {Number} [options.apiTimeout=4000] The timeout to wait for response from Auth server.
 * @param {Boolean} [options.forceTURNSSL=false] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that currently Firefox does not support the TURNS protocol, and that if TURNS is required,
 *   TURN ICE servers using port &lt;code&gt;443&lt;/code&gt; will be used instead.&lt;br&gt;
 *   Note that for Edge browsers, this value is overriden as &lt;code&gt;false&lt;/code&gt; due to its supports and
 *   only port &lt;code&gt;3478&lt;/code&gt; is used.&lt;/blockquote&gt;
 *   The flag if TURNS protocol should be used when &lt;code&gt;options.enableTURNServer&lt;/code&gt; is enabled.
 * @param {JSON} [options.filterCandidatesType] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this a debugging feature and there might be connectivity issues when toggling these flags.
 *   &lt;/blockquote&gt; The configuration options to filter the type of ICE candidates sent and received.
 * @param {Boolean} [options.filterCandidatesType.host=false] The flag if local network ICE candidates should be filtered out.
 * @param {Boolean} [options.filterCandidatesType.srflx=false] The flag if STUN ICE candidates should be filtered out.
 * @param {Boolean} [options.filterCandidatesType.relay=false] The flag if TURN ICE candidates should be filtered out.
 * @param {JSON} [options.throttleIntervals] The configuration options to configure the throttling method timeouts.
 * @param {Number} [options.throttleIntervals.shareScreen=10000] The interval timeout for
 *   &lt;a href=&quot;#method_shareScreen&quot;&gt;&lt;code&gt;shareScreen()&lt;/code&gt; method&lt;/a&gt; throttling in milliseconds.
 * @param {Number} [options.throttleIntervals.getUserMedia=0] The interval timeout for
 *   &lt;a href=&quot;#method_getUserMedia&quot;&gt;&lt;code&gt;getUserMedia()&lt;/code&gt; method&lt;/a&gt; throttling in milliseconds.
 * @param {Number} [options.throttleIntervals.refreshConnection=5000] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this throttling is only done for MCU enabled Peer connections with the
 *   &lt;code&gt;options.mcuUseRenegoRestart&lt;/code&gt; being set to &lt;code&gt;false&lt;/code&gt;.
 *   &lt;/blockquote&gt; The interval timeout for &lt;a href=&quot;#method_refreshConnection&quot;&gt;
 *   &lt;code&gt;refreshConnection()&lt;/code&gt; method&lt;/a&gt; throttling in milliseconds.
 *   &lt;small&gt;Note that there will be no throttling when &lt;a href=&quot;#method_refreshConnection&quot;&gt;
 *   &lt;code&gt;refreshConnection()&lt;/code&gt; method&lt;/a&gt; is called internally.&lt;/small&gt;
 * @param {Boolean} [options.throttleShouldThrowError=false] The flag if throttled methods should throw errors when
 *   method is invoked less than the interval timeout value configured in &lt;code&gt;options.throttleIntervals&lt;/code&gt;.
 * @param {Boolean} [options.mcuUseRenegoRestart=true] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this feature is currently is beta and for any enquiries on enabling and its support, please
 *   contact &lt;a href=&quot;http://support.temasys.io&quot;&gt;our support portal&lt;/a&gt;.&lt;/blockquote&gt;
 *   The flag if &lt;a href=&quot;#method_refreshConnection&quot;&gt;&lt;code&gt;
 *   refreshConnection()&lt;/code&gt; method&lt;/a&gt; should renegotiate like non-MCU enabled Peer connection for MCU
 *   enabled Peer connections instead of invoking &lt;a href=&quot;#method_joinRoom&quot;&gt;&lt;code&gt;joinRoom()&lt;/code&gt; method&lt;/a&gt; again.
 * @param {String|Array} [options.iceServer] The ICE servers for debugging purposes to use.
 *   - When defined as string, the value is considered as &lt;code&gt;[options.iceServer]&lt;/code&gt;.
 *   &lt;small&gt;Note that this is a debugging feature and is only used when instructed for debugging purposes.&lt;/small&gt;
 * @param {String} [options.iceServer.#index] The ICE server url for debugging purposes to use.
 * @param {String|JSON} [options.socketServer] The Signaling server for debugging purposes to use.
 *   - When defined as string, the value is considered as &lt;code&gt;{ url: options.socketServer }&lt;/code&gt;.
 *   &lt;small&gt;Note that this is a debugging feature and is only used when instructed for debugging purposes.&lt;/small&gt;
 * @param {String} options.socketServer.url The Signaling server URL for debugging purposes to use.
 * @param {Array} [options.socketServer.ports] The list of Signaling server ports for debugging purposes to use.
 *   &lt;small&gt;If not defined, it will use the default list of ports specified.&lt;/small&gt;
 * @param {Number} options.socketServer.ports.#index The Signaling server port to fallback and use for debugging purposes.
 * @param {String} [options.socketServer.protocol] The Signaling server protocol for debugging purposes to use.
 *   &lt;small&gt;If not defined, it will use the default protocol specified.&lt;/small&gt;
 * @param {JSON} [options.codecParams] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that some of these parameters are mainly used for experimental or debugging purposes. Toggling any of
 *   these feature may result in disruptions in connectivity.&lt;/blockquote&gt;
 *   The audio and video codecs parameters to configure.
 * @param {JSON} [options.codecParams.video] The video codecs parameters to configure.
 * @param {JSON} [options.codecParams.video.h264] The H264 video codec parameters to configure.
 * @param {String} [options.codecParams.video.h264.profileLevelId] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this parameter should only be used for debugging purposes only.&lt;/blockquote&gt;
 *   The H264 video codec base16 encoded string which indicates the H264 baseline, main, or the extended profiles.
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {Boolean} [options.codecParams.video.h264.levelAsymmetryAllowed] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this is an experimental parameter which may result in connectivity issues when toggled.&lt;/blockquote&gt;
 *   The flag if streaming H264 sending video data should be encoded at a different level
 *   from receiving video data from Peer encoding to User when Peer is the offerer.
 *   &lt;small&gt;If Peer is the offerer instead of the User, the Peer&#x27;s &lt;code&gt;peerInfo.config.priorityWeight&lt;/code&gt; will be
 *   higher than User&#x27;s &lt;code&gt;peerInfo.config.priorityWeight&lt;/code&gt;.&lt;/small&gt;
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {Number} [options.codecParams.video.h264.packetizationMode] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this is an experimental parameter which may result in connectivity issues when enabled. It is
 *   advisable to turn off this feature off when receiving H264 decoders do not support the packetization mode,
 *   which may result in a blank receiving video stream.&lt;/blockquote&gt;
 *   The flag to enable H264 video codec packetization mode, which splits video frames that are larger
 *   for a RTP packet into RTP packet chunks.
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {JSON} [options.codecParams.video.vp8] The VP8 video codec parameters to configure.
 * @param {Number} [options.codecParams.video.vp8.maxFr] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this parameter should only be used for debugging purposes only. Do not toggle this otherwise.&lt;/blockquote&gt;
 *   The maximum number of fps (frames per second) that the VP8 video codec decoder is capable of
 *   decoding when receiving encoded video data packets.
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {Number} [options.codecParams.video.vp8.maxFs] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this parameter should only be used for debugging purposes only. Do not toggle this otherwise.&lt;/blockquote&gt;
 *   The maximum number of frame size macroblocks that the VP8 video codec decoder is capable of
 *   decoding when receiving encoded video data packets.
 *   &lt;small&gt;The value has to have the width and height of the frame in macroblocks less than the value of
 *   &lt;code&gt;parseInt(Math.sqrt(maxFs * 8))&lt;/code&gt;. E.g. If the value is &lt;code&gt;1200&lt;/code&gt;, it is capable of
 *   support &lt;code&gt;640x480&lt;/code&gt; frame width and height, which heights up to &lt;code&gt;1552px&lt;/code&gt;
 *   (&lt;code&gt;97&lt;/code&gt; macroblocks value.&lt;/small&gt;
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {JSON} [options.codecParams.video.vp9] The VP9 video codec parameters to configure.
 * @param {Number} [options.codecParams.video.vp9.maxFr] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this parameter should only be used for debugging purposes only. Do not toggle this otherwise.&lt;/blockquote&gt;
 *   The maximum number of fps (frames per second) that the VP9 video codec decoder is capable of
 *   decoding when receiving encoded video data packets.
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {Number} [options.codecParams.video.vp9.maxFs] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this parameter should only be used for debugging purposes only. Do not toggle this otherwise.&lt;/blockquote&gt;
 *   The maximum number of frame size macroblocks that the VP9 video codec decoder is capable of
 *   decoding when receiving encoded video data packets.
 *   &lt;small&gt;The value has to have the width and height of the frame in macroblocks less than the value of
 *   &lt;code&gt;parseInt(Math.sqrt(maxFs * 8))&lt;/code&gt;. E.g. If the value is &lt;code&gt;1200&lt;/code&gt;, it is capable of
 *   support &lt;code&gt;640x480&lt;/code&gt; frame width and height, which heights up to &lt;code&gt;1552px&lt;/code&gt;
 *   (&lt;code&gt;97&lt;/code&gt; macroblocks value.&lt;/small&gt;
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {JSON} [options.codecParams.audio] The audio codecs parameters to configure.
 * @param {JSON} [options.codecParams.audio.opus] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this is only applicable to OPUS audio codecs with a sampling rate of &lt;code&gt;48000&lt;/code&gt; Hz (hertz).
 *   &lt;/blockquote&gt; The OPUS audio codec parameters to configure.
 * @param {Boolean} [options.codecParams.audio.opus.stereo] The flag if OPUS audio codec is able to decode or receive stereo packets.
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {Boolean} [options.codecParams.audio.opus.sprop-stereo] The flag if OPUS audio codec is sending stereo packets.
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {Boolean} [options.codecParams.audio.opus.usedtx] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this feature might not work depending on the browser support and implementation.&lt;/blockquote&gt;
 *   The flag if OPUS audio codec should enable DTX (Discontinuous Transmission) for sending encoded audio data.
 *   &lt;small&gt;This might help to reduce bandwidth as it reduces the bitrate during silence or background noise, and
 *   goes hand-in-hand with the &lt;code&gt;options.voiceActivityDetection&lt;/code&gt; flag in &lt;a href=&quot;#method_joinRoom&quot;&gt;
 *   &lt;code&gt;joinRoom()&lt;/code&gt; method&lt;/a&gt;.&lt;/small&gt;
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {Boolean} [options.codecParams.audio.opus.useinbandfec] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this parameter should only be used for debugging purposes only.&lt;/blockquote&gt;
 *   The flag if OPUS audio codec has the capability to take advantage of the in-band FEC
 *   (Forward Error Correction) when sending encoded audio data.
 *   &lt;small&gt;This helps to reduce the harm of packet loss by encoding information about the previous packet loss.&lt;/small&gt;
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {Number} [options.codecParams.audio.opus.maxplaybackrate] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this parameter should only be used for debugging purposes only.&lt;/blockquote&gt;
 *   The OPUS audio codec maximum output sampling rate in Hz (hertz) that is is capable of receiving
 *   decoded audio data, to adjust to the hardware limitations and ensure that any sending audio data
 *   would not encode at a higher sampling rate specified by this.
 *   &lt;small&gt;This value must be between &lt;code&gt;8000&lt;/code&gt; to &lt;code&gt;48000&lt;/code&gt;.&lt;/small&gt;
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {Number} [options.codecParams.minptime] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this parameter should only be used for debugging purposes only.&lt;/blockquote&gt;
 *   The OPUS audio codec receiving audio data decoder minimum length of time in milleseconds should be
 *   encapsulated in a single received encoded audio data packet.
 *   &lt;small&gt;This value must be between &lt;code&gt;3&lt;/code&gt; to &lt;code&gt;120&lt;/code&gt;&lt;/small&gt;
 *   &lt;small&gt;When not provided, the default browser configuration is used.&lt;/small&gt;
 * @param {String} [options.priorityWeightScheme] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this parameter should only be used for debugging purposes only and may not work when
 *   internals change.&lt;/blockquote&gt; The User&#x27;s priority weight to enforce User as offerer or answerer.
 * - When not provided, its value is &lt;code&gt;AUTO&lt;/code&gt;.
 *   [Rel: Skylink.PRIORITY_WEIGHT_SCHEME]
 * @param {Boolean} [options.useEdgeWebRTC=false] The flag to use Edge 15.x pre-1.0 WebRTC support.
 * @param {Boolean} [options.enableSimultaneousTransfers=true] The flag to enable simultaneous data transfers.
 * @param {Function} [callback] The callback function fired when request has completed.
 *   &lt;small&gt;Function parameters signature is &lt;code&gt;function (error, success)&lt;/code&gt;&lt;/small&gt;
 *   &lt;small&gt;Function request completion is determined by the &lt;a href=&quot;#event_readyStateChange&quot;&gt;
 *   &lt;code&gt;readyStateChange&lt;/code&gt; event&lt;/a&gt; &lt;code&gt;state&lt;/code&gt; parameter payload value
 *   as &lt;code&gt;COMPLETED&lt;/code&gt; for request success.&lt;/small&gt;
 *   [Rel: Skylink.READY_STATE_CHANGE]
 * @param {JSON|String} callback.error The error result in request.
 * - When defined as string, it&#x27;s the error when required App Key is not provided.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are no errors in request&lt;/small&gt;
 * @param {Number} callback.error.errorCode The &lt;a href=&quot;#event_readyStateChange&quot;&gt;&lt;code&gt;readyStateChange&lt;/code&gt;
 *   event&lt;/a&gt; &lt;code&gt;error.errorCode&lt;/code&gt; parameter payload value.
 *   [Rel: Skylink.READY_STATE_CHANGE_ERROR]
 * @param {Error|String} callback.error.error The &lt;a href=&quot;#event_readyStateChange&quot;&gt;&lt;code&gt;readyStateChange&lt;/code&gt;
 *   event&lt;/a&gt; &lt;code&gt;error.content&lt;/code&gt; parameter payload value.
 * @param {Number} callback.error.status The &lt;a href=&quot;#event_readyStateChange&quot;&gt;&lt;code&gt;readyStateChange&lt;/code&gt;
 *   event&lt;/a&gt; &lt;code&gt;error.status&lt;/code&gt; parameter payload value.
 * @param {JSON} callback.success The success result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are errors in request&lt;/small&gt;
 * @param {String} callback.success.serverUrl The constructed REST URL requested to Auth server.
 * @param {Number} callback.success.readyState The current ready state.
 *   [Rel: Skylink.READY_STATE_CHANGE]
 * @param {String} callback.success.selectedRoom The Room based on the current Room session token retrieved for.
 * @param {String} callback.success.appKey The configured value of the &lt;code&gt;options.appKey&lt;/code&gt;.
 * @param {String} callback.success.defaultRoom The configured value of the &lt;code&gt;options.defaultRoom&lt;/code&gt;.
 * @param {String} callback.success.roomServer The configured value of the &lt;code&gt;options.roomServer&lt;/code&gt;.
 * @param {Boolean} callback.success.enableIceTrickle The configured value of the &lt;code&gt;options.enableIceTrickle&lt;/code&gt;.
 * @param {Boolean} callback.success.enableDataChannel The configured value of the &lt;code&gt;options.enableDataChannel&lt;/code&gt;.
 * @param {Boolean} callback.success.enableTURNServer The configured value of the &lt;code&gt;options.enableTURNServer&lt;/code&gt;.
 * @param {Boolean} callback.success.enableSTUNServer The configured value of the &lt;code&gt;options.enableSTUNServer&lt;/code&gt;.
 * @param {Boolean} callback.success.TURNTransport The configured value of the &lt;code&gt;options.TURNServerTransport&lt;/code&gt;.
 * @param {Boolean} callback.success.audioFallback The configured value of the &lt;code&gt;options.audioFallback&lt;/code&gt;.
 * @param {Boolean} callback.success.forceSSL The configured value of the &lt;code&gt;options.forceSSL&lt;/code&gt;.
 * @param {String|JSON} callback.success.audioCodec The configured value of the &lt;code&gt;options.audioCodec&lt;/code&gt;.
 * @param {String|JSON} callback.success.videoCodec The configured value of the &lt;code&gt;options.videoCodec&lt;/code&gt;.
 * @param {Number} callback.success.socketTimeout The configured value of the &lt;code&gt;options.socketTimeout&lt;/code&gt;.
 * @param {Number} callback.success.apiTimeout The configured value of the &lt;code&gt;options.apiTimeout&lt;/code&gt;.
 * @param {Boolean} callback.success.forceTURNSSL The configured value of the &lt;code&gt;options.forceTURNSSL&lt;/code&gt;.
 * @param {Boolean} callback.success.forceTURN The configured value of the &lt;code&gt;options.forceTURN&lt;/code&gt;.
 * @param {Boolean} callback.success.usePublicSTUN The configured value of the &lt;code&gt;options.usePublicSTUN&lt;/code&gt;.
 * @param {Boolean} callback.success.disableVideoFecCodecs The configured value of the &lt;code&gt;options.disableVideoFecCodecs&lt;/code&gt;.
 * @param {Boolean} callback.success.disableComfortNoiseCodec The configured value of the &lt;code&gt;options.disableComfortNoiseCodec&lt;/code&gt;.
 * @param {Boolean} callback.success.disableREMB The configured value of the &lt;code&gt;options.disableREMB&lt;/code&gt;.
 * @param {JSON} callback.success.filterCandidatesType The configured value of the &lt;code&gt;options.filterCandidatesType&lt;/code&gt;.
 * @param {JSON} callback.success.throttleIntervals The configured value of the &lt;code&gt;options.throttleIntervals&lt;/code&gt;.
 * @param {Boolean} callback.success.throttleShouldThrowError The configured value of the &lt;code&gt;options.throttleShouldThrowError&lt;/code&gt;.
 * @param {JSON} callback.success.mcuUseRenegoRestart The configured value of the &lt;code&gt;options.mcuUseRenegoRestart&lt;/code&gt;.
 * @param {JSON} callback.success.iceServer The configured value of the &lt;code&gt;options.iceServer&lt;/code&gt;.
 *   &lt;small&gt;See the &lt;code&gt;.urls&lt;/code&gt; property in this object for configured value if defined.&lt;/small&gt;
 * @param {JSON|String} callback.success.socketServer The configured value of the &lt;code&gt;options.socketServer&lt;/code&gt;.
 * @param {Boolean} callback.success.useEdgeWebRTC The configured value of the &lt;code&gt;options.useEdgeWebRTC&lt;/code&gt;.
 * @param {Boolean} callback.success.enableSimultaneousTransfers The configured value of the &lt;code&gt;options.enableSimultaneousTransfers&lt;/code&gt;.
 * @example
 *   // Example 1: Using CORS authentication and connection to default Room
 *   skylinkDemo(appKey, function (error, success) {
 *     if (error) return;
 *     skylinkDemo.joinRoom(); // Goes to default Room
 *   });
 *
 *   // Example 2: Using CORS authentication and connection to a different Room
 *   skylinkDemo(appKey, function (error, success) {
 *     skylinkDemo.joinRoom(&quot;testxx&quot;); // Goes to &quot;testxx&quot; Room
 *   });
 *
 *   // Example 3: Using credentials authentication and connection to only default Room
 *   var defaultRoom   = &quot;test&quot;,
 *       startDateTime = (new Date()).toISOString(),
 *       duration      = 1, // Allows only User session to stay for 1 hour
 *       appKeySecret  = &quot;xxxxxxx&quot;,
 *       hash          = CryptoJS.HmacSHA1(defaultRoom + &quot;\_&quot; + duration + &quot;\_&quot; + startDateTime, appKeySecret);
 *       credentials   = encodeURIComponent(hash.toString(CryptoJS.enc.Base64));
 *
 *   skylinkDemo({
 *     defaultRoom: defaultRoom,
 *     appKey: appKey,
 *     credentials: {
 *       duration: duration,
 *       startDateTime: startDateTime,
 *       credentials: credentials
 *     }
 *   }, function (error, success) {
 *     if (error) return;
 *     skylinkDemo.joinRoom(); // Goes to default Room (switching to different Room is not allowed for credentials authentication)
 *   });
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *   &lt;li&gt;If parameter &lt;code&gt;options&lt;/code&gt; is not provided: &lt;ol&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Checks if dependecies and browser APIs are available. &lt;ol&gt;&lt;li&gt;If AdapterJS is not loaded: &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_readyStateChange&quot;&gt;&lt;code&gt;readyStateChange&lt;/code&gt; event&lt;/a&gt; triggers
 *   parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt; and &lt;code&gt;error.errorCode&lt;/code&gt; as
 *   &lt;code&gt;ADAPTER_NO_LOADED&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If socket.io-client is not loaded: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_readyStateChange&quot;&gt;
 *   &lt;code&gt;readyStateChange&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt;
 *   as &lt;code&gt;ERROR&lt;/code&gt; and &lt;code&gt;error.errorCode&lt;/code&gt; as &lt;code&gt;NO_SOCKET_IO&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; and return error. &lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;If XMLHttpRequest API is not available: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_readyStateChange&quot;&gt;
 *   &lt;code&gt;readyStateChange&lt;/code&gt; event&lt;/a&gt; triggers parameter payload &lt;code&gt;state&lt;/code&gt;
 *   as &lt;code&gt;ERROR&lt;/code&gt; and &lt;code&gt;error.errorCode&lt;/code&gt; as &lt;code&gt;NO_XMLHTTPREQUEST_SUPPORT&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;If WebRTC is not supported by device: &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_readyStateChange&quot;&gt;&lt;code&gt;readyStateChange&lt;/code&gt; event&lt;/a&gt; triggers parameter
 *   payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt; and &lt;code&gt;error.errorCode&lt;/code&gt; as
 *   &lt;code&gt;NO_WEBRTC_SUPPORT&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Retrieves Room session token from Auth server. &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_readyStateChange&quot;&gt;&lt;code&gt;readyStateChange&lt;/code&gt; event&lt;/a&gt; triggers
 *   parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;LOADING&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;If retrieval was successful: &lt;ol&gt;&lt;li&gt;&lt;a href=&quot;#event_readyStateChange&quot;&gt;&lt;code&gt;readyStateChange&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;COMPLETED&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;Else: &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_readyStateChange&quot;&gt;&lt;code&gt;readyStateChange&lt;/code&gt; event&lt;/a&gt; triggers parameter
 *   payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;ERROR&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype.init = function(_options, _callback) {
  var self = this;
  var options = {};
  var callback = function () {};

  // &#x60;init(function () {})&#x60;
  if (typeof _options === &#x27;function&#x27;){
    callback = _options;

  // &#x60;init({})&#x60;
  } else if (_options &amp;&amp; typeof _options === &#x27;object&#x27;) {
    options = clone(_options);

    // &#x60;init({ apiKey: &quot;xxxxx&quot; })&#x60; (fallback for older documentation)
    if (!(options.appKey &amp;&amp; typeof options.appKey === &#x27;string&#x27;) &amp;&amp;
      (options.apiKey &amp;&amp; typeof options.apiKey === &#x27;string&#x27;)) {
      options.appKey = options.apiKey;
    }

  // &#x60;init(&quot;xxxxx&quot;)&#x60; (for just the options.appKey being provided)
  } else if (_options &amp;&amp; typeof _options === &#x27;string&#x27;) {
    options.appKey = _options;
  }

  // &#x60;init(.., function () {})&#x60;
  if (typeof _callback === &#x27;function&#x27;) {
    callback = _callback;
  }

  // &#x60;init({ defaultRoom: &quot;xxxxx&quot; })&#x60;
  options.defaultRoom = options.defaultRoom &amp;&amp; typeof options.defaultRoom === &#x27;string&#x27; ? options.defaultRoom : options.appKey;

  // &#x60;init({ roomServer: &quot;//server.temasys.io&quot; })&#x60;
  options.roomServer = options.roomServer &amp;&amp; typeof options.roomServer === &#x27;string&#x27; ? options.roomServer : &#x27;//api.temasys.io&#x27;;

  // &#x60;init({ statsServer: &quot;//server.temasys.io&quot; })&#x60;
  options.statsServer = options.statsServer &amp;&amp; typeof options.statsServer === &#x27;string&#x27; ? options.statsServer : &#x27;//api.temasys.io&#x27;;

  // &#x60;init({ enableIceTrickle: true })&#x60;
  options.enableIceTrickle = options.enableIceTrickle !== false;

  // &#x60;init({ enableIceTrickle: true })&#x60;
  options.enableDataChannel = options.enableDataChannel !== false;

  // &#x60;init({ enableSTUNServer: true })&#x60;
  options.enableSTUNServer = options.enableSTUNServer !== false;

  // &#x60;init({ enableTURNServer: true })&#x60;
  options.enableTURNServer = options.enableTURNServer !== false;

  // &#x60;init({ audioFallback: true })&#x60;
  options.audioFallback = options.audioFallback === true;

  // &#x60;init({ forceSSL: true })&#x60;
  options.forceSSL = options.forceSSL !== false;

  // &#x60;init({ enableStatsGathering: true })&#x60;
  options.enableStatsGathering = options.enableStatsGathering !== false;

  // &#x60;init({ socketTimeout: 20000 })&#x60;
  options.socketTimeout = typeof options.socketTimeout === &#x27;number&#x27; &amp;&amp; options.socketTimeout &gt;= 5000 ? options.socketTimeout : 7000;

  // &#x60;init({ socketTimeout: 4000 })&#x60;
  options.apiTimeout = typeof options.apiTimeout === &#x27;number&#x27; ? options.apiTimeout : 4000;

  // &#x60;init({ forceTURNSSL: false })&#x60;
  options.forceTURNSSL = options.forceTURNSSL === true;

  // &#x60;init({ forceTURN: false })&#x60;
  options.forceTURN = options.forceTURN === true;

  // &#x60;init({ usePublicSTUN: false })&#x60;
  options.usePublicSTUN = options.usePublicSTUN === true;

  // &#x60;init({ disableVideoFecCodecs: false })&#x60;
  options.disableVideoFecCodecs = options.disableVideoFecCodecs === true;

  // &#x60;init({ disableComfortNoiseCodec: false })&#x60;
  options.disableComfortNoiseCodec = options.disableComfortNoiseCodec === true;

  // &#x60;init({ disableREMB: false })&#x60;
  options.disableREMB = options.disableREMB === true;

  // &#x60;init({ throttleShouldThrowError: false })&#x60;
  options.throttleShouldThrowError = options.throttleShouldThrowError === true;

  // &#x60;init({ mcuUseRenegoRestart: true })&#x60;
  options.mcuUseRenegoRestart = options.mcuUseRenegoRestart === false;

  // &#x60;init({ useEdgeWebRTC: false })&#x60;
  options.useEdgeWebRTC = options.useEdgeWebRTC === true;

  // &#x60;init({ enableSimultaneousTransfers: true })&#x60;
  options.enableSimultaneousTransfers = options.enableSimultaneousTransfers !== false;

  // &#x60;init({ priorityWeightScheme: &quot;auto&quot; })&#x60;
  options.priorityWeightScheme = self._containsInList(&#x27;PRIORITY_WEIGHT_SCHEME&#x27;, options.priorityWeightScheme, &#x27;AUTO&#x27;);

  // &#x60;init({ TURNServerTransport: &quot;any&quot; })&#x60;
  options.TURNServerTransport = self._containsInList(&#x27;TURN_TRANSPORT&#x27;, options.TURNServerTransport, &#x27;ANY&#x27;);

  // &#x60;init({ credentials: { credentials: &quot;xxxxx&quot;, startDateTime: &quot;xxxxx&quot;, duration: 24 } })&#x60;
  options.credentials = options.credentials &amp;&amp; typeof options.credentials === &#x27;object&#x27; &amp;&amp;
    options.credentials.startDateTime &amp;&amp; typeof options.credentials.startDateTime === &#x27;string&#x27; &amp;&amp;
    options.credentials.credentials &amp;&amp; typeof options.credentials.credentials === &#x27;string&#x27; &amp;&amp;
    typeof options.credentials.duration === &#x27;number&#x27; ? options.credentials : null;

  // &#x60;init({ filterCandidatesType: { .. } })&#x60;
  options.filterCandidatesType = options.filterCandidatesType &amp;&amp;
    typeof options.filterCandidatesType === &#x27;object&#x27; ? options.filterCandidatesType : {};

  // &#x60;init({ filterCandidatesType: { host: false } })&#x60;
  options.filterCandidatesType.host = options.filterCandidatesType.host === true;

  // &#x60;init({ filterCandidatesType: { srflx: false } })&#x60;
  options.filterCandidatesType.srflx = options.filterCandidatesType.srflx === true;

  // &#x60;init({ filterCandidatesType: { relay: false } })&#x60;
  options.filterCandidatesType.relay = options.filterCandidatesType.relay === true;

  // &#x60;init({ throttleIntervals: { .. } })&#x60;
  options.throttleIntervals = options.throttleIntervals &amp;&amp;
    typeof options.throttleIntervals === &#x27;object&#x27; ? options.throttleIntervals : {};

  // &#x60;init({ throttleIntervals: { shareScreen: 10000 } })&#x60;
  options.throttleIntervals.shareScreen = typeof options.throttleIntervals.shareScreen === &#x27;number&#x27; ?
    options.throttleIntervals.shareScreen : 10000;

  // &#x60;init({ throttleIntervals: { refreshConnection: 5000 } })&#x60;
  options.throttleIntervals.refreshConnection = typeof options.throttleIntervals.refreshConnection === &#x27;number&#x27; ?
    options.throttleIntervals.refreshConnection : 5000;

  // &#x60;init({ throttleIntervals: { getUserMedia: 0 } })&#x60;
  options.throttleIntervals.getUserMedia = typeof options.throttleIntervals.getUserMedia === &#x27;number&#x27; ?
    options.throttleIntervals.getUserMedia : 0;

  // &#x60;init({ iceServer: &quot;turn:xxxx.io&quot; })&#x60;
  if (options.iceServer &amp;&amp; typeof options.iceServer === &#x27;string&#x27;) {
    options.iceServer = { urls: [options.iceServer] };

  // &#x60;init({ iceServer: [&quot;turn:xxxx.io&quot;, &quot;turn:xxx2.io&quot;] })&#x60;
  } else if (Array.isArray(options.iceServer) &amp;&amp; options.iceServer.length &gt; 0) {
    options.iceServer = { urls: options.iceServer };

  } else {
    options.iceServer = null;
  }

  // &#x60;init({ socketServer: &quot;server.io&quot; })&#x60;
  if (options.socketServer &amp;&amp; typeof options.socketServer === &#x27;string&#x27;) {
    options.socketServer = options.socketServer;

  // &#x60;init({ socketServer: { url: &quot;server.io&quot;, ... } })&#x60;
  } else if (options.socketServer &amp;&amp; typeof options.socketServer === &#x27;object&#x27; &amp;&amp;
    options.socketServer.url &amp;&amp; typeof options.socketServer.url === &#x27;string&#x27;) {
    options.socketServer = {
      url: options.socketServer.url,
      // &#x60;init({ socketServer: { ports: [80, 3000], ... } })&#x60;
      ports: Array.isArray(options.socketServer.ports) ? options.socketServer.ports : [],
      // &#x60;init({ socketServer: { protocol: &quot;https:&quot;, ... } })&#x60;
      protocol: options.socketServer.protocol ? options.socketServer.protocol : null
    };

  } else {
    options.socketServer = null;
  }

  // &#x60;init({ audioCodec: { codec: &quot;xxxx&quot;, ... } })&#x60;
  if (options.audioCodec &amp;&amp; typeof options.audioCodec === &#x27;object&#x27; &amp;&amp;
    self._containsInList(&#x27;AUDIO_CODEC&#x27;, options.audioCodec.codec, &#x27;-&#x27;)) {
    options.audioCodec = {
      codec: options.audioCodec.codec,
      // &#x60;init({ audioCodec: { samplingRate: 48000, ... } })&#x60;
      samplingRate: typeof options.audioCodec.samplingRate === &#x27;number&#x27; ? options.audioCodec.samplingRate : null,
      // &#x60;init({ audioCodec: { channels: 2, ... } })&#x60;
      channels: typeof options.audioCodec.channels === &#x27;number&#x27; ? options.audioCodec.channels : null
    };

  // &#x60;init({ audioCodec: &quot;xxxx&quot; })&#x60;
  } else {
    options.audioCodec = self._containsInList(&#x27;AUDIO_CODEC&#x27;, options.audioCodec, &#x27;AUTO&#x27;);
  }

  // &#x60;init({ videoCodec: { codec: &quot;xxxx&quot;, ... } })&#x60;
  if (options.videoCodec &amp;&amp; typeof options.videoCodec === &#x27;object&#x27; &amp;&amp;
    self._containsInList(&#x27;VIDEO_CODEC&#x27;, options.videoCodec.codec, &#x27;-&#x27;)) {
    options.videoCodec = {
      codec: options.videoCodec.codec,
      // &#x60;init({ videoCodec: { samplingRate: 48000, ... } })&#x60;
      samplingRate: typeof options.videoCodec.samplingRate === &#x27;number&#x27; ? options.videoCodec.samplingRate : null
    };

  // &#x60;init({ videoCodec: &quot;xxxx&quot; })&#x60;
  } else {
    options.videoCodec = self._containsInList(&#x27;VIDEO_CODEC&#x27;, options.videoCodec, &#x27;AUTO&#x27;);
  }

  // &#x60;init({ codecParams: { ... } })&#x60;
  options.codecParams = options.codecParams &amp;&amp; typeof options.codecParams === &#x27;object&#x27; ? options.codecParams : {};

  // &#x60;init({ codecParams: { audio: { ... } } })&#x60;
  options.codecParams.audio = options.codecParams.audio &amp;&amp; typeof options.codecParams.audio === &#x27;object&#x27; ? options.codecParams.audio : {};

  // &#x60;init({ codecParams: { video: { ... } } })&#x60;
  options.codecParams.video = options.codecParams.video &amp;&amp; typeof options.codecParams.video === &#x27;object&#x27; ? options.codecParams.video : {};

  // &#x60;init({ codecParams: { audio: { opus: { ... } } } })&#x60;
  options.codecParams.audio.opus = options.codecParams.audio.opus &amp;&amp;
    typeof options.codecParams.audio.opus === &#x27;object&#x27; ? options.codecParams.audio.opus : {};

  // &#x60;init({ codecParams: { audio: { opus: { stereo: true } } } })&#x60;
  options.codecParams.audio.opus.stereo = typeof options.codecParams.audio.opus.stereo === &#x27;boolean&#x27; ?
    options.codecParams.audio.opus.stereo : null;

  // &#x60;init({ codecParams: { audio: { opus: { &quot;sprop-stereo&quot;: true } } } })&#x60;
  options.codecParams.audio.opus[&#x27;sprop-stereo&#x27;] = typeof options.codecParams.audio.opus[&#x27;sprop-stereo&#x27;] === &#x27;boolean&#x27; ?
    options.codecParams.audio.opus[&#x27;sprop-stereo&#x27;] : null;

  // &#x60;init({ codecParams: { audio: { opus: { usedtx: true } } } })&#x60;
  options.codecParams.audio.opus.usedtx = typeof options.codecParams.audio.opus.usedtx === &#x27;boolean&#x27; ?
    options.codecParams.audio.opus.usedtx : null;

  // &#x60;init({ codecParams: { audio: { opus: { useinbandfec: true } } } })&#x60;
  options.codecParams.audio.opus.useinbandfec = typeof options.codecParams.audio.opus.useinbandfec === &#x27;boolean&#x27; ?
    options.codecParams.audio.opus.useinbandfec : null;

  // &#x60;init({ codecParams: { audio: { opus: { maxplaybackrate: 48000 } } } })&#x60;
  options.codecParams.audio.opus.maxplaybackrate = typeof options.codecParams.audio.opus.maxplaybackrate === &#x27;number&#x27; &amp;&amp;
    options.codecParams.audio.opus.maxplaybackrate &gt;= 8000 &amp;&amp; options.codecParams.audio.opus.maxplaybackrate &lt;= 48000 ?
    options.codecParams.audio.opus.maxplaybackrate : null;

  // &#x60;init({ codecParams: { audio: { opus: { minptime: 60 } } } })&#x60;
  options.codecParams.audio.opus.minptime = typeof options.codecParams.audio.opus.minptime === &#x27;number&#x27; &amp;&amp;
    options.codecParams.audio.opus.minptime &gt;= 3 ? options.codecParams.audio.opus.minptime : null;

  // &#x60;init({ codecParams: { video: { h264: { ... } } } })&#x60;
  options.codecParams.video.h264 = options.codecParams.video.h264 &amp;&amp;
    typeof options.codecParams.video.h264 === &#x27;object&#x27; ? options.codecParams.video.h264 : {};

  // &#x60;init({ codecParams: { video: { h264: { profileLevelId: &quot;xxxxxx&quot; } } } })&#x60;
  options.codecParams.video.h264.profileLevelId = options.codecParams.video.h264.profileLevelId &amp;&amp;
    typeof options.codecParams.video.h264.profileLevelId === &#x27;string&#x27; ?
    options.codecParams.video.h264.profileLevelId : null;

  // &#x60;init({ codecParams: { video: { h264: { levelAsymmetryAllowed: 1 } } } })&#x60;
  options.codecParams.video.h264.levelAsymmetryAllowed = typeof options.codecParams.video.h264.levelAsymmetryAllowed === &#x27;boolean&#x27; ?
    options.codecParams.video.h264.levelAsymmetryAllowed : null;

  // &#x60;init({ codecParams: { video: { h264: { packetizationMode: 1 } } } })&#x60; (fallback for number)
  options.codecParams.video.h264.packetizationMode = typeof options.codecParams.video.h264.packetizationMode === &#x27;boolean&#x27; ?
    (options.codecParams.video.h264.packetizationMode === true ? 1 : 0) :
    (typeof options.codecParams.video.h264.packetizationMode === &#x27;number&#x27; ?
    options.codecParams.video.h264.packetizationMode : null);

  // &#x60;init({ codecParams: { video: { vp8: { ... } } } })&#x60;
  options.codecParams.video.vp8 = options.codecParams.video.vp8 &amp;&amp;
    typeof options.codecParams.video.vp8 === &#x27;object&#x27; ? options.codecParams.video.vp8 : {};

  // &#x60;init({ codecParams: { video: { vp8: { maxFs: 100 } } } })&#x60;
  options.codecParams.video.vp8.maxFs = typeof options.codecParams.video.vp8.maxFs === &#x27;number&#x27; ?
    options.codecParams.video.vp8.maxFs : null;

  // &#x60;init({ codecParams: { video: { vp8: { maxFr: 100 } } } })&#x60;
  options.codecParams.video.vp8.maxFr = typeof options.codecParams.video.vp8.maxFr === &#x27;number&#x27; ?
    options.codecParams.video.vp8.maxFr : null;

  // &#x60;init({ codecParams: { video: { vp9: { ... } } } })&#x60;
  options.codecParams.video.vp9 = options.codecParams.video.vp9 &amp;&amp;
    typeof options.codecParams.video.vp9 === &#x27;object&#x27; ? options.codecParams.video.vp9 : {};

  // &#x60;init({ codecParams: { video: { vp9: { maxFs: 100 } } } })&#x60;
  options.codecParams.video.vp9.maxFs = typeof options.codecParams.video.vp9.maxFs === &#x27;number&#x27; ?
    options.codecParams.video.vp9.maxFs : null;

  // &#x60;init({ codecParams: { video: { vp9: { maxFr: 100 } } } })&#x60;
  options.codecParams.video.vp9.maxFr = typeof options.codecParams.video.vp9.maxFr === &#x27;number&#x27; ?
    options.codecParams.video.vp9.maxFr : null;

  // Force TURN connections should enforce settings.
  if (options.forceTURN) {
    options.enableTURNServer = true;
    options.enableSTUNServer = false;
    options.filterCandidatesType.host = true;
    options.filterCandidatesType.srflx = true;
    options.filterCandidatesType.relay = false;
  }

  self.once(&#x27;readyStateChange&#x27;, function () { }, function (state, error) {
    if (state === self.READY_STATE_CHANGE.ERROR) {
      log.error(&#x27;Failed init() process -&gt;&#x27;, error);
      callback({
        error: error.content,
        errorCode: error.errorCode,
        status: error.status
      }, null);
      return true;

    } else if (state === self.READY_STATE_CHANGE.COMPLETED) {
      log.info(&#x27;Completed init() successfully -&gt;&#x27;, options);

      var success = clone(self._initOptions);
      success.serverUrl = self._path;
      success.readyState = self._readyState;
      success.selectedRoom = self._selectedRoom;
      success.TURNTransport = success.TURNServerTransport;

      callback(null, success);
      return true;
    }
  });

  self._initOptions = options;
  self._readyState = self.READY_STATE_CHANGE.INIT;
  self._selectedRoom = self._initOptions.defaultRoom;
  self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.INIT, null, self._selectedRoom);

  if (!(options &amp;&amp; options.appKey &amp;&amp; typeof options.appKey === &#x27;string&#x27;)) {
    self._readyState = self.READY_STATE_CHANGE.ERROR;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
      content: new Error(&#x27;Please provide an app key&#x27;),
      errorCode: self.READY_STATE_CHANGE_ERROR.NO_PATH,
      status: -2
    }, self._selectedRoom);
    return;
  }

  // Format: https://api.temasys.io/api/&lt;appKey&gt;/&lt;room&gt;[/&lt;creds.start&gt;][/&lt;creds.duration&gt;][?cred=&lt;creds.hash&gt;]&amp;rand=&lt;rand&gt;
  self._path = self._initOptions.roomServer + &#x27;/api/&#x27; + self._initOptions.appKey + &#x27;/&#x27; + self._selectedRoom +
    (self._initOptions.credentials ? &#x27;/&#x27; + self._initOptions.credentials.startDateTime + &#x27;/&#x27; +
    self._initOptions.credentials.duration + &#x27;?cred=&#x27; + self._initOptions.credentials.credentials : &#x27;&#x27;) +
    (self._initOptions.credentials ? &#x27;&amp;&#x27; : &#x27;?&#x27;) + &#x27;rand=&#x27; + Date.now();

  self._loadInfo();
};

/**
 * Function that checks if value is contained in a SDK constant.
 * @method _containsInList
 * @for Skylink
 * @since 0.6.27
 * @private
 */
Skylink.prototype._containsInList = function (listName, value, defaultProperty) {
  var self = this;

  for (var property in self[listName]) {
    if (self[listName].hasOwnProperty(property) &amp;&amp; self[listName][property] === value) {
      return value;
    }
  }

  return self[listName][defaultProperty];
};

/**
 * Starts retrieving Room credentials information from API server.
 * @method _requestServerInfo
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._requestServerInfo = function(method, url, callback, params) {
  var self = this;
  var retries = 0;

  // XDomainRequest is supported in IE8 - 9 for CORS connection.
  self._socketUseXDR = typeof window.XDomainRequest === &#x27;function&#x27; || typeof window.XDomainRequest === &#x27;object&#x27;;
  url = (self._initOptions.forceSSL) ? &#x27;https:&#x27; + url : url;

  (function requestFn () {
    var xhr = new XMLHttpRequest();
    var completed = false;

    if (self._socketUseXDR) {
      log.debug([null, &#x27;XMLHttpRequest&#x27;, method, &#x27;Using XDomainRequest for CORS authentication.&#x27;]);
      xhr = new XDomainRequest();
      xhr.setContentType = function (contentType) {
        xhr.contentType = contentType;
      };
    }

    xhr.onload = function () {
      if (completed) {
        return;
      }
      completed = true;
      var response = JSON.parse(xhr.responseText || xhr.response || &#x27;{}&#x27;);
      var status = xhr.status || (response.success ? 200 : 400);
      self._handleAuthStats(response.success ? &#x27;success&#x27; : &#x27;error&#x27;, response, status);

      if (response.success) {
      	log.debug([null, &#x27;XMLHttpRequest&#x27;, method, &#x27;Received sessions parameters -&gt;&#x27;], response);
      	callback(response);
      	return;
      }

      log.error([null, &#x27;XMLHttpRequest&#x27;, method, &#x27;Failed retrieving sessions parameters -&gt;&#x27;], response);

      // 400 - Bad request
      // 403 - Room is locked
      // 401 - API Not authorized
      // 402 - run out of credits
      self._readyState = self.READY_STATE_CHANGE.ERROR;
      self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
        status: status,
        content: new Error(response.info || &#x27;XMLHttpRequest status not OK\nStatus was: &#x27; + status),
        errorCode: response.error || status
      }, self._selectedRoom);
    };

    xhr.onerror = function (error) {
      if (completed) {
        return;
      }
      completed = true;
      log.error([null, &#x27;XMLHttpRequest&#x27;, method, &#x27;Failed retrieving information with status -&gt;&#x27;], xhr.status);
      // TO CHECK: Added a new field &quot;web_sdk_error&quot; not documented in specs.
      self._handleAuthStats(&#x27;error&#x27;, null, -1, &#x27;Failed connecting to server&#x27;);
      self._readyState = self.READY_STATE_CHANGE.ERROR;
      self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
        status: xhr.status || -1,
        content: new Error(&#x27;Network error occurred. (Status: &#x27; + xhr.status + &#x27;)&#x27;),
        errorCode: self.READY_STATE_CHANGE_ERROR.XML_HTTP_REQUEST_ERROR
      }, self._selectedRoom);
    };

    xhr.onprogress = function () {
      log.debug([null, &#x27;XMLHttpRequest&#x27;, method, &#x27;Retrieving information and config from webserver -&gt;&#x27;], {
        url: url,
        params: params
      });
    };

    try {
      xhr.open(method, url, true);

      // ESS-1038: Adding custom headers to signaling
      if(!self._socketUseXDR) {
        xhr.setRequestHeader(&#x27;Skylink_SDK_version&#x27;, self.VERSION);
        xhr.setRequestHeader(&#x27;Skylink_SDK_type&#x27;, &#x27;WEB_SDK&#x27;);
      }

      if (params) {
        xhr.setContentType(&#x27;application/json;charset=UTF-8&#x27;);
        xhr.send(JSON.stringify(params));
      } else {
        xhr.send();
      }
    } catch (error) {
      completed = true;
      self._handleAuthStats(&#x27;error&#x27;, null, -1, error);
      self._readyState = self.READY_STATE_CHANGE.ERROR;
      self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
        status: xhr.status || -1,
        content: new Error(&#x27;Failed starting XHR process.&#x27;),
        errorCode: self.READY_STATE_CHANGE_ERROR.XML_HTTP_REQUEST_ERROR
      }, self._selectedRoom);
      return;
    }

    setTimeout(function () {
      if (completed) {
        return;
      }
      completed = true;
      xhr.onload = null;
      xhr.onerror = null;
      xhr.onprogress = null;

      if (retries &lt; 2) {
        retries++;
        requestFn();

      } else {
      	var timeoutError = new Error(&#x27;Response timed out from API server&#x27;);
        self._handleAuthStats(&#x27;error&#x27;, null, -1, timeoutError);
      	self._readyState = self.READY_STATE_CHANGE.ERROR;
        self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
          status: xhr.status || -1,
          content: timeoutError,
          errorCode: self.READY_STATE_CHANGE_ERROR.XML_HTTP_NO_REPONSE_ERROR
        }, self._selectedRoom);
      }
    }, self._initOptions.apiTimeout);
  })();
};

/**
 * Parses the Room credentials information retrieved from API server.
 * @method _parseInfo
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._parseInfo = function(info) {
  log.log(&#x27;Parsing parameter from server&#x27;, info);
  if (!info.pc_constraints &amp;&amp; !info.offer_constraints) {
    this._trigger(&#x27;readyStateChange&#x27;, this.READY_STATE_CHANGE.ERROR, {
      status: 200,
      content: info.info,
      errorCode: info.error
    }, self._selectedRoom);
    return;
  }

  log.debug(&#x27;Peer connection constraints:&#x27;, info.pc_constraints);
  log.debug(&#x27;Offer constraints:&#x27;, info.offer_constraints);

  this._key = info.cid;
  this._appKeyOwner = info.apiOwner;
  this._signalingServer = info.ipSigserver;
  this._isPrivileged = info.isPrivileged;
  this._autoIntroduce = info.autoIntroduce;
  this._hasMCU = info.hasMCU;

  if(!info.enable_stats_config){
    this._initOptions.enableStatsGathering = false;
  }

  this._user = {
    uid: info.username,
    token: info.userCred,
    timeStamp: info.timeStamp,
    streams: [],
    info: {}
  };
  this._room = {
    id: info.room_key,
    token: info.roomCred,
    startDateTime: info.start,
    duration: info.len,
    connection: {
      peerConstraints: JSON.parse(info.pc_constraints),
      peerConfig: null,
      offerConstraints: JSON.parse(info.offer_constraints),
      sdpConstraints: {
        mandatory: {
          OfferToReceiveAudio: true,
          OfferToReceiveVideo: true
        }
      },
      mediaConstraints: JSON.parse(info.media_constraints)
    }
  };
  //this._parseDefaultMediaStreamSettings(this._room.connection.mediaConstraints);

  // set the socket ports
  this._socketPorts = {
    &#x27;http:&#x27;: Array.isArray(info.httpPortList) &amp;&amp; info.httpPortList.length &gt; 0 ? info.httpPortList : [80, 3000],
    &#x27;https:&#x27;: Array.isArray(info.httpsPortList) &amp;&amp; info.httpsPortList.length &gt; 0 ? info.httpsPortList : [443, 3443]
  };

  // use default bandwidth and media resolution provided by server
  //this._streamSettings.bandwidth = info.bandwidth;
  //this._streamSettings.video = info.video;
  this._readyState = this.READY_STATE_CHANGE.COMPLETED;
  this._trigger(&#x27;readyStateChange&#x27;, this.READY_STATE_CHANGE.COMPLETED, null, this._selectedRoom);
  log.info(&#x27;Parsed parameters from webserver. Ready for web-realtime communication&#x27;);
};

/**
 * Loads and checks the dependencies if they are loaded correctly.
 * @method _loadInfo
 * @private
 * @for Skylink
 * @since 0.5.2
 */
Skylink.prototype._loadInfo = function() {
  var self = this;

  if (typeof (globals.AdapterJS || window.AdapterJS || {}).webRTCReady !== &#x27;function&#x27;) {
    var noAdapterErrorMsg = &#x27;AdapterJS dependency is not loaded or incorrect AdapterJS dependency is used&#x27;;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
      status: -2,
      content: new Error(noAdapterErrorMsg),
      errorCode: self.READY_STATE_CHANGE_ERROR.ADAPTER_NO_LOADED
    }, self._selectedRoom);
    return;

  } else if (!(globals.io || window.io)) {
    log.error(&#x27;Socket.io not loaded. Please load socket.io&#x27;);
    self._readyState = self.READY_STATE_CHANGE.ERROR;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
      status: -2,
      content: new Error(&#x27;Socket.io not found&#x27;),
      errorCode: self.READY_STATE_CHANGE_ERROR.NO_SOCKET_IO
    }, self._selectedRoom);
    return;

  } else if (!window.XMLHttpRequest) {
    log.error(&#x27;XMLHttpRequest not supported. Please upgrade your browser&#x27;);
    self._readyState = self.READY_STATE_CHANGE.ERROR;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
      status: -2,
      content: new Error(&#x27;XMLHttpRequest not available&#x27;),
      errorCode: self.READY_STATE_CHANGE_ERROR.NO_XMLHTTPREQUEST_SUPPORT
    }, self._selectedRoom);
    return;

  } else if (!self._path) {
    log.error(&#x27;Skylink is not initialised. Please call init() first&#x27;);
    self._readyState = self.READY_STATE_CHANGE.ERROR;
    self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
      status: -2,
      content: new Error(&#x27;No API Path is found&#x27;),
      errorCode: self.READY_STATE_CHANGE_ERROR.NO_PATH
    }, self._selectedRoom);
    return;
  }

  AdapterJS.webRTCReady(function () {
    self._enableIceRestart = AdapterJS.webrtcDetectedBrowser === &#x27;firefox&#x27; ?
      AdapterJS.webrtcDetectedVersion &gt;= 48 : true;
    self._binaryChunkType = AdapterJS.webrtcDetectedBrowser === &#x27;firefox&#x27; ?
      self.DATA_TRANSFER_DATA_TYPE.BLOB : self.DATA_TRANSFER_DATA_TYPE.ARRAY_BUFFER;

      // Prevent empty object returned when constructing the RTCPeerConnection object
    if (!(function () {
      try {
        var p = new window.RTCPeerConnection(null);
        // IE returns as typeof object
        return [&#x27;object&#x27;, &#x27;function&#x27;].indexOf(typeof p.createOffer) &gt; -1 &amp;&amp; p.createOffer !== null;
      } catch (e) {
        return false;
      }
    })()) {
      if (window.RTCPeerConnection &amp;&amp; AdapterJS.webrtcDetectedType === &#x27;plugin&#x27;) {
        log.error(&#x27;Plugin is not available. Please check plugin status.&#x27;);
      } else {
        log.error(&#x27;WebRTC not supported. Please upgrade your browser&#x27;);
      }
      self._readyState = self.READY_STATE_CHANGE.ERROR;
      self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
        status: -2,
        content: new Error(AdapterJS.webrtcDetectedType === &#x27;plugin&#x27; &amp;&amp; window.RTCPeerConnection ? &#x27;Plugin is not available&#x27; : &#x27;WebRTC not available&#x27;),
        errorCode: self.READY_STATE_CHANGE_ERROR.NO_WEBRTC_SUPPORT
      }, self._selectedRoom);
      return;
    }

    self._getCodecsSupport(function (error) {
      if (error) {
        log.error(error);
        self._readyState = self.READY_STATE_CHANGE.ERROR;
        self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
          status: -2,
          content: new Error(error.message || error.toString()),
          errorCode: self.READY_STATE_CHANGE_ERROR.PARSE_CODECS
        }, self._selectedRoom);
        return;
      }

      if (Object.keys(self._currentCodecSupport.audio).length === 0 &amp;&amp; Object.keys(self._currentCodecSupport.video).length === 0) {
        log.error(&#x27;No audio/video codecs available to start connection.&#x27;);
        self._readyState = self.READY_STATE_CHANGE.ERROR;
        self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.ERROR, {
          status: -2,
          content: new Error(&#x27;No audio/video codecs available to start connection&#x27;),
          errorCode: self.READY_STATE_CHANGE_ERROR.PARSE_CODECS
        }, self._selectedRoom);
        return;
      }

      self._readyState = self.READY_STATE_CHANGE.LOADING;
      self._trigger(&#x27;readyStateChange&#x27;, self.READY_STATE_CHANGE.LOADING, null, self._selectedRoom);
      self._handleClientStats();
      self._requestServerInfo(&#x27;GET&#x27;, self._path, function(response) {
        self._parseInfo(response);
      });
    });
  });
};

/**
 * Starts initialising for Room credentials for room name provided in &lt;code&gt;joinRoom()&lt;/code&gt; method.
 * @method _initSelectedRoom
 * @private
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype._initSelectedRoom = function(room, callback) {
  var self = this;
  if (typeof room === &#x27;function&#x27; || typeof room === &#x27;undefined&#x27;) {
    log.error(&#x27;Invalid room provided. Room:&#x27;, room);
    callback(new Error(&#x27;Invalid room provided&#x27;), null);
    return;
  }
  var defaultRoom = self._initOptions.defaultRoom;
  var options = clone(self._initOptions);
  options.iceServer = options.iceServer ? options.iceServer.urls : null;

  if(options.defaultRoom!==room){
    options.defaultRoom = room;
  }

  self.init(options, function (error, success) {
    self._initOptions.defaultRoom = defaultRoom;
    if (error) {
      callback(error, null);
    } else {
      callback(null, success);
    }
  });
};


    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
