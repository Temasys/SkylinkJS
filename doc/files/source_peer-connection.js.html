<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>SkylinkJS 0.6.15</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- font and icon -->
    <link rel="shortcut icon" type="image/ico" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Sans+Pro" type="text/css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700|Source+Code+Pro" type="text/css">
    <!-- styling -->
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap.min.css">
    <link rel="stylesheet" href="../assets/vendor/css/bootstrap-theme.min.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="../assets/css/style.css">
    <!-- scripts -->
    <script src="../assets/vendor/js/jquery.min.js"></script>
    <script src="../assets/vendor/js/bootstrap.min.js"></script>
    <script src="../assets/js/script.js"></script>
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body>

<div id="doc">
  <nav id="hd" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a href="" class="navbar-brand">
          <img src="../assets/img/logo.svg" />JS<small>Version: 0.6.15</small>
        </a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul id="api-list" class="nav navbar-nav navbar-right">
  <li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Getting Started Examples <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="https://temasys.com.sg/getting-started-with-webrtc-and-skylinkjs/">Setting up a Video Call</a></li>
      <li><a href="https://temasys.com.sg/screensharing-with-skylinkjs/">Setting up Screensharing</a></li>
      <li><a href="https://temasys.com.sg/building-a-simple-peer-to-peer-webrtc-chat/">Setting up a Chatroom</a></li>
    </ul>
  </li>
  
    <li><a href="../classes/Skylink.html">Documentation</a></li>
  
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Classes <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      
        <li><a href="../classes/Skylink.html">Skylink</a></li>
      
    </ul>
  </li>-->
  <li><a class="btn btn-info btn-navbar" href="http://developer.temasys.com.sg/">Developer Console</a></li>
  <li><a class="btn btn-info btn-navbar" href="http://support.temasys.com.sg/">Support</a></li>
  <!--<li class="dropdown">
    <a href="#" class="dropdown-toggle" data-toggle="dropdown">Modules <span class="caret"></span></a>
    <ul class="dropdown-menu" role="menu">
      <li><a href="#api-modules">View all Modules</a></li>
      
    </ul>
  </li>-->
</ul>
<!--<form id="api-tabview" class="navbar-form navbar-right" role="form">
  <div id="api-tabview-filter" class="form-group">
    <input type="search" id="api-filter" placeholder="Type to filter APIs">
  </div>
</form>-->
      </div><!--/.navbar-collapse -->
    </div>
  </nav>
  <div id="bd" class="yui3-g">

      <div class="yui3-u-1-4">

      </div>
      <div class="yui3-u-3-4">
          
          <div class="apidocs">
              <div id="docs-main">
                  <div class="content content-main">
                      <h1 class="file-heading">File: source/peer-connection.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   Learn more about how ICE works in this
 *   &lt;a href=&quot;https://temasys.com.sg/ice-what-is-this-sorcery/&quot;&gt;article here&lt;/a&gt;.
 * &lt;/blockquote&gt;
 * The list of Peer connection session description exchanging states.
 * @attribute PEER_CONNECTION_STATE
 * @param {String} STABLE            &lt;small&gt;Value &lt;code&gt;&quot;stable&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when there is no session description being exchanged between Peer connection.
 * @param {String} HAVE_LOCAL_OFFER  &lt;small&gt;Value &lt;code&gt;&quot;have-local-offer&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when local &lt;code&gt;&quot;offer&quot;&lt;/code&gt; session description is set.
 *   &lt;small&gt;This should transition to &lt;code&gt;STABLE&lt;/code&gt; state after remote &lt;code&gt;&quot;answer&quot;&lt;/code&gt;
 *   session description is set.&lt;/small&gt;
 *   &lt;small&gt;See &lt;a href=&quot;#event_handshakeProgress&quot;&gt;&lt;code&gt;handshakeProgress&lt;/code&gt; event&lt;/a&gt; for a more
 *   detailed exchanging of session description states.&lt;/small&gt;
 * @param {String} HAVE_REMOTE_OFFER &lt;small&gt;Value &lt;code&gt;&quot;have-remote-offer&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when remote &lt;code&gt;&quot;offer&quot;&lt;/code&gt; session description is set.
 *   &lt;small&gt;This should transition to &lt;code&gt;STABLE&lt;/code&gt; state after local &lt;code&gt;&quot;answer&quot;&lt;/code&gt;
 *   session description is set.&lt;/small&gt;
 *   &lt;small&gt;See &lt;a href=&quot;#event_handshakeProgress&quot;&gt;&lt;code&gt;handshakeProgress&lt;/code&gt; event&lt;/a&gt; for a more
 *   detailed exchanging of session description states.&lt;/small&gt;
 * @param {String} CLOSED            &lt;small&gt;Value &lt;code&gt;&quot;closed&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when Peer connection is closed and no session description can be exchanged and set.
 * @type JSON
 * @readOnly
 * @for Skylink
 * @since 0.5.0
 */
Skylink.prototype.PEER_CONNECTION_STATE = {
  STABLE: &#x27;stable&#x27;,
  HAVE_LOCAL_OFFER: &#x27;have-local-offer&#x27;,
  HAVE_REMOTE_OFFER: &#x27;have-remote-offer&#x27;,
  CLOSED: &#x27;closed&#x27;
};

/**
 * The list of &lt;a href=&quot;#method_getConnectionStatus&quot;&gt;&lt;code&gt;getConnectionStatus()&lt;/code&gt;
 * method&lt;/a&gt; retrieval states.
 * @attribute GET_CONNECTION_STATUS_STATE
 * @param {Number} RETRIEVING &lt;small&gt;Value &lt;code&gt;0&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when &lt;code&gt;getConnectionStatus()&lt;/code&gt; is retrieving the Peer connection stats.
 * @param {Number} RETRIEVE_SUCCESS &lt;small&gt;Value &lt;code&gt;1&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when &lt;code&gt;getConnectionStatus()&lt;/code&gt; has retrieved the Peer connection stats successfully.
 * @param {Number} RETRIEVE_ERROR &lt;small&gt;Value &lt;code&gt;-1&lt;/code&gt;&lt;/small&gt;
 *   The value of the state when &lt;code&gt;getConnectionStatus()&lt;/code&gt; has failed retrieving the Peer connection stats.
 * @type JSON
 * @readOnly
 * @for Skylink
 * @since 0.1.0
 */
Skylink.prototype.GET_CONNECTION_STATUS_STATE = {
  RETRIEVING: 0,
  RETRIEVE_SUCCESS: 1,
  RETRIEVE_ERROR: -1
};

/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *  As there are more features getting implemented, there will be eventually more different types of
 *  server Peers.
 * &lt;/blockquote&gt;
 * The list of available types of server Peer connections.
 * @attribute SERVER_PEER_TYPE
 * @param {String} MCU &lt;small&gt;Value &lt;code&gt;&quot;mcu&quot;&lt;/code&gt;&lt;/small&gt;
 *   The value of the server Peer type that is used for MCU connection.
 * @type JSON
 * @readOnly
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype.SERVER_PEER_TYPE = {
  MCU: &#x27;mcu&#x27;
  //SIP: &#x27;sip&#x27;
};

/**
 * Stores the restart initiated timestamp to throttle the &lt;code&gt;refreshConnection&lt;/code&gt; functionality.
 * @attribute _lastRestart
 * @type Object
 * @private
 * @for Skylink
 * @since 0.5.9
 */
Skylink.prototype._lastRestart = null;

/**
 * Stores the global number of Peer connection retries that would increase the wait-for-response timeout
 *   for the Peer connection health timer.
 * @attribute _retryCount
 * @type Number
 * @private
 * @for Skylink
 * @since 0.5.10
 */
Skylink.prototype._retryCount = 0;

/**
 * Stores the list of the Peer connections.
 * @attribute _peerConnections
 * @param {Object} &lt;#peerId&gt; The Peer connection.
 * @type JSON
 * @private
 * @for Skylink
 * @since 0.1.0
 */
Skylink.prototype._peerConnections = {};

/**
 * &lt;blockquote class=&quot;info&quot;&gt;
 *   For MCU enabled Peer connections, the restart functionality may differ, you may learn more about how to workaround
 *   it &lt;a href=&quot;http://support.temasys.com.sg/support/discussions/topics/12000002853&quot;&gt;in this article here&lt;/a&gt;.&lt;br&gt;
 *   For restarts with Peers connecting from Android or iOS SDKs, restarts might not work as written in
 *   &lt;a href=&quot;http://support.temasys.com.sg/support/discussions/topics/12000005188&quot;&gt;in this article here&lt;/a&gt;.&lt;br&gt;
 *   Note that this functionality should be used when Peer connection stream freezes during a connection,
 *   and is throttled when invoked many times in less than 3 seconds interval.
 * &lt;/blockquote&gt;
 * Function that refreshes Peer connections to update with the current streaming.
 * @method refreshConnection
 * @param {String|Array} [targetPeerId] &lt;blockquote class=&quot;info&quot;&gt;
 *   Note that this is ignored if MCU is enabled for the App Key provided in
 *   &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt; method&lt;/a&gt;. &lt;code&gt;refreshConnection()&lt;/code&gt; will &quot;refresh&quot;
 *   all Peer connections. See the &lt;u&gt;Event Sequence&lt;/u&gt; for more information.&lt;/blockquote&gt;
 *   The target Peer ID to refresh connection with.
 * - When provided as an Array, it will refresh all connections with all the Peer IDs provided.
 * - When not provided, it will refresh all the currently connected Peers in the Room.
 * @param {Function} [callback] The callback function fired when request has completed.
 *   &lt;small&gt;Function parameters signature is &lt;code&gt;function (error, success)&lt;/code&gt;&lt;/small&gt;
 *   &lt;small&gt;Function request completion is determined by the &lt;a href=&quot;#event_peerRestart&quot;&gt;
 *   &lt;code&gt;peerRestart&lt;/code&gt; event&lt;/a&gt; triggering &lt;code&gt;isSelfInitiateRestart&lt;/code&gt; parameter payload
 *   value as &lt;code&gt;true&lt;/code&gt; for all Peers targeted for request success.&lt;/small&gt;
 * @param {JSON} callback.error The error result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are no errors in request&lt;/small&gt;
 * @param {Array} callback.error.listOfPeers The list of Peer IDs targeted.
 * @param {JSON} callback.error.refreshErrors The list of Peer connection refresh errors.
 * @param {Error|String} callback.error.refreshErrors.#peerId The Peer connection refresh error associated
 *   with the Peer ID defined in &lt;code&gt;#peerId&lt;/code&gt; property.
 *   &lt;small&gt;If &lt;code&gt;#peerId&lt;/code&gt; value is &lt;code&gt;&quot;self&quot;&lt;/code&gt;, it means that it is the error when there
 *   is no Peer connections to refresh with.&lt;/small&gt;
 * @param {JSON} callback.success The success result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are errors in request&lt;/small&gt;
 * @param {Array} callback.success.listOfPeers The list of Peer IDs targeted.
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *   &lt;li&gt;Checks if MCU is enabled for App Key provided in &lt;a href=&quot;#method_init&quot;&gt;&lt;code&gt;init()&lt;/code&gt; method&lt;/a&gt;&lt;ol&gt;
 *   &lt;li&gt;If MCU is enabled: &lt;ol&gt;&lt;li&gt;If there are connected Peers in the Room: &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_peerRestart&quot;&gt;&lt;code&gt;peerRestart&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;isSelfInitiateRestart&lt;/code&gt; value as &lt;code&gt;true&lt;/code&gt; for all connected Peer connections.&lt;/li&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_serverPeerRestart&quot;&gt;&lt;code&gt;serverPeerRestart&lt;/code&gt; event&lt;/a&gt; triggers for
 *   connected MCU server Peer connection.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Invokes &lt;a href=&quot;#method_joinRoom&quot;&gt;&lt;code&gt;joinRoom()&lt;/code&gt; method&lt;/a&gt; &lt;small&gt;&lt;code&gt;refreshConnection()&lt;/code&gt;
 *   will retain the User session information except the Peer ID will be a different assigned ID due to restarting the
 *   Room session.&lt;/small&gt; &lt;ol&gt;&lt;li&gt;If request has errors &lt;ol&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; and return error.
 *   &lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Else: &lt;ol&gt;&lt;li&gt;If there are connected Peers in the Room: &lt;ol&gt;
 *   &lt;li&gt;Refresh connections for all targeted Peers. &lt;ol&gt;
 *   &lt;li&gt;If Peer connection exists: &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_peerRestart&quot;&gt;&lt;code&gt;peerRestart&lt;/code&gt; event&lt;/a&gt; triggers parameter payload
 *   &lt;code&gt;isSelfInitiateRestart&lt;/code&gt; value as &lt;code&gt;true&lt;/code&gt; for all targeted Peer connections.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Else: &lt;ol&gt;&lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
 * @example
 *   // Example 1: Refreshing a Peer connection
 *   function refreshFrozenVideoStream (peerId) {
 *     skylinkDemo.refreshConnection(peerId, function (error, success) {
 *       if (error) return;
 *       console.log(&quot;Refreshing connection for &#x27;&quot; + peerId + &quot;&#x27;&quot;);
 *     });
 *   }
 *
 *   // Example 2: Refreshing a list of Peer connections
 *   function refreshFrozenVideoStreamGroup (peerIdA, peerIdB) {
 *     skylinkDemo.refreshConnection([peerIdA, peerIdB], function (error, success) {
 *       if (error) {
 *         if (error.transferErrors[peerIdA]) {
 *           console.error(&quot;Failed refreshing connection for &#x27;&quot; + peerIdA + &quot;&#x27;&quot;);
 *         } else {
 *           console.log(&quot;Refreshing connection for &#x27;&quot; + peerIdA + &quot;&#x27;&quot;);
 *         }
 *         if (error.transferErrors[peerIdB]) {
 *           console.error(&quot;Failed refreshing connection for &#x27;&quot; + peerIdB + &quot;&#x27;&quot;);
 *         } else {
 *           console.log(&quot;Refreshing connection for &#x27;&quot; + peerIdB + &quot;&#x27;&quot;);
 *         }
 *       } else {
 *         console.log(&quot;Refreshing connection for &#x27;&quot; + peerIdA + &quot;&#x27; and &#x27;&quot; + peerIdB + &quot;&#x27;&quot;);
 *       }
 *     });
 *   }
 *
 *   // Example 3: Refreshing all Peer connections
 *   function refreshFrozenVideoStreamAll () {
 *     skylinkDemo.refreshConnection(function (error, success) {
 *       if (error) {
 *         for (var i = 0; i &lt; error.listOfPeers.length; i++) {
 *           if (error.refreshErrors[error.listOfPeers[i]]) {
 *             console.error(&quot;Failed refreshing connection for &#x27;&quot; + error.listOfPeers[i] + &quot;&#x27;&quot;);
 *           } else {
 *             console.info(&quot;Refreshing connection for &#x27;&quot; + error.listOfPeers[i] + &quot;&#x27;&quot;);
 *           }
 *         }
 *       } else {
 *         console.log(&quot;Refreshing connection for all Peers&quot;, success.listOfPeers);
 *       }
 *     });
 *   }
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype.refreshConnection = function(targetPeerId, callback) {
  var self = this;

  var listOfPeers = Object.keys(self._peerConnections);
  var listOfPeerRestarts = [];
  var error = &#x27;&#x27;;
  var listOfPeerRestartErrors = {};

  if(Array.isArray(targetPeerId)) {
    listOfPeers = targetPeerId;

  } else if (typeof targetPeerId === &#x27;string&#x27;) {
    listOfPeers = [targetPeerId];
  } else if (typeof targetPeerId === &#x27;function&#x27;) {
    callback = targetPeerId;
  }

  if (listOfPeers.length === 0) {
    error = &#x27;There is currently no peer connections to restart&#x27;;
    log.warn([null, &#x27;PeerConnection&#x27;, null, error]);

    listOfPeerRestartErrors.self = new Error(error);

    if (typeof callback === &#x27;function&#x27;) {
      callback({
        refreshErrors: listOfPeerRestartErrors,
        listOfPeers: listOfPeers
      }, null);
    }
    return;
  }

  self._throttle(function () {
    self._refreshPeerConnection(listOfPeers, true, callback);
  },5000)();

};

/**
 * Function that refresh connections.
 * @method _refreshPeerConnection
 * @private
 * @for Skylink
 * @since 0.6.15
 */
Skylink.prototype._refreshPeerConnection = function(listOfPeers, shouldThrottle, callback) {
  var self = this;
  var listOfPeerRestarts = [];
  var error = &#x27;&#x27;;
  var listOfPeerRestartErrors = {};

  // To fix jshint dont put functions within a loop
  var refreshSinglePeerCallback = function (peerId) {
    return function (error, success) {
      if (listOfPeerRestarts.indexOf(peerId) === -1) {
        if (error) {
          log.error([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Failed restarting for peer&#x27;], error);
          listOfPeerRestartErrors[peerId] = error;
        }
        listOfPeerRestarts.push(peerId);
      }

      if (listOfPeerRestarts.length === listOfPeers.length) {
        if (typeof callback === &#x27;function&#x27;) {
          log.log([null, &#x27;PeerConnection&#x27;, null, &#x27;Invoked all peers to restart. Firing callback&#x27;]);

          if (Object.keys(listOfPeerRestartErrors).length &gt; 0) {
            callback({
              refreshErrors: listOfPeerRestartErrors,
              listOfPeers: listOfPeers
            }, null);
          } else {
            callback(null, {
              listOfPeers: listOfPeers
            });
          }
        }
      }
    };
  };

  var refreshSinglePeer = function(peerId, peerCallback){
    if (!self._peerConnections[peerId]) {
      error = &#x27;There is currently no existing peer connection made &#x27; +
        &#x27;with the peer. Unable to restart connection&#x27;;
      log.error([peerId, null, null, error]);
      listOfPeerRestartErrors[peerId] = new Error(error);
      return;
    }

    if (shouldThrottle) {
      var now = Date.now() || function() { return +new Date(); };

      if (now - self.lastRestart &lt; 3000) {
        error = &#x27;Last restart was so tight. Aborting.&#x27;;
        log.error([peerId, null, null, error]);
        listOfPeerRestartErrors[peerId] = new Error(error);
        return;
      }
    }

    log.log([peerId, &#x27;PeerConnection&#x27;, null, &#x27;Restarting peer connection&#x27;]);

    // do a hard reset on variable object
    self._restartPeerConnection(peerId, true, false, peerCallback, true);
  };

  if(!self._hasMCU) {
    var i;

    for (i = 0; i &lt; listOfPeers.length; i++) {
      var peerId = listOfPeers[i];

      if (Object.keys(self._peerConnections).indexOf(peerId) &gt; -1) {
        refreshSinglePeer(peerId, refreshSinglePeerCallback(peerId));
      } else {
        error = &#x27;Peer connection with peer does not exists. Unable to restart&#x27;;
        log.error([peerId, &#x27;PeerConnection&#x27;, null, error]);
        listOfPeerRestartErrors[peerId] = new Error(error);
      }

      // there&#x27;s an error to trigger for
      if (i === listOfPeers.length - 1 &amp;&amp; Object.keys(listOfPeerRestartErrors).length &gt; 0) {
        if (typeof callback === &#x27;function&#x27;) {
          callback({
            refreshErrors: listOfPeerRestartErrors,
            listOfPeers: listOfPeers
          }, null);
        }
      }
    }
  } else {
    self._restartMCUConnection(callback);
  }
};

/**
 * Function that retrieves Peer connection bandwidth and ICE connection stats.
 * @method getConnectionStatus
 * @param {String|Array} [targetPeerId] The target Peer ID to retrieve connection stats from.
 * - When provided as an Array, it will retrieve all connection stats from all the Peer IDs provided.
 * - When not provided, it will retrieve all connection stats from the currently connected Peers in the Room.
 * @param {Function} [callback] The callback function fired when request has completed.
 *   &lt;small&gt;Function parameters signature is &lt;code&gt;function (error, success)&lt;/code&gt;&lt;/small&gt;
 *   &lt;small&gt;Function request completion is determined by the &lt;a href=&quot;#event_getConnectionStatusStateChange&quot;&gt;
 *   &lt;code&gt;getConnectionStatusStateChange&lt;/code&gt; event&lt;/a&gt; triggering &lt;code&gt;state&lt;/code&gt; parameter payload
 *   value as &lt;code&gt;RETRIEVE_SUCCESS&lt;/code&gt; for all Peers targeted for request success.&lt;/small&gt;
 *   [Rel: Skylink.GET_CONNECTION_STATUS_STATE]
 * @param {JSON} callback.error The error result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are no errors in request&lt;/small&gt;
 * @param {Array} callback.error.listOfPeers The list of Peer IDs targeted.
 * @param {JSON} callback.error.retrievalErrors The list of Peer connection stats retrieval errors.
 * @param {Error|String} callback.error.retrievalErrors.#peerId The Peer connection stats retrieval error associated
 *   with the Peer ID defined in &lt;code&gt;#peerId&lt;/code&gt; property.
 *   &lt;small&gt;If &lt;code&gt;#peerId&lt;/code&gt; value is &lt;code&gt;&quot;self&quot;&lt;/code&gt;, it means that it is the error when there
 *   are no Peer connections to refresh with.&lt;/small&gt;
 * @param {JSON} callback.error.connectionStats The list of Peer connection stats.
 *   &lt;small&gt;These are the Peer connection stats that has been managed to be successfully retrieved.&lt;/small&gt;
 * @param {JSON} callback.error.connectionStats.#peerId The Peer connection stats associated with
 *   the Peer ID defined in &lt;code&gt;#peerId&lt;/code&gt; property.
 *   &lt;small&gt;Object signature matches the &lt;code&gt;stats&lt;/code&gt; parameter payload received in the
 *   &lt;a href=&quot;#event_getConnectionStatusStateChange&quot;&gt;&lt;code&gt;getConnectionStatusStateChange&lt;/code&gt; event&lt;/a&gt;.&lt;/small&gt;
 * @param {JSON} callback.success The success result in request.
 *   &lt;small&gt;Defined as &lt;code&gt;null&lt;/code&gt; when there are errors in request&lt;/small&gt;
 * @param {Array} callback.success.listOfPeers The list of Peer IDs targeted.
 * @param {JSON} callback.success.connectionStats The list of Peer connection stats.
 * @param {JSON} callback.success.connectionStats.#peerId The Peer connection stats associated with
 *   the Peer ID defined in &lt;code&gt;#peerId&lt;/code&gt; property.
 *   &lt;small&gt;Object signature matches the &lt;code&gt;stats&lt;/code&gt; parameter payload received in the
 *   &lt;a href=&quot;#event_getConnectionStatusStateChange&quot;&gt;&lt;code&gt;getConnectionStatusStateChange&lt;/code&gt; event&lt;/a&gt;.&lt;/small&gt;
 * @trigger &lt;ol class=&quot;desc-seq&quot;&gt;
 *   &lt;li&gt;Retrieves Peer connection stats for all targeted Peers. &lt;ol&gt;
 *   &lt;li&gt;If Peer connection has closed or does not exists: &lt;small&gt;This can be checked with
 *   &lt;a href=&quot;#event_peerConnectionState&quot;&gt;&lt;code&gt;peerConnectionState&lt;/code&gt; event&lt;/a&gt;
 *   triggering parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;CLOSED&lt;/code&gt; for Peer.&lt;/small&gt; &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_getConnectionStatusStateChange&quot;&gt; &lt;code&gt;getConnectionStatusStateChange&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;RETRIEVE_ERROR&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;&lt;b&gt;ABORT&lt;/b&gt; and return error.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_getConnectionStatusStateChange&quot;&gt;&lt;code&gt;getConnectionStatusStateChange&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;RETRIEVING&lt;/code&gt;.&lt;/li&gt;
 *   &lt;li&gt;Received response from retrieval. &lt;ol&gt;
 *   &lt;li&gt;If retrieval was successful: &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_getConnectionStatusStateChange&quot;&gt;&lt;code&gt;getConnectionStatusStateChange&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;RETRIEVE_SUCCESS&lt;/code&gt;.&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;
 *   &lt;li&gt;Else: &lt;ol&gt;
 *   &lt;li&gt;&lt;a href=&quot;#event_getConnectionStatusStateChange&quot;&gt; &lt;code&gt;getConnectionStatusStateChange&lt;/code&gt; event&lt;/a&gt;
 *   triggers parameter payload &lt;code&gt;state&lt;/code&gt; as &lt;code&gt;RETRIEVE_ERROR&lt;/code&gt;.&lt;/li&gt;
 *   &lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
 * @example
 *   // Example 1: Retrieve a Peer connection stats
 *   function startBWStatsInterval (peerId) {
 *     setInterval(function () {
 *       skylinkDemo.getConnectionStatus(peerId, function (error, success) {
 *         if (error) return;
 *         var sendVideoBytes  = success.connectionStats[peerId].video.sending.bytes;
 *         var sendAudioBytes  = success.connectionStats[peerId].audio.sending.bytes;
 *         var recvVideoBytes  = success.connectionStats[peerId].video.receiving.bytes;
 *         var recvAudioBytes  = success.connectionStats[peerId].audio.receiving.bytes;
 *         var localCandidate  = success.connectionStats[peerId].selectedCandidate.local;
 *         var remoteCandidate = success.connectionStats[peerId].selectedCandidate.remote;
 *         console.log(&quot;Sending audio (&quot; + sendAudioBytes + &quot;bps) video (&quot; + sendVideoBytes + &quot;)&quot;);
 *         console.log(&quot;Receiving audio (&quot; + recvAudioBytes + &quot;bps) video (&quot; + recvVideoBytes + &quot;)&quot;);
 *         console.log(&quot;Local candidate: &quot; + localCandidate.ipAddress + &quot;:&quot; + localCandidate.portNumber +
 *           &quot;?transport=&quot; + localCandidate.transport + &quot; (type: &quot; + localCandidate.candidateType + &quot;)&quot;);
 *         console.log(&quot;Remote candidate: &quot; + remoteCandidate.ipAddress + &quot;:&quot; + remoteCandidate.portNumber +
 *           &quot;?transport=&quot; + remoteCandidate.transport + &quot; (type: &quot; + remoteCandidate.candidateType + &quot;)&quot;);
 *       });
 *     }, 1000);
 *   }
 *
 *   // Example 2: Retrieve a list of Peer connection stats
 *   function printConnStats (peerId, data) {
 *     if (!data.connectionStats[peerId]) return;
 *     var sendVideoBytes  = data.connectionStats[peerId].video.sending.bytes;
 *     var sendAudioBytes  = data.connectionStats[peerId].audio.sending.bytes;
 *     var recvVideoBytes  = data.connectionStats[peerId].video.receiving.bytes;
 *     var recvAudioBytes  = data.connectionStats[peerId].audio.receiving.bytes;
 *     var localCandidate  = data.connectionStats[peerId].selectedCandidate.local;
 *     var remoteCandidate = data.connectionStats[peerId].selectedCandidate.remote;
 *     console.log(peerId + &quot; - Sending audio (&quot; + sendAudioBytes + &quot;bps) video (&quot; + sendVideoBytes + &quot;)&quot;);
 *     console.log(peerId + &quot; - Receiving audio (&quot; + recvAudioBytes + &quot;bps) video (&quot; + recvVideoBytes + &quot;)&quot;);
 *     console.log(peerId + &quot; - Local candidate: &quot; + localCandidate.ipAddress + &quot;:&quot; + localCandidate.portNumber +
 *       &quot;?transport=&quot; + localCandidate.transport + &quot; (type: &quot; + localCandidate.candidateType + &quot;)&quot;);
 *     console.log(peerId + &quot; - Remote candidate: &quot; + remoteCandidate.ipAddress + &quot;:&quot; + remoteCandidate.portNumber +
 *       &quot;?transport=&quot; + remoteCandidate.transport + &quot; (type: &quot; + remoteCandidate.candidateType + &quot;)&quot;);
 *   }
 *
 *   function startBWStatsInterval (peerIdA, peerIdB) {
 *     setInterval(function () {
 *       skylinkDemo.getConnectionStatus([peerIdA, peerIdB], function (error, success) {
 *         if (error) {
 *           printConnStats(peerIdA, error.connectionStats);
 *           printConnStats(peerIdB, error.connectionStats);
 *         } else {
 *           printConnStats(peerIdA, success.connectionStats);
 *           printConnStats(peerIdB, success.connectionStats);
 *         }
 *       });
 *     }, 1000);
 *   }
 *
 *   // Example 3: Retrieve all Peer connection stats
 *   function printConnStats (listOfPeers, data) {
 *     listOfPeers.forEach(function (peerId) {
 *       if (!data.connectionStats[peerId]) return;
 *       var sendVideoBytes  = data.connectionStats[peerId].video.sending.bytes;
 *       var sendAudioBytes  = data.connectionStats[peerId].audio.sending.bytes;
 *       var recvVideoBytes  = data.connectionStats[peerId].video.receiving.bytes;
 *       var recvAudioBytes  = data.connectionStats[peerId].audio.receiving.bytes;
 *       var localCandidate  = data.connectionStats[peerId].selectedCandidate.local;
 *       var remoteCandidate = data.connectionStats[peerId].selectedCandidate.remote;
 *       console.log(peerId + &quot; - Sending audio (&quot; + sendAudioBytes + &quot;bps) video (&quot; + sendVideoBytes + &quot;)&quot;);
 *       console.log(peerId + &quot; - Receiving audio (&quot; + recvAudioBytes + &quot;bps) video (&quot; + recvVideoBytes + &quot;)&quot;);
 *       console.log(peerId + &quot; - Local candidate: &quot; + localCandidate.ipAddress + &quot;:&quot; + localCandidate.portNumber +
 *         &quot;?transport=&quot; + localCandidate.transport + &quot; (type: &quot; + localCandidate.candidateType + &quot;)&quot;);
 *       console.log(peerId + &quot; - Remote candidate: &quot; + remoteCandidate.ipAddress + &quot;:&quot; + remoteCandidate.portNumber +
 *         &quot;?transport=&quot; + remoteCandidate.transport + &quot; (type: &quot; + remoteCandidate.candidateType + &quot;)&quot;);
 *     });
 *   }
 *
 *   function startBWStatsInterval (peerIdA, peerIdB) {
 *     setInterval(function () {
 *       skylinkDemo.getConnectionStatus(function (error, success) {
 *         if (error) {
 *           printConnStats(error.listOfPeers, error.connectionStats);
 *         } else {
 *           printConnStats(success.listOfPeers, success.connectionStats);
 *         }
 *       });
 *     }, 1000);
 *   }
 * @for Skylink
 * @since 0.6.14
 */
Skylink.prototype.getConnectionStatus = function (targetPeerId, callback) {
  var self = this;
  var listOfPeers = Object.keys(self._peerConnections);
  var listOfPeerStats = {};
  var listOfPeerErrors = {};

  // getConnectionStatus([])
  if (Array.isArray(targetPeerId)) {
    listOfPeers = targetPeerId;

  // getConnectionStatus(&#x27;...&#x27;)
  } else if (typeof targetPeerId === &#x27;string&#x27; &amp;&amp; !!targetPeerId) {
    listOfPeers = [targetPeerId];

  // getConnectionStatus(function () {})
  } else if (typeof targetPeerId === &#x27;function&#x27;) {
    callback = targetPeerId;
    targetPeerId = undefined;
  }

  // Check if Peers list is empty, in which we throw an Error if there isn&#x27;t any
  if (listOfPeers.length === 0) {
    listOfPeerErrors.self = new Error(&#x27;There is currently no peer connections to retrieve connection status&#x27;);

    log.error([null, &#x27;RTCStatsReport&#x27;, null, &#x27;Retrieving request failure -&gt;&#x27;], listOfPeerErrors.self);

    if (typeof callback === &#x27;function&#x27;) {
      callback({
        listOfPeers: listOfPeers,
        retrievalErrors: listOfPeerErrors,
        connectionStats: listOfPeerStats
      }, null);
    }
    return;
  }

  var completedTaskCounter = [];

  var checkCompletedFn = function (peerId) {
    if (completedTaskCounter.indexOf(peerId) === -1) {
      completedTaskCounter.push(peerId);
    }

    if (completedTaskCounter.length === listOfPeers.length) {
      if (typeof callback === &#x27;function&#x27;) {
        if (Object.keys(listOfPeerErrors).length &gt; 0) {
          callback({
            listOfPeers: listOfPeers,
            retrievalErrors: listOfPeerErrors,
            connectionStats: listOfPeerStats
          }, null);

        } else {
          callback(null, {
            listOfPeers: listOfPeers,
            connectionStats: listOfPeerStats
          });
        }
      }
    }
  };

  var statsFn = function (peerId) {
    log.debug([peerId, &#x27;RTCStatsReport&#x27;, null, &#x27;Retrieivng connection status&#x27;]);

    var pc = self._peerConnections[peerId];
    var result = {
      raw: null,
      connection: {
        iceConnectionState: pc.iceConnectionState,
        iceGatheringState: pc.iceGatheringState,
        signalingState: pc.signalingState,
        remoteDescription: pc.remoteDescription,
        localDescription: pc.localDescription,
        candidates: clone(self._gatheredCandidates[peerId] || {
          sending: { host: [], srflx: [], relay: [] },
          receiving: { host: [], srflx: [], relay: [] }
        })
      },
      audio: {
        sending: {
          ssrc: null,
          bytes: 0,
          packets: 0,
          packetsLost: 0,
          rtt: 0
        },
        receiving: {
          ssrc: null,
          bytes: 0,
          packets: 0,
          packetsLost: 0
        }
      },
      video: {
        sending: {
          ssrc: null,
          bytes: 0,
          packets: 0,
          packetsLost: 0,
          rtt: 0
        },
        receiving: {
          ssrc: null,
          bytes: 0,
          packets: 0,
          packetsLost: 0
        }
      },
      selectedCandidate: {
        local: { ipAddress: null, candidateType: null, portNumber: null, transport: null },
        remote: { ipAddress: null, candidateType: null, portNumber: null, transport: null }
      }
    };
    var loopFn = function (obj, fn) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop) &amp;&amp; obj[prop]) {
          fn(obj[prop], prop);
        }
      }
    };
    var formatCandidateFn = function (candidateDirType, candidate) {
      result.selectedCandidate[candidateDirType].ipAddress = candidate.ipAddress;
      result.selectedCandidate[candidateDirType].candidateType = candidate.candidateType;
      result.selectedCandidate[candidateDirType].portNumber = typeof candidate.portNumber !== &#x27;number&#x27; ?
        parseInt(candidate.portNumber, 10) || null : candidate.portNumber;
      result.selectedCandidate[candidateDirType].transport = candidate.transport;
    };

    pc.getStats(null, function (stats) {
      log.debug([peerId, &#x27;RTCStatsReport&#x27;, null, &#x27;Retrieval success -&gt;&#x27;], stats);

      result.raw = stats;

      if (window.webrtcDetectedBrowser === &#x27;firefox&#x27;) {
        loopFn(stats, function (obj, prop) {
          var dirType = &#x27;&#x27;;

          // Receiving/Sending RTP packets
          if (prop.indexOf(&#x27;inbound_rtp&#x27;) === 0 || prop.indexOf(&#x27;outbound_rtp&#x27;) === 0) {
            dirType = prop.indexOf(&#x27;inbound_rtp&#x27;) === 0 ? &#x27;receiving&#x27; : &#x27;sending&#x27;;

            result[obj.mediaType][dirType].bytes = dirType === &#x27;sending&#x27; ? obj.bytesSent : obj.bytesReceived;
            result[obj.mediaType][dirType].packets = dirType === &#x27;sending&#x27; ? obj.packetsSent : obj.packetsReceived;
            result[obj.mediaType][dirType].ssrc = obj.ssrc;

            if (dirType === &#x27;receiving&#x27;) {
              result[obj.mediaType][dirType].packetsLost = obj.packetsLost || 0;
            }

          // Sending RTP packets lost
          } else if (prop.indexOf(&#x27;outbound_rtcp&#x27;) === 0) {
            dirType = prop.indexOf(&#x27;inbound_rtp&#x27;) === 0 ? &#x27;receiving&#x27; : &#x27;sending&#x27;;

            result[obj.mediaType][dirType].packetsLost = obj.packetsLost || 0;

            if (dirType === &#x27;sending&#x27;) {
              result[obj.mediaType].sending.rtt = obj.mozRtt || 0;
            }

          // Candidates
          } else if (obj.nominated &amp;&amp; obj.selected) {
            formatCandidateFn(&#x27;remote&#x27;, stats[obj.remoteCandidateId]);
            formatCandidateFn(&#x27;local&#x27;, stats[obj.localCandidateId]);
          }
        });

      } else if (window.webrtcDetectedBrowser === &#x27;edge&#x27;) {
        if (pc.getRemoteStreams().length &gt; 0) {
          var tracks = pc.getRemoteStreams()[0].getTracks();

          loopFn(tracks, function (track) {
            loopFn(stats, function (obj, prop) {
              if (obj.type === &#x27;track&#x27; &amp;&amp; obj.trackIdentifier === track.id) {
                loopFn(stats, function (streamObj) {
                  if (streamObj.associateStatsId === obj.id &amp;&amp;
                    [&#x27;outboundrtp&#x27;, &#x27;inboundrtp&#x27;].indexOf(streamObj.type) &gt; -1) {
                    var dirType = streamObj.type === &#x27;outboundrtp&#x27; ? &#x27;sending&#x27; : &#x27;receiving&#x27;;

                    result[track.kind][dirType].bytes = dirType === &#x27;sending&#x27; ? streamObj.bytesSent : streamObj.bytesReceived;
                    result[track.kind][dirType].packets = dirType === &#x27;sending&#x27; ? streamObj.packetsSent : streamObj.packetsReceived;
                    result[track.kind][dirType].packetsLost = streamObj.packetsLost || 0;
                    result[track.kind][dirType].ssrc = parseInt(streamObj.ssrc || &#x27;0&#x27;, 10);

                    if (dirType === &#x27;sending&#x27;) {
                      result[track.kind].sending.rtt = obj.roundTripTime || 0;
                    }
                  }
                });
              }
            });
          });
        }

      } else {
        var reportedCandidate = false;

        loopFn(stats, function (obj, prop) {
          if (prop.indexOf(&#x27;ssrc_&#x27;) === 0) {
            var dirType = prop.indexOf(&#x27;_recv&#x27;) &gt; 0 ? &#x27;receiving&#x27; : &#x27;sending&#x27;;

            // Polyfill fix for plugin. Plugin should fix this though
            if (!obj.mediaType) {
              obj.mediaType = obj.hasOwnProperty(&#x27;audioOutputLevel&#x27;) ||
                obj.hasOwnProperty(&#x27;audioInputLevel&#x27;) ? &#x27;audio&#x27; : &#x27;video&#x27;;
            }

            // Receiving/Sending RTP packets
            result[obj.mediaType][dirType].bytes = parseInt((dirType === &#x27;receiving&#x27; ?
              obj.bytesReceived : obj.bytesSent) || &#x27;0&#x27;, 10);
            result[obj.mediaType][dirType].packets = parseInt((dirType === &#x27;receiving&#x27; ?
              obj.packetsReceived : obj.packetsSent) || &#x27;0&#x27;, 10);
            result[obj.mediaType][dirType].ssrc = parseInt(obj.ssrc || &#x27;0&#x27;, 10);
            result[obj.mediaType][dirType].packetsLost = parseInt(obj.packetsLost || &#x27;0&#x27;, 10);

            if (dirType === &#x27;sending&#x27;) {
              // NOTE: Chrome sending audio does have it but plugin has..
              result[obj.mediaType].sending.rtt = parseInt(obj.googRtt || &#x27;0&#x27;, 10);
            }

            if (!reportedCandidate) {
              loopFn(stats, function (canObj, canProp) {
                if (!reportedCandidate &amp;&amp; canProp.indexOf(&#x27;Conn-&#x27;) === 0) {
                  if (obj.transportId === canObj.googChannelId) {
                    formatCandidateFn(&#x27;local&#x27;, stats[canObj.localCandidateId]);
                    formatCandidateFn(&#x27;remote&#x27;, stats[canObj.remoteCandidateId]);
                    reportedCandidate = true;
                  }
                }
              });
            }
          }
        });
      }

      listOfPeerStats[peerId] = result;

      self._trigger(&#x27;getConnectionStatusStateChange&#x27;, self.GET_CONNECTION_STATUS_STATE.RETRIEVE_SUCCESS,
        peerId, listOfPeerStats[peerId], null);

      checkCompletedFn(peerId);

    }, function (error) {
      log.error([peerId, &#x27;RTCStatsReport&#x27;, null, &#x27;Retrieval failure -&gt;&#x27;], error);

      listOfPeerErrors[peerId] = error;

      self._trigger(&#x27;getConnectionStatusStateChange&#x27;, self.GET_CONNECTION_STATUS_STATE.RETRIEVE_ERROR,
        peerId, null, error);

      checkCompletedFn(peerId);
    });
  };

  // Loop through all the list of Peers selected to retrieve connection status
  for (var i = 0; i &lt; listOfPeers.length; i++) {
    var peerId = listOfPeers[i];

    self._trigger(&#x27;getConnectionStatusStateChange&#x27;, self.GET_CONNECTION_STATUS_STATE.RETRIEVING,
      peerId, null, null);

    // Check if the Peer connection exists first
    if (self._peerConnections.hasOwnProperty(peerId) &amp;&amp; self._peerConnections[peerId]) {
      statsFn(peerId);

    } else {
      listOfPeerErrors[peerId] = new Error(&#x27;The peer connection object does not exists&#x27;);

      log.error([peerId, &#x27;RTCStatsReport&#x27;, null, &#x27;Retrieval failure -&gt;&#x27;], listOfPeerErrors[peerId]);

      self._trigger(&#x27;getConnectionStatusStateChange&#x27;, self.GET_CONNECTION_STATUS_STATE.RETRIEVE_ERROR,
        peerId, null, listOfPeerErrors[peerId]);

      checkCompletedFn(peerId);
    }
  }
};

/**
 * Function that starts the Peer connection session.
 * Remember to remove previous method of reconnection (re-creating the Peer connection - destroy and create connection).
 * @method _addPeer
 * @private
 * @for Skylink
 * @since 0.5.4
 */
Skylink.prototype._addPeer = function(targetMid, peerBrowser, toOffer, restartConn, receiveOnly, isSS) {
  var self = this;
  if (self._peerConnections[targetMid] &amp;&amp; !restartConn) {
    log.error([targetMid, null, null, &#x27;Connection to peer has already been made&#x27;]);
    return;
  }
  log.log([targetMid, null, null, &#x27;Starting the connection to peer. Options provided:&#x27;], {
    peerBrowser: peerBrowser,
    toOffer: toOffer,
    receiveOnly: receiveOnly,
    enableDataChannel: self._enableDataChannel
  });

  log.info(&#x27;Adding peer&#x27;, isSS);

  if (!restartConn) {
    self._peerConnections[targetMid] = self._createPeerConnection(targetMid, !!isSS);
  }

  if (!self._peerConnections[targetMid]) {
    log.error([targetMid, null, null, &#x27;Failed creating the connection to peer&#x27;]);
    return;
  }

  self._peerConnections[targetMid].receiveOnly = !!receiveOnly;
  self._peerConnections[targetMid].hasScreen = !!isSS;
  if (!receiveOnly) {
    self._addLocalMediaStreams(targetMid);
  }
  // I&#x27;m the callee I need to make an offer
  /*if (toOffer) {
    self._doOffer(targetMid, peerBrowser);
  }*/

  // do a peer connection health check
  // let MCU handle this case
  if (!self._hasMCU) {
    this._startPeerConnectionHealthCheck(targetMid, toOffer);
  } else {
    log.warn([targetMid, &#x27;PeerConnectionHealth&#x27;, null, &#x27;Not setting health timer for MCU connection&#x27;]);
    return;
  }
};

/**
 * Function that re-negotiates a Peer connection.
 * We currently do not implement the ICE restart functionality.
 * Remember to remove previous method of reconnection (re-creating the Peer connection - destroy and create connection).
 * @method _restartPeerConnection
 * @private
 * @for Skylink
 * @since 0.5.8
 */
Skylink.prototype._restartPeerConnection = function (peerId, isSelfInitiatedRestart, isConnectionRestart, callback, explicit) {
  var self = this;

  if (!self._peerConnections[peerId]) {
    log.error([peerId, null, null, &#x27;Peer does not have an existing &#x27; +
      &#x27;connection. Unable to restart&#x27;]);
    return;
  }

  delete self._peerConnectionHealth[peerId];

  self._stopPeerConnectionHealthCheck(peerId);

  var pc = self._peerConnections[peerId];

  var agent = (self.getPeerInfo(peerId) || {}).agent || {};

  // prevent restarts for other SDK clients
  if ([&#x27;Android&#x27;, &#x27;iOS&#x27;, &#x27;cpp&#x27;].indexOf(agent.name) &gt; -1) {
    var notSupportedError = new Error(&#x27;Failed restarting with other agents connecting from other SDKs as &#x27; +
      &#x27;re-negotiation is not supported by other SDKs&#x27;);

    log.warn([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Ignoring restart request as agent\&#x27;s SDK does not support it&#x27;],
        notSupportedError);

    if (typeof callback === &#x27;function&#x27;) {
      log.debug([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Firing restart failure callback&#x27;]);
      callback(null, notSupportedError);
    }
    return;
  }

  // This is when the state is stable and re-handshaking is possible
  // This could be due to previous connection handshaking that is already done
  if (pc.signalingState === self.PEER_CONNECTION_STATE.STABLE) {
    if (self._peerConnections[peerId] &amp;&amp; !self._peerConnections[peerId].receiveOnly) {
      self._addLocalMediaStreams(peerId);
    }

    if (isSelfInitiatedRestart){
      log.log([peerId, null, null, &#x27;Sending restart message to signaling server&#x27;]);

      var lastRestart = Date.now() || function() { return +new Date(); };

      self._sendChannelMessage({
        type: self._SIG_MESSAGE_TYPE.RESTART,
        mid: self._user.sid,
        rid: self._room.id,
        agent: window.webrtcDetectedBrowser,
        version: window.webrtcDetectedVersion,
        os: window.navigator.platform,
        userInfo: self._getUserInfo(),
        target: peerId,
        isConnectionRestart: !!isConnectionRestart,
        lastRestart: lastRestart,
        // This will not be used based off the logic in _restartHandler
        weight: self._peerPriorityWeight,
        receiveOnly: self._peerConnections[peerId] &amp;&amp; self._peerConnections[peerId].receiveOnly,
        enableIceTrickle: self._enableIceTrickle,
        enableDataChannel: self._enableDataChannel,
        sessionType: !!self._streams.screenshare ? &#x27;screensharing&#x27; : &#x27;stream&#x27;,
        explicit: !!explicit,
        temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null
      });

      self._trigger(&#x27;peerRestart&#x27;, peerId, self.getPeerInfo(peerId), false);

      if (typeof callback === &#x27;function&#x27;) {
        log.debug([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Firing restart callback&#x27;]);
        callback(null, null);
      }
    } else {
      if (typeof callback === &#x27;function&#x27;) {
        log.debug([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Firing restart callback (receiving peer)&#x27;]);
        callback(null, null);
      }
    }

    // following the previous logic to do checker always
    self._startPeerConnectionHealthCheck(peerId, false);

  } else {
    // Let&#x27;s check if the signalingState is stable first.
    // In another galaxy or universe, where the local description gets dropped..
    // In the offerHandler or answerHandler, do the appropriate flags to ignore or drop &quot;extra&quot; descriptions
    if (pc.signalingState === self.PEER_CONNECTION_STATE.HAVE_LOCAL_OFFER) {
      // Checks if the local description is defined first
      var hasLocalDescription = pc.localDescription &amp;&amp; pc.localDescription.sdp;
      // By then it should have at least the local description..
      if (hasLocalDescription) {
        self._sendChannelMessage({
          type: pc.localDescription.type,
          sdp: pc.localDescription.sdp,
          mid: self._user.sid,
          target: peerId,
          rid: self._room.id,
          restart: true
        });
      } else {
        var noLocalDescriptionError = &#x27;Failed re-sending localDescription as there is &#x27; +
          &#x27;no localDescription set to connection. There could be a handshaking step error&#x27;;
        log.error([peerId, &#x27;RTCPeerConnection&#x27;, null, noLocalDescriptionError], {
            localDescription: pc.localDescription,
            remoteDescription: pc.remoteDescription
        });
        if (typeof callback === &#x27;function&#x27;) {
          log.debug([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Firing restart failure callback&#x27;]);
          callback(null, new Error(noLocalDescriptionError));
        }
      }
    // It could have connection state closed
    } else {
      var unableToRestartError = &#x27;Failed restarting as peer connection state is &#x27; + pc.signalingState;
      log.warn([peerId, &#x27;RTCPeerConnection&#x27;, null, unableToRestartError]);
      if (typeof callback === &#x27;function&#x27;) {
        log.debug([peerId, &#x27;RTCPeerConnection&#x27;, null, &#x27;Firing restart failure callback&#x27;]);
        callback(null, new Error(unableToRestartError));
      }
    }
  }
};

/**
 * Function that ends the Peer connection session.
 * @method _removePeer
 * @private
 * @for Skylink
 * @since 0.5.5
 */
Skylink.prototype._removePeer = function(peerId) {
  var peerInfo = clone(this.getPeerInfo(peerId)) || {
    userData: &#x27;&#x27;,
    settings: {},
    mediaStatus: {},
    agent: {},
    room: clone(this._selectedRoom)
  };

  if (peerId !== &#x27;MCU&#x27;) {
    this._trigger(&#x27;peerLeft&#x27;, peerId, peerInfo, false);
  } else {
    this._hasMCU = false;
    log.log([peerId, null, null, &#x27;MCU has stopped listening and left&#x27;]);
    this._trigger(&#x27;serverPeerLeft&#x27;, peerId, this.SERVER_PEER_TYPE.MCU);
  }
  // stop any existing peer health timer
  this._stopPeerConnectionHealthCheck(peerId);

  // check if health timer exists
  if (typeof this._peerConnections[peerId] !== &#x27;undefined&#x27;) {
    // new flag to check if datachannels are all closed
    this._peerConnections[peerId].dataChannelClosed = true;

    if (this._peerConnections[peerId].signalingState !== &#x27;closed&#x27;) {
      this._peerConnections[peerId].close();
    }

    if (this._peerConnections[peerId].hasStream) {
      this._trigger(&#x27;streamEnded&#x27;, peerId, this.getPeerInfo(peerId), false);
    }

    delete this._peerConnections[peerId];
  }
  // remove peer informations session
  if (typeof this._peerInformations[peerId] !== &#x27;undefined&#x27;) {
    delete this._peerInformations[peerId];
  }
  // remove peer messages stamps session
  if (typeof this._peerMessagesStamps[peerId] !== &#x27;undefined&#x27;) {
    delete this._peerMessagesStamps[peerId];
  }
  
  if (typeof this._peerConnectionHealth[peerId] !== &#x27;undefined&#x27;) {
    delete this._peerConnectionHealth[peerId];
  }
  // close datachannel connection
  if (this._enableDataChannel) {
    this._closeDataChannel(peerId);
  }

  log.log([peerId, null, null, &#x27;Successfully removed peer&#x27;]);
};

/**
 * Function that creates the Peer connection.
 * @method _createPeerConnection
 * @private
 * @for Skylink
 * @since 0.5.1
 */
Skylink.prototype._createPeerConnection = function(targetMid, isScreenSharing) {
  var pc, self = this;
  // currently the AdapterJS 0.12.1-2 causes an issue to prevent firefox from
  // using .urls feature
  try {
    pc = new window.RTCPeerConnection(
      self._room.connection.peerConfig,
      self._room.connection.peerConstraints);
    log.info([targetMid, null, null, &#x27;Created peer connection&#x27;]);
    log.debug([targetMid, null, null, &#x27;Peer connection config:&#x27;],
      self._room.connection.peerConfig);
    log.debug([targetMid, null, null, &#x27;Peer connection constraints:&#x27;],
      self._room.connection.peerConstraints);
  } catch (error) {
    log.error([targetMid, null, null, &#x27;Failed creating peer connection:&#x27;], error);
    return null;
  }
  // attributes (added on by Temasys)
  pc.setOffer = &#x27;&#x27;;
  pc.setAnswer = &#x27;&#x27;;
  pc.hasStream = false;
  pc.hasScreen = !!isScreenSharing;
  pc.hasMainChannel = false;
  pc.firefoxStreamId = &#x27;&#x27;;
  pc.processingLocalSDP = false;
  pc.processingRemoteSDP = false;
  pc.gathered = false;

  // candidates
  self._gatheredCandidates[targetMid] = {
    sending: { host: [], srflx: [], relay: [] },
    receiving: { host: [], srflx: [], relay: [] }
  };

  // callbacks
  // standard not implemented: onnegotiationneeded,
  pc.ondatachannel = function(event) {
    var dc = event.channel || event;
    log.debug([targetMid, &#x27;RTCDataChannel&#x27;, dc.label, &#x27;Received datachannel -&gt;&#x27;], dc);
    if (self._enableDataChannel) {

      var channelType = self.DATA_CHANNEL_TYPE.DATA;
      var channelKey = dc.label;

      // if peer does not have main channel, the first item is main
      if (!pc.hasMainChannel) {
        channelType = self.DATA_CHANNEL_TYPE.MESSAGING;
        channelKey = &#x27;main&#x27;;
        pc.hasMainChannel = true;
      }

      self._createDataChannel(targetMid, dc);

    } else {
      log.warn([targetMid, &#x27;RTCDataChannel&#x27;, dc.label, &#x27;Not adding datachannel as enable datachannel &#x27; +
        &#x27;is set to false&#x27;]);
    }
  };
  pc.onaddstream = function(event) {
    var stream = event.stream || event;

    if (targetMid === &#x27;MCU&#x27;) {
      log.debug([targetMid, &#x27;MediaStream&#x27;, stream.id, &#x27;Ignoring received remote stream from MCU -&gt;&#x27;], stream);
      return;
    }

    pc.hasStream = true;

    var agent = (self.getPeerInfo(targetMid) || {}).agent || {};
    var timeout = 0;

    // NOTE: Add timeouts to the firefox stream received because it seems to have some sort of black stream rendering at first
    // This may not be advisable but that it seems to work after 1500s. (tried with ICE established but it does not work and getStats)
    if (agent.name === &#x27;firefox&#x27; &amp;&amp; window.webrtcDetectedBrowser !== &#x27;firefox&#x27;) {
      timeout = 1500;
    }
    setTimeout(function () {
      self._onRemoteStreamAdded(targetMid, stream, !!pc.hasScreen);
    }, timeout);
  };
  pc.onicecandidate = function(event) {
    var candidate = event.candidate || event;

    if (candidate.candidate) {
      pc.gathered = false;
    } else {
      pc.gathered = true;
    }

    log.debug([targetMid, &#x27;RTCIceCandidate&#x27;, null, &#x27;Ice candidate generated -&gt;&#x27;], candidate);
    self._onIceCandidate(targetMid, candidate);
  };
  pc.oniceconnectionstatechange = function(evt) {
    checkIceConnectionState(targetMid, pc.iceConnectionState,
      function(iceConnectionState) {
      log.debug([targetMid, &#x27;RTCIceConnectionState&#x27;, null,
        &#x27;Ice connection state changed -&gt;&#x27;], iceConnectionState);
      self._trigger(&#x27;iceConnectionState&#x27;, iceConnectionState, targetMid);

      // clear all peer connection health check
      // peer connection is stable. now if there is a waiting check on it
      if (iceConnectionState === self.ICE_CONNECTION_STATE.COMPLETED &amp;&amp;
        pc.signalingState === self.PEER_CONNECTION_STATE.STABLE) {
        log.debug([targetMid, &#x27;PeerConnectionHealth&#x27;, null,
          &#x27;Peer connection with user is stable&#x27;]);
        self._peerConnectionHealth[targetMid] = true;
        self._stopPeerConnectionHealthCheck(targetMid);
        self._retryCount = 0;
      }

      if (typeof self._ICEConnectionFailures[targetMid] === &#x27;undefined&#x27;) {
        self._ICEConnectionFailures[targetMid] = 0;
      }

      if (iceConnectionState === self.ICE_CONNECTION_STATE.FAILED) {
        self._ICEConnectionFailures[targetMid] += 1;

        if (self._enableIceTrickle) {
          self._trigger(&#x27;iceConnectionState&#x27;,
            self.ICE_CONNECTION_STATE.TRICKLE_FAILED, targetMid);
        }

        // refresh when failed. ignore for MCU case since restart is handled by MCU in this case
        if (!self._hasMCU) {
          self._restartPeerConnection(targetMid, true, true, null, false);
        }
      }

      /**** SJS-53: Revert of commit ******
      // resend if failed
      if (iceConnectionState === self.ICE_CONNECTION_STATE.FAILED) {
        log.debug([targetMid, &#x27;RTCIceConnectionState&#x27;, null,
          &#x27;Ice connection state failed. Re-negotiating connection&#x27;]);
        self._removePeer(targetMid);
        self._sendChannelMessage({
          type: self._SIG_MESSAGE_TYPE.WELCOME,
          mid: self._user.sid,
          rid: self._room.id,
          agent: window.webrtcDetectedBrowser,
          version: window.webrtcDetectedVersion,
          userInfo: self._getUserInfo(),
          target: targetMid,
          restartNego: true,
          hsPriority: -1
        });
      } *****/
    });
  };
  // pc.onremovestream = function () {
  //   self._onRemoteStreamRemoved(targetMid);
  // };
  pc.onsignalingstatechange = function() {
    log.debug([targetMid, &#x27;RTCSignalingState&#x27;, null,
      &#x27;Peer connection state changed -&gt;&#x27;], pc.signalingState);
    self._trigger(&#x27;peerConnectionState&#x27;, pc.signalingState, targetMid);

    // clear all peer connection health check
    // peer connection is stable. now if there is a waiting check on it
    if ((pc.iceConnectionState === self.ICE_CONNECTION_STATE.COMPLETED ||
      pc.iceConnectionState === self.ICE_CONNECTION_STATE.CONNECTED) &amp;&amp;
      pc.signalingState === self.PEER_CONNECTION_STATE.STABLE) {
      log.debug([targetMid, &#x27;PeerConnectionHealth&#x27;, null,
        &#x27;Peer connection with user is stable&#x27;]);
      self._peerConnectionHealth[targetMid] = true;
      self._stopPeerConnectionHealthCheck(targetMid);
      self._retryCount = 0;
    }
  };
  pc.onicegatheringstatechange = function() {
    log.log([targetMid, &#x27;RTCIceGatheringState&#x27;, null,
      &#x27;Ice gathering state changed -&gt;&#x27;], pc.iceGatheringState);
    self._trigger(&#x27;candidateGenerationState&#x27;, pc.iceGatheringState, targetMid);
  };

  if (window.webrtcDetectedBrowser === &#x27;firefox&#x27;) {
    pc.removeStream = function (stream) {
      var senders = pc.getSenders();
      for (var s = 0; s &lt; senders.length; s++) {
        var tracks = stream.getTracks();
        for (var t = 0; t &lt; tracks.length; t++) {
          if (tracks[t] === senders[s].track) {
            pc.removeTrack(senders[s]);
          }
        }
      }
    };
  }

  return pc;
};

/**
 * Function that handles the &lt;code&gt;_restartPeerConnection&lt;/code&gt; scenario
 *   for MCU enabled Peer connections.
 * This is implemented currently by making the user leave and join the Room again.
 * The Peer ID will not stay the same though.
 * @method _restartMCUConnection
 * @private
 * @for Skylink
 * @since 0.6.1
 */
Skylink.prototype._restartMCUConnection = function(callback) {
  var self = this;
  log.info([self._user.sid, null, null, &#x27;Restarting with MCU enabled&#x27;]);
  // Save room name
  /*var roomName = (self._room.id).substring((self._room.id)
                    .indexOf(&#x27;_api_&#x27;) + 5, (self._room.id).length);*/
  var listOfPeers = Object.keys(self._peerConnections);
  var listOfPeerRestartErrors = {};
  var peerId; // j shint is whinning
  var receiveOnly = false;
  // for MCU case, these dont matter at all
  var lastRestart = Date.now() || function() { return +new Date(); };
  var weight = (new Date()).valueOf();

  self._trigger(&#x27;serverPeerRestart&#x27;, &#x27;MCU&#x27;, self.SERVER_PEER_TYPE.MCU);

  for (var i = 0; i &lt; listOfPeers.length; i++) {
    peerId = listOfPeers[i];

    if (!self._peerConnections[peerId]) {
      var error = &#x27;Peer connection with peer does not exists. Unable to restart&#x27;;
      log.error([peerId, &#x27;PeerConnection&#x27;, null, error]);
      listOfPeerRestartErrors[peerId] = new Error(error);
      continue;
    }

    if (peerId === &#x27;MCU&#x27;) {
      receiveOnly = !!self._peerConnections[peerId].receiveOnly;
    }

    if (peerId !== &#x27;MCU&#x27;) {
      self._trigger(&#x27;peerRestart&#x27;, peerId, self.getPeerInfo(peerId), true);

      log.log([peerId, null, null, &#x27;Sending restart message to signaling server&#x27;]);

      self._sendChannelMessage({
        type: self._SIG_MESSAGE_TYPE.RESTART,
        mid: self._user.sid,
        rid: self._room.id,
        agent: window.webrtcDetectedBrowser,
        version: window.webrtcDetectedVersion,
        os: window.navigator.platform,
        userInfo: self._getUserInfo(),
        target: peerId, //&#x27;MCU&#x27;,
        isConnectionRestart: false,
        lastRestart: lastRestart,
        weight: self._peerPriorityWeight,
        receiveOnly: receiveOnly,
        enableIceTrickle: self._enableIceTrickle,
        enableDataChannel: self._enableDataChannel,
        sessionType: !!self._streams.screenshare ? &#x27;screensharing&#x27; : &#x27;stream&#x27;,
        explicit: true,
        temasysPluginVersion: AdapterJS.WebRTCPlugin.plugin ? AdapterJS.WebRTCPlugin.plugin.VERSION : null
      });
    }
  }

  // Restart with MCU = peer leaves then rejoins room
  var peerJoinedFn = function (peerId, peerInfo, isSelf) {
    log.log([null, &#x27;PeerConnection&#x27;, null, &#x27;Invoked all peers to restart with MCU. Firing callback&#x27;]);

    if (typeof callback === &#x27;function&#x27;) {
      if (Object.keys(listOfPeerRestartErrors).length &gt; 0) {
        callback({
          refreshErrors: listOfPeerRestartErrors,
          listOfPeers: listOfPeers
        }, null);
      } else {
        callback(null, {
          listOfPeers: listOfPeers
        });
      }
    }
  };

  self.once(&#x27;peerJoined&#x27;, peerJoinedFn, function (peerId, peerInfo, isSelf) {
    return isSelf;
  });

  self.leaveRoom(false, function (error, success) {
    if (error) {
      if (typeof callback === &#x27;function&#x27;) {
        for (var i = 0; i &lt; listOfPeers.length; i++) {
          listOfPeerRestartErrors[listOfPeers[i]] = error;
        }
        callback({
          refreshErrors: listOfPeerRestartErrors,
          listOfPeers: listOfPeers
        }, null);
      }
    } else {
      //self._trigger(&#x27;serverPeerLeft&#x27;, &#x27;MCU&#x27;, self.SERVER_PEER_TYPE.MCU);
      self.joinRoom(self._selectedRoom);
    }
  });
};

    </pre>
</div>

                  </div>
              </div>
          </div>
      </div>
  </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
